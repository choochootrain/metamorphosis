/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/static/assets/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!****************************!*\
  !*** ./static/js/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 1)['default'];

	__webpack_require__(/*! index.scss */ 2);

	__webpack_require__(/*! babel-core/polyfill */ 3);

	var _statsJs = __webpack_require__(/*! stats.js */ 191);

	var _statsJs2 = _interopRequireDefault(_statsJs);

	var _game = __webpack_require__(/*! game */ 192);

	var _game2 = _interopRequireDefault(_game);

	var _amoeba_simulation = __webpack_require__(/*! amoeba_simulation */ 251);

	var _amoeba_simulation2 = _interopRequireDefault(_amoeba_simulation);

	document.addEventListener("DOMContentLoaded", function () {
	    var stats = new _statsJs2['default']();
	    stats.setMode(1);

	    stats.domElement.style.position = "absolute";
	    stats.domElement.style.left = "0px";
	    stats.domElement.style.bottom = "0px";
	    document.body.appendChild(stats.domElement);

	    var game;
	    switch (window.location.hash) {
	        case "#simulation":
	            game = new _amoeba_simulation2['default']("glcontainer");
	            break;
	        default:
	            game = new _game2['default']("glcontainer");
	            break;
	    }

	    game.init();

	    var animate = function animate() {
	        stats.begin();

	        game.update();
	        game.render();

	        stats.end();

	        requestAnimationFrame(animate);
	    };

	    animate();
	});

/***/ },
/* 1 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/helpers/interop-require-default.js ***!
  \************************************************************/
/***/ function(module, exports) {

	"use strict";

	exports["default"] = function (obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	};

	exports.__esModule = true;

/***/ },
/* 2 */
/*!********************************!*\
  !*** ./static/scss/index.scss ***!
  \********************************/
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 3 */
/*!**********************************!*\
  !*** ./~/babel-core/polyfill.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/polyfill */ 4);


/***/ },
/* 4 */
/*!**************************************!*\
  !*** ./~/babel-core/lib/polyfill.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	__webpack_require__(/*! core-js/shim */ 5);

	__webpack_require__(/*! regenerator/runtime */ 189);

	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel/polyfill is allowed");
	}
	global._babelPolyfill = true;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 5 */
/*!****************************************!*\
  !*** ./~/babel-core/~/core-js/shim.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./modules/es5 */ 6);
	__webpack_require__(/*! ./modules/es6.symbol */ 38);
	__webpack_require__(/*! ./modules/es6.object.assign */ 44);
	__webpack_require__(/*! ./modules/es6.object.is */ 46);
	__webpack_require__(/*! ./modules/es6.object.set-prototype-of */ 48);
	__webpack_require__(/*! ./modules/es6.object.to-string */ 50);
	__webpack_require__(/*! ./modules/es6.object.freeze */ 52);
	__webpack_require__(/*! ./modules/es6.object.seal */ 54);
	__webpack_require__(/*! ./modules/es6.object.prevent-extensions */ 55);
	__webpack_require__(/*! ./modules/es6.object.is-frozen */ 56);
	__webpack_require__(/*! ./modules/es6.object.is-sealed */ 57);
	__webpack_require__(/*! ./modules/es6.object.is-extensible */ 58);
	__webpack_require__(/*! ./modules/es6.object.get-own-property-descriptor */ 59);
	__webpack_require__(/*! ./modules/es6.object.get-prototype-of */ 60);
	__webpack_require__(/*! ./modules/es6.object.keys */ 61);
	__webpack_require__(/*! ./modules/es6.object.get-own-property-names */ 62);
	__webpack_require__(/*! ./modules/es6.function.name */ 63);
	__webpack_require__(/*! ./modules/es6.function.has-instance */ 64);
	__webpack_require__(/*! ./modules/es6.number.constructor */ 65);
	__webpack_require__(/*! ./modules/es6.number.epsilon */ 66);
	__webpack_require__(/*! ./modules/es6.number.is-finite */ 67);
	__webpack_require__(/*! ./modules/es6.number.is-integer */ 68);
	__webpack_require__(/*! ./modules/es6.number.is-nan */ 70);
	__webpack_require__(/*! ./modules/es6.number.is-safe-integer */ 71);
	__webpack_require__(/*! ./modules/es6.number.max-safe-integer */ 72);
	__webpack_require__(/*! ./modules/es6.number.min-safe-integer */ 73);
	__webpack_require__(/*! ./modules/es6.number.parse-float */ 74);
	__webpack_require__(/*! ./modules/es6.number.parse-int */ 75);
	__webpack_require__(/*! ./modules/es6.math.acosh */ 76);
	__webpack_require__(/*! ./modules/es6.math.asinh */ 78);
	__webpack_require__(/*! ./modules/es6.math.atanh */ 79);
	__webpack_require__(/*! ./modules/es6.math.cbrt */ 80);
	__webpack_require__(/*! ./modules/es6.math.clz32 */ 82);
	__webpack_require__(/*! ./modules/es6.math.cosh */ 83);
	__webpack_require__(/*! ./modules/es6.math.expm1 */ 84);
	__webpack_require__(/*! ./modules/es6.math.fround */ 86);
	__webpack_require__(/*! ./modules/es6.math.hypot */ 87);
	__webpack_require__(/*! ./modules/es6.math.imul */ 88);
	__webpack_require__(/*! ./modules/es6.math.log10 */ 89);
	__webpack_require__(/*! ./modules/es6.math.log1p */ 90);
	__webpack_require__(/*! ./modules/es6.math.log2 */ 91);
	__webpack_require__(/*! ./modules/es6.math.sign */ 92);
	__webpack_require__(/*! ./modules/es6.math.sinh */ 93);
	__webpack_require__(/*! ./modules/es6.math.tanh */ 94);
	__webpack_require__(/*! ./modules/es6.math.trunc */ 95);
	__webpack_require__(/*! ./modules/es6.string.from-code-point */ 96);
	__webpack_require__(/*! ./modules/es6.string.raw */ 97);
	__webpack_require__(/*! ./modules/es6.string.trim */ 98);
	__webpack_require__(/*! ./modules/es6.string.iterator */ 100);
	__webpack_require__(/*! ./modules/es6.string.code-point-at */ 105);
	__webpack_require__(/*! ./modules/es6.string.ends-with */ 106);
	__webpack_require__(/*! ./modules/es6.string.includes */ 110);
	__webpack_require__(/*! ./modules/es6.string.repeat */ 111);
	__webpack_require__(/*! ./modules/es6.string.starts-with */ 113);
	__webpack_require__(/*! ./modules/es6.array.from */ 114);
	__webpack_require__(/*! ./modules/es6.array.of */ 119);
	__webpack_require__(/*! ./modules/es6.array.iterator */ 120);
	__webpack_require__(/*! ./modules/es6.array.species */ 123);
	__webpack_require__(/*! ./modules/es6.array.copy-within */ 125);
	__webpack_require__(/*! ./modules/es6.array.fill */ 127);
	__webpack_require__(/*! ./modules/es6.array.find */ 129);
	__webpack_require__(/*! ./modules/es6.array.find-index */ 130);
	__webpack_require__(/*! ./modules/es6.regexp.constructor */ 131);
	__webpack_require__(/*! ./modules/es6.regexp.flags */ 133);
	__webpack_require__(/*! ./modules/es6.regexp.match */ 134);
	__webpack_require__(/*! ./modules/es6.regexp.replace */ 136);
	__webpack_require__(/*! ./modules/es6.regexp.search */ 137);
	__webpack_require__(/*! ./modules/es6.regexp.split */ 138);
	__webpack_require__(/*! ./modules/es6.promise */ 139);
	__webpack_require__(/*! ./modules/es6.map */ 145);
	__webpack_require__(/*! ./modules/es6.set */ 148);
	__webpack_require__(/*! ./modules/es6.weak-map */ 149);
	__webpack_require__(/*! ./modules/es6.weak-set */ 151);
	__webpack_require__(/*! ./modules/es6.reflect.apply */ 152);
	__webpack_require__(/*! ./modules/es6.reflect.construct */ 153);
	__webpack_require__(/*! ./modules/es6.reflect.define-property */ 154);
	__webpack_require__(/*! ./modules/es6.reflect.delete-property */ 155);
	__webpack_require__(/*! ./modules/es6.reflect.enumerate */ 156);
	__webpack_require__(/*! ./modules/es6.reflect.get */ 157);
	__webpack_require__(/*! ./modules/es6.reflect.get-own-property-descriptor */ 158);
	__webpack_require__(/*! ./modules/es6.reflect.get-prototype-of */ 159);
	__webpack_require__(/*! ./modules/es6.reflect.has */ 160);
	__webpack_require__(/*! ./modules/es6.reflect.is-extensible */ 161);
	__webpack_require__(/*! ./modules/es6.reflect.own-keys */ 162);
	__webpack_require__(/*! ./modules/es6.reflect.prevent-extensions */ 164);
	__webpack_require__(/*! ./modules/es6.reflect.set */ 165);
	__webpack_require__(/*! ./modules/es6.reflect.set-prototype-of */ 166);
	__webpack_require__(/*! ./modules/es7.array.includes */ 167);
	__webpack_require__(/*! ./modules/es7.string.at */ 168);
	__webpack_require__(/*! ./modules/es7.string.pad-left */ 169);
	__webpack_require__(/*! ./modules/es7.string.pad-right */ 171);
	__webpack_require__(/*! ./modules/es7.string.trim-left */ 172);
	__webpack_require__(/*! ./modules/es7.string.trim-right */ 173);
	__webpack_require__(/*! ./modules/es7.regexp.escape */ 174);
	__webpack_require__(/*! ./modules/es7.object.get-own-property-descriptors */ 176);
	__webpack_require__(/*! ./modules/es7.object.values */ 177);
	__webpack_require__(/*! ./modules/es7.object.entries */ 179);
	__webpack_require__(/*! ./modules/es7.map.to-json */ 180);
	__webpack_require__(/*! ./modules/es7.set.to-json */ 182);
	__webpack_require__(/*! ./modules/js.array.statics */ 183);
	__webpack_require__(/*! ./modules/web.timers */ 184);
	__webpack_require__(/*! ./modules/web.immediate */ 187);
	__webpack_require__(/*! ./modules/web.dom.iterable */ 188);
	module.exports = __webpack_require__(/*! ./modules/$.core */ 18);

/***/ },
/* 6 */
/*!***********************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es5.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $                = __webpack_require__(/*! ./$ */ 7)
	  , SUPPORT_DESC     = __webpack_require__(/*! ./$.support-desc */ 8)
	  , createDesc       = __webpack_require__(/*! ./$.property-desc */ 10)
	  , html             = __webpack_require__(/*! ./$.html */ 11)
	  , cel              = __webpack_require__(/*! ./$.dom-create */ 13)
	  , has              = __webpack_require__(/*! ./$.has */ 15)
	  , cof              = __webpack_require__(/*! ./$.cof */ 16)
	  , $def             = __webpack_require__(/*! ./$.def */ 17)
	  , invoke           = __webpack_require__(/*! ./$.invoke */ 22)
	  , arrayMethod      = __webpack_require__(/*! ./$.array-methods */ 23)
	  , IE_PROTO         = __webpack_require__(/*! ./$.uid */ 21)('__proto__')
	  , isObject         = __webpack_require__(/*! ./$.is-object */ 14)
	  , anObject         = __webpack_require__(/*! ./$.an-object */ 34)
	  , aFunction        = __webpack_require__(/*! ./$.a-function */ 25)
	  , toObject         = __webpack_require__(/*! ./$.to-object */ 27)
	  , toIObject        = __webpack_require__(/*! ./$.to-iobject */ 35)
	  , toInteger        = __webpack_require__(/*! ./$.to-integer */ 30)
	  , toIndex          = __webpack_require__(/*! ./$.to-index */ 36)
	  , toLength         = __webpack_require__(/*! ./$.to-length */ 29)
	  , IObject          = __webpack_require__(/*! ./$.iobject */ 26)
	  , fails            = __webpack_require__(/*! ./$.fails */ 9)
	  , ObjectProto      = Object.prototype
	  , A                = []
	  , _slice           = A.slice
	  , _join            = A.join
	  , defineProperty   = $.setDesc
	  , getOwnDescriptor = $.getDesc
	  , defineProperties = $.setDescs
	  , $indexOf         = __webpack_require__(/*! ./$.array-includes */ 37)(false)
	  , factories        = {}
	  , IE8_DOM_DEFINE;

	if(!SUPPORT_DESC){
	  IE8_DOM_DEFINE = !fails(function(){
	    return defineProperty(cel('div'), 'a', {get: function(){ return 7; }}).a != 7;
	  });
	  $.setDesc = function(O, P, Attributes){
	    if(IE8_DOM_DEFINE)try {
	      return defineProperty(O, P, Attributes);
	    } catch(e){ /* empty */ }
	    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	    if('value' in Attributes)anObject(O)[P] = Attributes.value;
	    return O;
	  };
	  $.getDesc = function(O, P){
	    if(IE8_DOM_DEFINE)try {
	      return getOwnDescriptor(O, P);
	    } catch(e){ /* empty */ }
	    if(has(O, P))return createDesc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
	  };
	  $.setDescs = defineProperties = function(O, Properties){
	    anObject(O);
	    var keys   = $.getKeys(Properties)
	      , length = keys.length
	      , i = 0
	      , P;
	    while(length > i)$.setDesc(O, P = keys[i++], Properties[P]);
	    return O;
	  };
	}
	$def($def.S + $def.F * !SUPPORT_DESC, 'Object', {
	  // 19.1.2.6 / 15.2.3.3 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $.getDesc,
	  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	  defineProperty: $.setDesc,
	  // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	  defineProperties: defineProperties
	});

	  // IE 8- don't enum bug keys
	var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' +
	            'toLocaleString,toString,valueOf').split(',')
	  // Additional keys for getOwnPropertyNames
	  , keys2 = keys1.concat('length', 'prototype')
	  , keysLen1 = keys1.length;

	// Create object with `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = cel('iframe')
	    , i      = keysLen1
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict.prototype[keys1[i]];
	  return createDict();
	};
	var createGetKeys = function(names, length){
	  return function(object){
	    var O      = toIObject(object)
	      , i      = 0
	      , result = []
	      , key;
	    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	    // Don't enum bug & hidden keys
	    while(length > i)if(has(O, key = names[i++])){
	      ~$indexOf(result, key) || result.push(key);
	    }
	    return result;
	  };
	};
	var Empty = function(){};
	$def($def.S, 'Object', {
	  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	  getPrototypeOf: $.getProto = $.getProto || function(O){
	    O = toObject(O);
	    if(has(O, IE_PROTO))return O[IE_PROTO];
	    if(typeof O.constructor == 'function' && O instanceof O.constructor){
	      return O.constructor.prototype;
	    } return O instanceof Object ? ObjectProto : null;
	  },
	  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
	  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	  create: $.create = $.create || function(O, /*?*/Properties){
	    var result;
	    if(O !== null){
	      Empty.prototype = anObject(O);
	      result = new Empty();
	      Empty.prototype = null;
	      // add "__proto__" for Object.getPrototypeOf shim
	      result[IE_PROTO] = O;
	    } else result = createDict();
	    return Properties === undefined ? result : defineProperties(result, Properties);
	  },
	  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
	  keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false)
	});

	var construct = function(F, len, args){
	  if(!(len in factories)){
	    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  }
	  return factories[len](F, args);
	};

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	$def($def.P, 'Function', {
	  bind: function bind(that /*, args... */){
	    var fn       = aFunction(this)
	      , partArgs = _slice.call(arguments, 1);
	    var bound = function(/* args... */){
	      var args = partArgs.concat(_slice.call(arguments));
	      return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	    };
	    if(isObject(fn.prototype))bound.prototype = fn.prototype;
	    return bound;
	  }
	});

	// fallback for not array-like ES3 strings and DOM objects
	var buggySlice = fails(function(){
	  if(html)_slice.call(html);
	});

	$def($def.P + $def.F * buggySlice, 'Array', {
	  slice: function(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return _slice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});
	$def($def.P + $def.F * (IObject != Object), 'Array', {
	  join: function(){
	    return _join.apply(IObject(this), arguments);
	  }
	});

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	$def($def.S, 'Array', {isArray: __webpack_require__(/*! ./$.is-array */ 31)});

	var createArrayReduce = function(isRight){
	  return function(callbackfn, memo){
	    aFunction(callbackfn);
	    var O      = IObject(this)
	      , length = toLength(O.length)
	      , index  = isRight ? length - 1 : 0
	      , i      = isRight ? -1 : 1;
	    if(arguments.length < 2)for(;;){
	      if(index in O){
	        memo = O[index];
	        index += i;
	        break;
	      }
	      index += i;
	      if(isRight ? index < 0 : length <= index){
	        throw TypeError('Reduce of empty array with no initial value');
	      }
	    }
	    for(;isRight ? index >= 0 : length > index; index += i)if(index in O){
	      memo = callbackfn(memo, O[index], index, this);
	    }
	    return memo;
	  };
	};
	var methodize = function($fn){
	  return function(arg1/*, arg2 = undefined */){
	    return $fn(this, arg1, arguments[1]);
	  };
	};
	$def($def.P, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: $.each = $.each || methodize(arrayMethod(0)),
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: methodize(arrayMethod(1)),
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: methodize(arrayMethod(2)),
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: methodize(arrayMethod(3)),
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: methodize(arrayMethod(4)),
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: createArrayReduce(false),
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: createArrayReduce(true),
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: methodize($indexOf),
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function(el, fromIndex /* = @[*-1] */){
	    var O      = toIObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, toInteger(fromIndex));
	    if(index < 0)index = toLength(length + index);
	    for(;index >= 0; index--)if(index in O)if(O[index] === el)return index;
	    return -1;
	  }
	});

	// 20.3.3.1 / 15.9.4.4 Date.now()
	$def($def.S, 'Date', {now: function(){ return +new Date; }});

	var lz = function(num){
	  return num > 9 ? num : '0' + num;
	};

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	// PhantomJS and old webkit had a broken Date implementation.
	var date       = new Date(-5e13 - 1)
	  , brokenDate = !(date.toISOString && date.toISOString() == '0385-07-25T07:06:39.999Z'
	      && fails(function(){ new Date(NaN).toISOString(); }));
	$def($def.P + $def.F * brokenDate, 'Date', {
	  toISOString: function toISOString(){
	    if(!isFinite(this))throw RangeError('Invalid time value');
	    var d = this
	      , y = d.getUTCFullYear()
	      , m = d.getUTCMilliseconds()
	      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ },
/* 7 */
/*!*********************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.js ***!
  \*********************************************/
/***/ function(module, exports) {

	var $Object = Object;
	module.exports = {
	  create:     $Object.create,
	  getProto:   $Object.getPrototypeOf,
	  isEnum:     {}.propertyIsEnumerable,
	  getDesc:    $Object.getOwnPropertyDescriptor,
	  setDesc:    $Object.defineProperty,
	  setDescs:   $Object.defineProperties,
	  getKeys:    $Object.keys,
	  getNames:   $Object.getOwnPropertyNames,
	  getSymbols: $Object.getOwnPropertySymbols,
	  each:       [].forEach
	};

/***/ },
/* 8 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.support-desc.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(/*! ./$.fails */ 9)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 9 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.fails.js ***!
  \***************************************************/
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 10 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.property-desc.js ***!
  \***********************************************************/
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 11 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.html.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./$.global */ 12).document && document.documentElement;

/***/ },
/* 12 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.global.js ***!
  \****************************************************/
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 13 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.dom-create.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ./$.is-object */ 14)
	  , document = __webpack_require__(/*! ./$.global */ 12).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 14 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.is-object.js ***!
  \*******************************************************/
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 15 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.has.js ***!
  \*************************************************/
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 16 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.cof.js ***!
  \*************************************************/
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 17 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.def.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global     = __webpack_require__(/*! ./$.global */ 12)
	  , core       = __webpack_require__(/*! ./$.core */ 18)
	  , hide       = __webpack_require__(/*! ./$.hide */ 19)
	  , $redef     = __webpack_require__(/*! ./$.redef */ 20)
	  , PROTOTYPE  = 'prototype';
	var ctx = function(fn, that){
	  return function(){
	    return fn.apply(that, arguments);
	  };
	};
	var $def = function(type, name, source){
	  var key, own, out, exp
	    , isGlobal = type & $def.G
	    , isProto  = type & $def.P
	    , target   = isGlobal ? global : type & $def.S
	        ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports  = isGlobal ? core : core[name] || (core[name] = {});
	  if(isGlobal)source = name;
	  for(key in source){
	    // contains in native
	    own = !(type & $def.F) && target && key in target;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    if(type & $def.B && own)exp = ctx(out, global);
	    else exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target && !own)$redef(target, key, out);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(isProto)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$def.F = 1;  // forced
	$def.G = 2;  // global
	$def.S = 4;  // static
	$def.P = 8;  // proto
	$def.B = 16; // bind
	$def.W = 32; // wrap
	module.exports = $def;

/***/ },
/* 18 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.core.js ***!
  \**************************************************/
/***/ function(module, exports) {

	var core = module.exports = {version: '1.2.2'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 19 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.hide.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $          = __webpack_require__(/*! ./$ */ 7)
	  , createDesc = __webpack_require__(/*! ./$.property-desc */ 10);
	module.exports = __webpack_require__(/*! ./$.support-desc */ 8) ? function(object, key, value){
	  return $.setDesc(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 20 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.redef.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	// add fake Function#toString
	// for correct work wrapped methods / constructors with methods like LoDash isNative
	var global    = __webpack_require__(/*! ./$.global */ 12)
	  , hide      = __webpack_require__(/*! ./$.hide */ 19)
	  , SRC       = __webpack_require__(/*! ./$.uid */ 21)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);

	__webpack_require__(/*! ./$.core */ 18).inspectSource = function(it){
	  return $toString.call(it);
	};

	(module.exports = function(O, key, val, safe){
	  if(typeof val == 'function'){
	    hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	    if(!('name' in val))val.name = key;
	  }
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe)delete O[key];
	    hide(O, key, val);
	  }
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 21 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.uid.js ***!
  \*************************************************/
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 22 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.invoke.js ***!
  \****************************************************/
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 23 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.array-methods.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(/*! ./$.ctx */ 24)
	  , isObject = __webpack_require__(/*! ./$.is-object */ 14)
	  , IObject  = __webpack_require__(/*! ./$.iobject */ 26)
	  , toObject = __webpack_require__(/*! ./$.to-object */ 27)
	  , toLength = __webpack_require__(/*! ./$.to-length */ 29)
	  , isArray  = __webpack_require__(/*! ./$.is-array */ 31)
	  , SPECIES  = __webpack_require__(/*! ./$.wks */ 32)('species');
	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var ASC = function(original, length){
	  var C;
	  if(isArray(original) && isObject(C = original.constructor)){
	    C = C[SPECIES];
	    if(C === null)C = undefined;
	  } return new (C === undefined ? Array : C)(length);
	};
	module.exports = function(TYPE){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? ASC($this, length) : IS_FILTER ? ASC($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 24 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.ctx.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(/*! ./$.a-function */ 25);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 25 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.a-function.js ***!
  \********************************************************/
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 26 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.iobject.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// indexed object, fallback for non-array-like ES3 strings
	var cof = __webpack_require__(/*! ./$.cof */ 16);
	module.exports = 0 in Object('z') ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 27 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.to-object.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(/*! ./$.defined */ 28);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 28 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.defined.js ***!
  \*****************************************************/
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 29 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.to-length.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(/*! ./$.to-integer */ 30)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 30 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.to-integer.js ***!
  \********************************************************/
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 31 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.is-array.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(/*! ./$.cof */ 16);
	module.exports = Array.isArray || function(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 32 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.wks.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var store  = __webpack_require__(/*! ./$.shared */ 33)('wks')
	  , Symbol = __webpack_require__(/*! ./$.global */ 12).Symbol;
	module.exports = function(name){
	  return store[name] || (store[name] =
	    Symbol && Symbol[name] || (Symbol || __webpack_require__(/*! ./$.uid */ 21))('Symbol.' + name));
	};

/***/ },
/* 33 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.shared.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(/*! ./$.global */ 12)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 34 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.an-object.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ./$.is-object */ 14);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 35 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.to-iobject.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(/*! ./$.iobject */ 26)
	  , defined = __webpack_require__(/*! ./$.defined */ 28);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 36 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.to-index.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(/*! ./$.to-integer */ 30)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 37 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.array-includes.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(/*! ./$.to-iobject */ 35)
	  , toLength  = __webpack_require__(/*! ./$.to-length */ 29)
	  , toIndex   = __webpack_require__(/*! ./$.to-index */ 36);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 38 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.symbol.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var $              = __webpack_require__(/*! ./$ */ 7)
	  , global         = __webpack_require__(/*! ./$.global */ 12)
	  , has            = __webpack_require__(/*! ./$.has */ 15)
	  , SUPPORT_DESC   = __webpack_require__(/*! ./$.support-desc */ 8)
	  , $def           = __webpack_require__(/*! ./$.def */ 17)
	  , $redef         = __webpack_require__(/*! ./$.redef */ 20)
	  , $fails         = __webpack_require__(/*! ./$.fails */ 9)
	  , shared         = __webpack_require__(/*! ./$.shared */ 33)
	  , setTag         = __webpack_require__(/*! ./$.tag */ 39)
	  , uid            = __webpack_require__(/*! ./$.uid */ 21)
	  , wks            = __webpack_require__(/*! ./$.wks */ 32)
	  , keyOf          = __webpack_require__(/*! ./$.keyof */ 40)
	  , $names         = __webpack_require__(/*! ./$.get-names */ 41)
	  , enumKeys       = __webpack_require__(/*! ./$.enum-keys */ 42)
	  , isArray        = __webpack_require__(/*! ./$.is-array */ 31)
	  , anObject       = __webpack_require__(/*! ./$.an-object */ 34)
	  , toIObject      = __webpack_require__(/*! ./$.to-iobject */ 35)
	  , createDesc     = __webpack_require__(/*! ./$.property-desc */ 10)
	  , getDesc        = $.getDesc
	  , setDesc        = $.setDesc
	  , _create        = $.create
	  , getNames       = $names.get
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , setter         = false
	  , HIDDEN         = wks('_hidden')
	  , isEnum         = $.isEnum
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , useNative      = typeof $Symbol == 'function'
	  , ObjectProto    = Object.prototype;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = SUPPORT_DESC && $fails(function(){
	  return _create(setDesc({}, 'a', {
	    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = getDesc(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  setDesc(it, key, D);
	  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
	} : setDesc;

	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol.prototype);
	  sym._k = tag;
	  SUPPORT_DESC && setter && setSymbolDesc(ObjectProto, tag, {
	    configurable: true,
	    set: function(value){
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    }
	  });
	  return sym;
	};

	var isSymbol = function(it){
	  return typeof it == 'symbol';
	};

	var $defineProperty = function defineProperty(it, key, D){
	  if(D && has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return setDesc(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key);
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
	    ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  var D = getDesc(it = toIObject(it), key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
	  return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
	  return result;
	};
	var $stringify = function stringify(it){
	  var args = [it]
	    , i    = 1
	    , $$   = arguments
	    , replacer, $replacer;
	  while($$.length > i)args.push($$[i++]);
	  replacer = args[1];
	  if(typeof replacer == 'function')$replacer = replacer;
	  if($replacer || !isArray(replacer))replacer = function(key, value){
	    if($replacer)value = $replacer.call(this, key, value);
	    if(!isSymbol(value))return value;
	  };
	  args[1] = replacer;
	  return _stringify.apply($JSON, args);
	};
	var buggyJSON = $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	});

	// 19.4.1.1 Symbol([description])
	if(!useNative){
	  $Symbol = function Symbol(){
	    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
	    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
	  };
	  $redef($Symbol.prototype, 'toString', function toString(){
	    return this._k;
	  });

	  isSymbol = function(it){
	    return it instanceof $Symbol;
	  };

	  $.create     = $create;
	  $.isEnum     = $propertyIsEnumerable;
	  $.getDesc    = $getOwnPropertyDescriptor;
	  $.setDesc    = $defineProperty;
	  $.setDescs   = $defineProperties;
	  $.getNames   = $names.get = $getOwnPropertyNames;
	  $.getSymbols = $getOwnPropertySymbols;

	  if(SUPPORT_DESC && !__webpack_require__(/*! ./$.library */ 43)){
	    $redef(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	}

	var symbolStatics = {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    return keyOf(SymbolRegistry, key);
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	};
	// 19.4.2.2 Symbol.hasInstance
	// 19.4.2.3 Symbol.isConcatSpreadable
	// 19.4.2.4 Symbol.iterator
	// 19.4.2.6 Symbol.match
	// 19.4.2.8 Symbol.replace
	// 19.4.2.9 Symbol.search
	// 19.4.2.10 Symbol.species
	// 19.4.2.11 Symbol.split
	// 19.4.2.12 Symbol.toPrimitive
	// 19.4.2.13 Symbol.toStringTag
	// 19.4.2.14 Symbol.unscopables
	$.each.call((
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
	  'species,split,toPrimitive,toStringTag,unscopables'
	).split(','), function(it){
	  var sym = wks(it);
	  symbolStatics[it] = useNative ? sym : wrap(sym);
	});

	setter = true;

	$def($def.G + $def.W, {Symbol: $Symbol});

	$def($def.S, 'Symbol', symbolStatics);

	$def($def.S + $def.F * !useNative, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $def($def.S + $def.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});

	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setTag(global.JSON, 'JSON', true);

/***/ },
/* 39 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.tag.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(/*! ./$ */ 7).setDesc
	  , has = __webpack_require__(/*! ./$.has */ 15)
	  , TAG = __webpack_require__(/*! ./$.wks */ 32)('toStringTag');

	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 40 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.keyof.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $         = __webpack_require__(/*! ./$ */ 7)
	  , toIObject = __webpack_require__(/*! ./$.to-iobject */ 35);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = $.getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 41 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.get-names.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toString  = {}.toString
	  , toIObject = __webpack_require__(/*! ./$.to-iobject */ 35)
	  , getNames  = __webpack_require__(/*! ./$ */ 7).getNames;

	var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function(it){
	  try {
	    return getNames(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};

	module.exports.get = function getOwnPropertyNames(it){
	  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
	  return getNames(toIObject(it));
	};

/***/ },
/* 42 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.enum-keys.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var $ = __webpack_require__(/*! ./$ */ 7);
	module.exports = function(it){
	  var keys       = $.getKeys(it)
	    , getSymbols = $.getSymbols;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = $.isEnum
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
	  }
	  return keys;
	};

/***/ },
/* 43 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.library.js ***!
  \*****************************************************/
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 44 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.assign.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S + $def.F, 'Object', {assign: __webpack_require__(/*! ./$.assign */ 45)});

/***/ },
/* 45 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.assign.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.1 Object.assign(target, source, ...)
	var $        = __webpack_require__(/*! ./$ */ 7)
	  , toObject = __webpack_require__(/*! ./$.to-object */ 27)
	  , IObject  = __webpack_require__(/*! ./$.iobject */ 26);

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = __webpack_require__(/*! ./$.fails */ 9)(function(){
	  var a = Object.assign
	    , A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , $$    = arguments
	    , $$len = $$.length
	    , index = 1
	    , getKeys    = $.getKeys
	    , getSymbols = $.getSymbols
	    , isEnum     = $.isEnum;
	  while($$len > index){
	    var S      = IObject($$[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  }
	  return T;
	} : Object.assign;

/***/ },
/* 46 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.is.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $def = __webpack_require__(/*! ./$.def */ 17);
	$def($def.S, 'Object', {
	  is: __webpack_require__(/*! ./$.same */ 47)
	});

/***/ },
/* 47 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.same.js ***!
  \**************************************************/
/***/ function(module, exports) {

	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 48 */
/*!***********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.set-prototype-of.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $def = __webpack_require__(/*! ./$.def */ 17);
	$def($def.S, 'Object', {setPrototypeOf: __webpack_require__(/*! ./$.set-proto */ 49).set});

/***/ },
/* 49 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.set-proto.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var getDesc  = __webpack_require__(/*! ./$ */ 7).getDesc
	  , isObject = __webpack_require__(/*! ./$.is-object */ 14)
	  , anObject = __webpack_require__(/*! ./$.an-object */ 34);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(/*! ./$.ctx */ 24)(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 50 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.to-string.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(/*! ./$.classof */ 51)
	  , test    = {};
	test[__webpack_require__(/*! ./$.wks */ 32)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(/*! ./$.redef */ 20)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 51 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.classof.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(/*! ./$.cof */ 16)
	  , TAG = __webpack_require__(/*! ./$.wks */ 32)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 52 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.freeze.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(/*! ./$.is-object */ 14);

	__webpack_require__(/*! ./$.object-sap */ 53)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(it) : it;
	  };
	});

/***/ },
/* 53 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.object-sap.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	module.exports = function(KEY, exec){
	  var $def = __webpack_require__(/*! ./$.def */ 17)
	    , fn   = (__webpack_require__(/*! ./$.core */ 18).Object || {})[KEY] || Object[KEY]
	    , exp  = {};
	  exp[KEY] = exec(fn);
	  $def($def.S + $def.F * __webpack_require__(/*! ./$.fails */ 9)(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 54 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.seal.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(/*! ./$.is-object */ 14);

	__webpack_require__(/*! ./$.object-sap */ 53)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(it) : it;
	  };
	});

/***/ },
/* 55 */
/*!*************************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.prevent-extensions.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(/*! ./$.is-object */ 14);

	__webpack_require__(/*! ./$.object-sap */ 53)('preventExtensions', function($preventExtensions){
	  return function preventExtensions(it){
	    return $preventExtensions && isObject(it) ? $preventExtensions(it) : it;
	  };
	});

/***/ },
/* 56 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.is-frozen.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(/*! ./$.is-object */ 14);

	__webpack_require__(/*! ./$.object-sap */ 53)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 57 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.is-sealed.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(/*! ./$.is-object */ 14);

	__webpack_require__(/*! ./$.object-sap */ 53)('isSealed', function($isSealed){
	  return function isSealed(it){
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ },
/* 58 */
/*!********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.is-extensible.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(/*! ./$.is-object */ 14);

	__webpack_require__(/*! ./$.object-sap */ 53)('isExtensible', function($isExtensible){
	  return function isExtensible(it){
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ },
/* 59 */
/*!**********************************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.get-own-property-descriptor.js ***!
  \**********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject = __webpack_require__(/*! ./$.to-iobject */ 35);

	__webpack_require__(/*! ./$.object-sap */ 53)('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 60 */
/*!***********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.get-prototype-of.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject = __webpack_require__(/*! ./$.to-object */ 27);

	__webpack_require__(/*! ./$.object-sap */ 53)('getPrototypeOf', function($getPrototypeOf){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 61 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.keys.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(/*! ./$.to-object */ 27);

	__webpack_require__(/*! ./$.object-sap */ 53)('keys', function($keys){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 62 */
/*!*****************************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.get-own-property-names.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(/*! ./$.object-sap */ 53)('getOwnPropertyNames', function(){
	  return __webpack_require__(/*! ./$.get-names */ 41).get;
	});

/***/ },
/* 63 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.function.name.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var setDesc    = __webpack_require__(/*! ./$ */ 7).setDesc
	  , createDesc = __webpack_require__(/*! ./$.property-desc */ 10)
	  , has        = __webpack_require__(/*! ./$.has */ 15)
	  , FProto     = Function.prototype
	  , nameRE     = /^\s*function ([^ (]*)/
	  , NAME       = 'name';
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(/*! ./$.support-desc */ 8) && setDesc(FProto, NAME, {
	  configurable: true,
	  get: function(){
	    var match = ('' + this).match(nameRE)
	      , name  = match ? match[1] : '';
	    has(this, NAME) || setDesc(this, NAME, createDesc(5, name));
	    return name;
	  }
	});

/***/ },
/* 64 */
/*!*********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.function.has-instance.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $             = __webpack_require__(/*! ./$ */ 7)
	  , isObject      = __webpack_require__(/*! ./$.is-object */ 14)
	  , HAS_INSTANCE  = __webpack_require__(/*! ./$.wks */ 32)('hasInstance')
	  , FunctionProto = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))$.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(typeof this != 'function' || !isObject(O))return false;
	  if(!isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = $.getProto(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 65 */
/*!******************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.number.constructor.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $          = __webpack_require__(/*! ./$ */ 7)
	  , global     = __webpack_require__(/*! ./$.global */ 12)
	  , has        = __webpack_require__(/*! ./$.has */ 15)
	  , cof        = __webpack_require__(/*! ./$.cof */ 16)
	  , isObject   = __webpack_require__(/*! ./$.is-object */ 14)
	  , fails      = __webpack_require__(/*! ./$.fails */ 9)
	  , NUMBER     = 'Number'
	  , $Number    = global[NUMBER]
	  , Base       = $Number
	  , proto      = $Number.prototype
	  // Opera ~12 has broken Object#toString
	  , BROKEN_COF = cof($.create(proto)) == NUMBER;
	var toPrimitive = function(it){
	  var fn, val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to number");
	};
	var toNumber = function(it){
	  if(isObject(it))it = toPrimitive(it);
	  if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
	    var binary = false;
	    switch(it.charCodeAt(1)){
	      case 66 : case 98  : binary = true;
	      case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
	    }
	  } return +it;
	};
	if(!($Number('0o1') && $Number('0b1'))){
	  $Number = function Number(it){
	    var that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? new Base(toNumber(it)) : toNumber(it);
	  };
	  $.each.call(__webpack_require__(/*! ./$.support-desc */ 8) ? $.getNames(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), function(key){
	    if(has(Base, key) && !has($Number, key)){
	      $.setDesc($Number, key, $.getDesc(Base, key));
	    }
	  });
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(/*! ./$.redef */ 20)(global, NUMBER, $Number);
	}

/***/ },
/* 66 */
/*!**************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.number.epsilon.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ },
/* 67 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.number.is-finite.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $def      = __webpack_require__(/*! ./$.def */ 17)
	  , _isFinite = __webpack_require__(/*! ./$.global */ 12).isFinite;

	$def($def.S, 'Number', {
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ },
/* 68 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.number.is-integer.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Number', {isInteger: __webpack_require__(/*! ./$.is-integer */ 69)});

/***/ },
/* 69 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.is-integer.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(/*! ./$.is-object */ 14)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 70 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.number.is-nan.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 71 */
/*!**********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.number.is-safe-integer.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $def      = __webpack_require__(/*! ./$.def */ 17)
	  , isInteger = __webpack_require__(/*! ./$.is-integer */ 69)
	  , abs       = Math.abs;

	$def($def.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ },
/* 72 */
/*!***********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.number.max-safe-integer.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ },
/* 73 */
/*!***********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.number.min-safe-integer.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ },
/* 74 */
/*!******************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.number.parse-float.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.12 Number.parseFloat(string)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Number', {parseFloat: parseFloat});

/***/ },
/* 75 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.number.parse-int.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.13 Number.parseInt(string, radix)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Number', {parseInt: parseInt});

/***/ },
/* 76 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.acosh.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $def   = __webpack_require__(/*! ./$.def */ 17)
	  , log1p  = __webpack_require__(/*! ./$.log1p */ 77)
	  , sqrt   = Math.sqrt
	  , $acosh = Math.acosh;

	// V8 bug https://code.google.com/p/v8/issues/detail?id=3509
	$def($def.S + $def.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710), 'Math', {
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ },
/* 77 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.log1p.js ***!
  \***************************************************/
/***/ function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x){
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ },
/* 78 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.asinh.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}

	$def($def.S, 'Math', {asinh: asinh});

/***/ },
/* 79 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.atanh.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Math', {
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ },
/* 80 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.cbrt.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $def = __webpack_require__(/*! ./$.def */ 17)
	  , sign = __webpack_require__(/*! ./$.sign */ 81);

	$def($def.S, 'Math', {
	  cbrt: function cbrt(x){
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ },
/* 81 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.sign.js ***!
  \**************************************************/
/***/ function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ },
/* 82 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.clz32.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Math', {
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ },
/* 83 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.cosh.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $def = __webpack_require__(/*! ./$.def */ 17)
	  , exp  = Math.exp;

	$def($def.S, 'Math', {
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ },
/* 84 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.expm1.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Math', {expm1: __webpack_require__(/*! ./$.expm1 */ 85)});

/***/ },
/* 85 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.expm1.js ***!
  \***************************************************/
/***/ function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	module.exports = Math.expm1 || function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	};

/***/ },
/* 86 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.fround.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $def  = __webpack_require__(/*! ./$.def */ 17)
	  , sign  = __webpack_require__(/*! ./$.sign */ 81)
	  , pow   = Math.pow
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);

	var roundTiesToEven = function(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	};


	$def($def.S, 'Math', {
	  fround: function fround(x){
	    var $abs  = Math.abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ },
/* 87 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.hypot.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
	var $def = __webpack_require__(/*! ./$.def */ 17)
	  , abs  = Math.abs;

	$def($def.S, 'Math', {
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum   = 0
	      , i     = 0
	      , $$    = arguments
	      , $$len = $$.length
	      , larg  = 0
	      , arg, div;
	    while(i < $$len){
	      arg = abs($$[i++]);
	      if(larg < arg){
	        div  = larg / arg;
	        sum  = sum * div * div + 1;
	        larg = arg;
	      } else if(arg > 0){
	        div  = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ },
/* 88 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.imul.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	// WebKit fails with big numbers
	$def($def.S + $def.F * __webpack_require__(/*! ./$.fails */ 9)(function(){
	  return Math.imul(0xffffffff, 5) != -5;
	}), 'Math', {
	  imul: function imul(x, y){
	    var UINT16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UINT16 & xn
	      , yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ },
/* 89 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.log10.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Math', {
	  log10: function log10(x){
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ },
/* 90 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.log1p.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Math', {log1p: __webpack_require__(/*! ./$.log1p */ 77)});

/***/ },
/* 91 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.log2.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 92 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.sign.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Math', {sign: __webpack_require__(/*! ./$.sign */ 81)});

/***/ },
/* 93 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.sinh.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $def  = __webpack_require__(/*! ./$.def */ 17)
	  , expm1 = __webpack_require__(/*! ./$.expm1 */ 85)
	  , exp   = Math.exp;

	// V8 near Chromium 38 has a problem with very small numbers
	$def($def.S + $def.F * __webpack_require__(/*! ./$.fails */ 9)(function(){
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x){
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ },
/* 94 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.tanh.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $def  = __webpack_require__(/*! ./$.def */ 17)
	  , expm1 = __webpack_require__(/*! ./$.expm1 */ 85)
	  , exp   = Math.exp;

	$def($def.S, 'Math', {
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ },
/* 95 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.trunc.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Math', {
	  trunc: function trunc(it){
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ },
/* 96 */
/*!**********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.from-code-point.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $def    = __webpack_require__(/*! ./$.def */ 17)
	  , toIndex = __webpack_require__(/*! ./$.to-index */ 36)
	  , fromCharCode = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	$def($def.S + $def.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res   = []
	      , $$    = arguments
	      , $$len = $$.length
	      , i     = 0
	      , code;
	    while($$len > i){
	      code = +$$[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 97 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.raw.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $def      = __webpack_require__(/*! ./$.def */ 17)
	  , toIObject = __webpack_require__(/*! ./$.to-iobject */ 35)
	  , toLength  = __webpack_require__(/*! ./$.to-length */ 29);

	$def($def.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl   = toIObject(callSite.raw)
	      , len   = toLength(tpl.length)
	      , $$    = arguments
	      , $$len = $$.length
	      , res   = []
	      , i     = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < $$len)res.push(String($$[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 98 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.trim.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(/*! ./$.string-trim */ 99)('trim', function($trim){
	  return function trim(){
	    return $trim(this, 3);
	  };
	});

/***/ },
/* 99 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.string-trim.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = function(string, TYPE){
	  string = String(defined(string));
	  if(TYPE & 1)string = string.replace(ltrim, '');
	  if(TYPE & 2)string = string.replace(rtrim, '');
	  return string;
	};

	var $def    = __webpack_require__(/*! ./$.def */ 17)
	  , defined = __webpack_require__(/*! ./$.defined */ 28)
	  , spaces  = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	      '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'
	  , space   = '[' + spaces + ']'
	  , non     = '\u200b\u0085'
	  , ltrim   = RegExp('^' + space + space + '*')
	  , rtrim   = RegExp(space + space + '*$');

	module.exports = function(KEY, exec){
	  var exp  = {};
	  exp[KEY] = exec(trim);
	  $def($def.P + $def.F * __webpack_require__(/*! ./$.fails */ 9)(function(){
	    return !!spaces[KEY]() || non[KEY]() != non;
	  }), 'String', exp);
	};

/***/ },
/* 100 */
/*!***************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.iterator.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(/*! ./$.string-at */ 101)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(/*! ./$.iter-define */ 102)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 101 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.string-at.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// true  -> String#at
	// false -> String#codePointAt
	var toInteger = __webpack_require__(/*! ./$.to-integer */ 30)
	  , defined   = __webpack_require__(/*! ./$.defined */ 28);
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l
	      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	        ? TO_STRING ? s.charAt(i) : a
	        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 102 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.iter-define.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY         = __webpack_require__(/*! ./$.library */ 43)
	  , $def            = __webpack_require__(/*! ./$.def */ 17)
	  , $redef          = __webpack_require__(/*! ./$.redef */ 20)
	  , hide            = __webpack_require__(/*! ./$.hide */ 19)
	  , has             = __webpack_require__(/*! ./$.has */ 15)
	  , SYMBOL_ITERATOR = __webpack_require__(/*! ./$.wks */ 32)('iterator')
	  , Iterators       = __webpack_require__(/*! ./$.iterators */ 103)
	  , BUGGY           = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR     = '@@iterator'
	  , KEYS            = 'keys'
	  , VALUES          = 'values';
	var returnThis = function(){ return this; };
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
	  __webpack_require__(/*! ./$.iter-create */ 104)(Constructor, NAME, next);
	  var createMethod = function(kind){
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG      = NAME + ' Iterator'
	    , proto    = Base.prototype
	    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , _default = _native || createMethod(DEFAULT)
	    , methods, key;
	  // Fix native
	  if(_native){
	    var IteratorPrototype = __webpack_require__(/*! ./$ */ 7).getProto(_default.call(new Base));
	    // Set @@toStringTag to native iterators
	    __webpack_require__(/*! ./$.tag */ 39)(IteratorPrototype, TAG, true);
	    // FF fix
	    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, SYMBOL_ITERATOR, returnThis);
	  }
	  // Define iterator
	  if(!LIBRARY || FORCE)hide(proto, SYMBOL_ITERATOR, _default);
	  // Plug for library
	  Iterators[NAME] = _default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      keys:    IS_SET            ? _default : createMethod(KEYS),
	      values:  DEFAULT == VALUES ? _default : createMethod(VALUES),
	      entries: DEFAULT != VALUES ? _default : createMethod('entries')
	    };
	    if(FORCE)for(key in methods){
	      if(!(key in proto))$redef(proto, key, methods[key]);
	    } else $def($def.P + $def.F * BUGGY, NAME, methods);
	  }
	};

/***/ },
/* 103 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.iterators.js ***!
  \*******************************************************/
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 104 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.iter-create.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $ = __webpack_require__(/*! ./$ */ 7)
	  , IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(/*! ./$.hide */ 19)(IteratorPrototype, __webpack_require__(/*! ./$.wks */ 32)('iterator'), function(){ return this; });

	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = $.create(IteratorPrototype, {next: __webpack_require__(/*! ./$.property-desc */ 10)(1,next)});
	  __webpack_require__(/*! ./$.tag */ 39)(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 105 */
/*!********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.code-point-at.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $def = __webpack_require__(/*! ./$.def */ 17)
	  , $at  = __webpack_require__(/*! ./$.string-at */ 101)(false);
	$def($def.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 106 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.ends-with.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $def      = __webpack_require__(/*! ./$.def */ 17)
	  , toLength  = __webpack_require__(/*! ./$.to-length */ 29)
	  , context   = __webpack_require__(/*! ./$.string-context */ 107)
	  , ENDS_WITH = 'endsWith'
	  , $endsWith = ''[ENDS_WITH];

	$def($def.P + $def.F * __webpack_require__(/*! ./$.fails-is-regexp */ 109)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    var that = context(this, searchString, ENDS_WITH)
	      , $$   = arguments
	      , endPosition = $$.length > 1 ? $$[1] : undefined
	      , len    = toLength(that.length)
	      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
	      , search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

/***/ },
/* 107 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.string-context.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(/*! ./$.is-regexp */ 108)
	  , defined  = __webpack_require__(/*! ./$.defined */ 28);

	module.exports = function(that, searchString, NAME){
	  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ },
/* 108 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.is-regexp.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(/*! ./$.is-object */ 14)
	  , cof      = __webpack_require__(/*! ./$.cof */ 16)
	  , MATCH    = __webpack_require__(/*! ./$.wks */ 32)('match');
	module.exports = function(it){
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ },
/* 109 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.fails-is-regexp.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(KEY){
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch(e){
	    try {
	      re[__webpack_require__(/*! ./$.wks */ 32)('match')] = false;
	      return !'/./'[KEY](re);
	    } catch(f){ /* empty */ }
	  } return true;
	};

/***/ },
/* 110 */
/*!***************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.includes.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $def     = __webpack_require__(/*! ./$.def */ 17)
	  , context  = __webpack_require__(/*! ./$.string-context */ 107)
	  , INCLUDES = 'includes';

	$def($def.P + $def.F * __webpack_require__(/*! ./$.fails-is-regexp */ 109)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */){
	    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ },
/* 111 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.repeat.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(/*! ./$.string-repeat */ 112)
	});

/***/ },
/* 112 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.string-repeat.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(/*! ./$.to-integer */ 30)
	  , defined   = __webpack_require__(/*! ./$.defined */ 28);

	module.exports = function repeat(count){
	  var str = String(defined(this))
	    , res = ''
	    , n   = toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 113 */
/*!******************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.starts-with.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $def        = __webpack_require__(/*! ./$.def */ 17)
	  , toLength    = __webpack_require__(/*! ./$.to-length */ 29)
	  , context     = __webpack_require__(/*! ./$.string-context */ 107)
	  , STARTS_WITH = 'startsWith'
	  , $startsWith = ''[STARTS_WITH];

	$def($def.P + $def.F * __webpack_require__(/*! ./$.fails-is-regexp */ 109)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    var that   = context(this, searchString, STARTS_WITH)
	      , $$     = arguments
	      , index  = toLength(Math.min($$.length > 1 ? $$[1] : undefined, that.length))
	      , search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

/***/ },
/* 114 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.from.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx         = __webpack_require__(/*! ./$.ctx */ 24)
	  , $def        = __webpack_require__(/*! ./$.def */ 17)
	  , toObject    = __webpack_require__(/*! ./$.to-object */ 27)
	  , call        = __webpack_require__(/*! ./$.iter-call */ 115)
	  , isArrayIter = __webpack_require__(/*! ./$.is-array-iter */ 116)
	  , toLength    = __webpack_require__(/*! ./$.to-length */ 29)
	  , getIterFn   = __webpack_require__(/*! ./core.get-iterator-method */ 117);
	$def($def.S + $def.F * !__webpack_require__(/*! ./$.iter-detect */ 118)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , $$      = arguments
	      , $$len   = $$.length
	      , mapfn   = $$len > 1 ? $$[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        result[index] = mapping ? mapfn(O[index], index) : O[index];
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 115 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.iter-call.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(/*! ./$.an-object */ 34);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 116 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.is-array-iter.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators = __webpack_require__(/*! ./$.iterators */ 103)
	  , ITERATOR  = __webpack_require__(/*! ./$.wks */ 32)('iterator');
	module.exports = function(it){
	  return (Iterators.Array || Array.prototype[ITERATOR]) === it;
	};

/***/ },
/* 117 */
/*!********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/core.get-iterator-method.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(/*! ./$.classof */ 51)
	  , ITERATOR  = __webpack_require__(/*! ./$.wks */ 32)('iterator')
	  , Iterators = __webpack_require__(/*! ./$.iterators */ 103);
	module.exports = __webpack_require__(/*! ./$.core */ 18).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 118 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.iter-detect.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var SYMBOL_ITERATOR = __webpack_require__(/*! ./$.wks */ 32)('iterator')
	  , SAFE_CLOSING    = false;
	try {
	  var riter = [7][SYMBOL_ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[SYMBOL_ITERATOR]();
	    iter.next = function(){ safe = true; };
	    arr[SYMBOL_ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 119 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.of.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $def = __webpack_require__(/*! ./$.def */ 17);

	// WebKit Array.of isn't generic
	$def($def.S + $def.F * __webpack_require__(/*! ./$.fails */ 9)(function(){
	  function F(){}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , $$     = arguments
	      , $$len  = $$.length
	      , result = new (typeof this == 'function' ? this : Array)($$len);
	    while($$len > index)result[index] = $$[index++];
	    result.length = $$len;
	    return result;
	  }
	});

/***/ },
/* 120 */
/*!**************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.iterator.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var setUnscope = __webpack_require__(/*! ./$.unscope */ 121)
	  , step       = __webpack_require__(/*! ./$.iter-step */ 122)
	  , Iterators  = __webpack_require__(/*! ./$.iterators */ 103)
	  , toIObject  = __webpack_require__(/*! ./$.to-iobject */ 35);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	__webpack_require__(/*! ./$.iter-define */ 102)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	setUnscope('keys');
	setUnscope('values');
	setUnscope('entries');

/***/ },
/* 121 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.unscope.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(/*! ./$.wks */ 32)('unscopables');
	if([][UNSCOPABLES] == undefined)__webpack_require__(/*! ./$.hide */ 19)(Array.prototype, UNSCOPABLES, {});
	module.exports = function(key){
	  [][UNSCOPABLES][key] = true;
	};

/***/ },
/* 122 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.iter-step.js ***!
  \*******************************************************/
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 123 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.species.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./$.species */ 124)(Array);

/***/ },
/* 124 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.species.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $       = __webpack_require__(/*! ./$ */ 7)
	  , SPECIES = __webpack_require__(/*! ./$.wks */ 32)('species');
	module.exports = function(C){
	  if(__webpack_require__(/*! ./$.support-desc */ 8) && !(SPECIES in C))$.setDesc(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 125 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.copy-within.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.P, 'Array', {copyWithin: __webpack_require__(/*! ./$.array-copy-within */ 126)});

	__webpack_require__(/*! ./$.unscope */ 121)('copyWithin');

/***/ },
/* 126 */
/*!***************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.array-copy-within.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(/*! ./$.to-object */ 27)
	  , toIndex  = __webpack_require__(/*! ./$.to-index */ 36)
	  , toLength = __webpack_require__(/*! ./$.to-length */ 29);

	module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
	  var O     = toObject(this)
	    , len   = toLength(O.length)
	    , to    = toIndex(target, len)
	    , from  = toIndex(start, len)
	    , $$    = arguments
	    , end   = $$.length > 2 ? $$[2] : undefined
	    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
	    , inc   = 1;
	  if(from < to && to < from + count){
	    inc  = -1;
	    from += count - 1;
	    to   += count - 1;
	  }
	  while(count-- > 0){
	    if(from in O)O[to] = O[from];
	    else delete O[to];
	    to   += inc;
	    from += inc;
	  } return O;
	};

/***/ },
/* 127 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.fill.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.P, 'Array', {fill: __webpack_require__(/*! ./$.array-fill */ 128)});

	__webpack_require__(/*! ./$.unscope */ 121)('fill');

/***/ },
/* 128 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.array-fill.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(/*! ./$.to-object */ 27)
	  , toIndex  = __webpack_require__(/*! ./$.to-index */ 36)
	  , toLength = __webpack_require__(/*! ./$.to-length */ 29);
	module.exports = [].fill || function fill(value /*, start = 0, end = @length */){
	  var O      = toObject(this, true)
	    , length = toLength(O.length)
	    , $$     = arguments
	    , $$len  = $$.length
	    , index  = toIndex($$len > 1 ? $$[1] : undefined, length)
	    , end    = $$len > 2 ? $$[2] : undefined
	    , endPos = end === undefined ? length : toIndex(end, length);
	  while(endPos > index)O[index++] = value;
	  return O;
	};

/***/ },
/* 129 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.find.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var KEY    = 'find'
	  , $def   = __webpack_require__(/*! ./$.def */ 17)
	  , forced = true
	  , $find  = __webpack_require__(/*! ./$.array-methods */ 23)(5);
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$def($def.P + $def.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(/*! ./$.unscope */ 121)(KEY);

/***/ },
/* 130 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.find-index.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var KEY    = 'findIndex'
	  , $def   = __webpack_require__(/*! ./$.def */ 17)
	  , forced = true
	  , $find  = __webpack_require__(/*! ./$.array-methods */ 23)(6);
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$def($def.P + $def.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(/*! ./$.unscope */ 121)(KEY);

/***/ },
/* 131 */
/*!******************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.regexp.constructor.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $        = __webpack_require__(/*! ./$ */ 7)
	  , global   = __webpack_require__(/*! ./$.global */ 12)
	  , isRegExp = __webpack_require__(/*! ./$.is-regexp */ 108)
	  , $flags   = __webpack_require__(/*! ./$.flags */ 132)
	  , $RegExp  = global.RegExp
	  , Base     = $RegExp
	  , proto    = $RegExp.prototype
	  , re1      = /a/g
	  , re2      = /a/g
	  // "new" creates a new object, old webkit buggy here
	  , CORRECT_NEW = new $RegExp(re1) !== re1;

	if(__webpack_require__(/*! ./$.support-desc */ 8) && (!CORRECT_NEW || __webpack_require__(/*! ./$.fails */ 9)(function(){
	  re2[__webpack_require__(/*! ./$.wks */ 32)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))){
	  $RegExp = function RegExp(p, f){
	    var piRE = isRegExp(p)
	      , fiU  = f === undefined;
	    return !(this instanceof $RegExp) && piRE && p.constructor === $RegExp && fiU ? p
	      : CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f);
	  };
	  $.each.call($.getNames(Base), function(key){
	    key in $RegExp || $.setDesc($RegExp, key, {
	      configurable: true,
	      get: function(){ return Base[key]; },
	      set: function(it){ Base[key] = it; }
	    });
	  });
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(/*! ./$.redef */ 20)(global, 'RegExp', $RegExp);
	}

	__webpack_require__(/*! ./$.species */ 124)($RegExp);

/***/ },
/* 132 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.flags.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(/*! ./$.an-object */ 34);
	module.exports = function(){
	  var that   = anObject(this)
	    , result = '';
	  if(that.global)result += 'g';
	  if(that.ignoreCase)result += 'i';
	  if(that.multiline)result += 'm';
	  if(that.unicode)result += 'u';
	  if(that.sticky)result += 'y';
	  return result;
	};

/***/ },
/* 133 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.regexp.flags.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	var $ = __webpack_require__(/*! ./$ */ 7);
	if(__webpack_require__(/*! ./$.support-desc */ 8) && /./g.flags != 'g')$.setDesc(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(/*! ./$.flags */ 132)
	});

/***/ },
/* 134 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.regexp.match.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(/*! ./$.fix-re-wks */ 135)('match', 1, function(defined, MATCH){
	  // 21.1.3.11 String.prototype.match(regexp)
	  return function match(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  };
	});

/***/ },
/* 135 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.fix-re-wks.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	module.exports = function(KEY, length, exec){
	  var defined  = __webpack_require__(/*! ./$.defined */ 28)
	    , SYMBOL   = __webpack_require__(/*! ./$.wks */ 32)(KEY)
	    , original = ''[KEY];
	  if(__webpack_require__(/*! ./$.fails */ 9)(function(){
	    var O = {};
	    O[SYMBOL] = function(){ return 7; };
	    return ''[KEY](O) != 7;
	  })){
	    __webpack_require__(/*! ./$.redef */ 20)(String.prototype, KEY, exec(defined, SYMBOL, original));
	    __webpack_require__(/*! ./$.hide */ 19)(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function(string, arg){ return original.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function(string){ return original.call(string, this); }
	    );
	  }
	};

/***/ },
/* 136 */
/*!**************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.regexp.replace.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(/*! ./$.fix-re-wks */ 135)('replace', 2, function(defined, REPLACE, $replace){
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return function replace(searchValue, replaceValue){
	    'use strict';
	    var O  = defined(this)
	      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  };
	});

/***/ },
/* 137 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.regexp.search.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(/*! ./$.fix-re-wks */ 135)('search', 1, function(defined, SEARCH){
	  // 21.1.3.15 String.prototype.search(regexp)
	  return function search(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  };
	});

/***/ },
/* 138 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.regexp.split.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(/*! ./$.fix-re-wks */ 135)('split', 2, function(defined, SPLIT, $split){
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return function split(separator, limit){
	    'use strict';
	    var O  = defined(this)
	      , fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined
	      ? fn.call(separator, O, limit)
	      : $split.call(String(O), separator, limit);
	  };
	});

/***/ },
/* 139 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.promise.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $          = __webpack_require__(/*! ./$ */ 7)
	  , LIBRARY    = __webpack_require__(/*! ./$.library */ 43)
	  , global     = __webpack_require__(/*! ./$.global */ 12)
	  , ctx        = __webpack_require__(/*! ./$.ctx */ 24)
	  , classof    = __webpack_require__(/*! ./$.classof */ 51)
	  , $def       = __webpack_require__(/*! ./$.def */ 17)
	  , isObject   = __webpack_require__(/*! ./$.is-object */ 14)
	  , anObject   = __webpack_require__(/*! ./$.an-object */ 34)
	  , aFunction  = __webpack_require__(/*! ./$.a-function */ 25)
	  , strictNew  = __webpack_require__(/*! ./$.strict-new */ 140)
	  , forOf      = __webpack_require__(/*! ./$.for-of */ 141)
	  , setProto   = __webpack_require__(/*! ./$.set-proto */ 49).set
	  , same       = __webpack_require__(/*! ./$.same */ 47)
	  , species    = __webpack_require__(/*! ./$.species */ 124)
	  , SPECIES    = __webpack_require__(/*! ./$.wks */ 32)('species')
	  , RECORD     = __webpack_require__(/*! ./$.uid */ 21)('record')
	  , asap       = __webpack_require__(/*! ./$.microtask */ 142)
	  , PROMISE    = 'Promise'
	  , process    = global.process
	  , isNode     = classof(process) == 'process'
	  , P          = global[PROMISE]
	  , Wrapper;

	var testResolve = function(sub){
	  var test = new P(function(){});
	  if(sub)test.constructor = Object;
	  return P.resolve(test) === test;
	};

	var useNative = function(){
	  var works = false;
	  function P2(x){
	    var self = new P(x);
	    setProto(self, P2.prototype);
	    return self;
	  }
	  try {
	    works = P && P.resolve && testResolve();
	    setProto(P2, P);
	    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
	    // actual Firefox has broken subclass support, test that
	    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
	      works = false;
	    }
	    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
	    if(works && __webpack_require__(/*! ./$.support-desc */ 8)){
	      var thenableThenGotten = false;
	      P.resolve($.setDesc({}, 'then', {
	        get: function(){ thenableThenGotten = true; }
	      }));
	      works = thenableThenGotten;
	    }
	  } catch(e){ works = false; }
	  return works;
	}();

	// helpers
	var isPromise = function(it){
	  return isObject(it) && (useNative ? classof(it) == 'Promise' : RECORD in it);
	};
	var sameConstructor = function(a, b){
	  // library wrapper special case
	  if(LIBRARY && a === P && b === Wrapper)return true;
	  return same(a, b);
	};
	var getConstructor = function(C){
	  var S = anObject(C)[SPECIES];
	  return S != undefined ? S : C;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function(record, isReject){
	  if(record.n)return;
	  record.n = true;
	  var chain = record.c;
	  asap(function(){
	    var value = record.v
	      , ok    = record.s == 1
	      , i     = 0;
	    var run = function(react){
	      var cb = ok ? react.ok : react.fail
	        , ret, then;
	      try {
	        if(cb){
	          if(!ok)record.h = true;
	          ret = cb === true ? value : cb(value);
	          if(ret === react.P){
	            react.rej(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(ret)){
	            then.call(ret, react.res, react.rej);
	          } else react.res(ret);
	        } else react.rej(value);
	      } catch(err){
	        react.rej(err);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    chain.length = 0;
	    record.n = false;
	    if(isReject)setTimeout(function(){
	      var promise = record.p
	        , handler, console;
	      if(isUnhandled(promise)){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      } record.a = undefined;
	    }, 1);
	  });
	};
	var isUnhandled = function(promise){
	  var record = promise[RECORD]
	    , chain  = record.a || record.c
	    , i      = 0
	    , react;
	  if(record.h)return false;
	  while(chain.length > i){
	    react = chain[i++];
	    if(react.fail || !isUnhandled(react.P))return false;
	  } return true;
	};
	var $reject = function(value){
	  var record = this;
	  if(record.d)return;
	  record.d = true;
	  record = record.r || record; // unwrap
	  record.v = value;
	  record.s = 2;
	  record.a = record.c.slice();
	  notify(record, true);
	};
	var $resolve = function(value){
	  var record = this
	    , then;
	  if(record.d)return;
	  record.d = true;
	  record = record.r || record; // unwrap
	  try {
	    if(then = isThenable(value)){
	      asap(function(){
	        var wrapper = {r: record, d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      record.v = value;
	      record.s = 1;
	      notify(record, false);
	    }
	  } catch(e){
	    $reject.call({r: record, d: false}, e); // wrap
	  }
	};

	// constructor polyfill
	if(!useNative){
	  // 25.4.3.1 Promise(executor)
	  P = function Promise(executor){
	    aFunction(executor);
	    var record = {
	      p: strictNew(this, P, PROMISE),         // <- promise
	      c: [],                                  // <- awaiting reactions
	      a: undefined,                           // <- checked in isUnhandled reactions
	      s: 0,                                   // <- state
	      d: false,                               // <- done
	      v: undefined,                           // <- value
	      h: false,                               // <- handled rejection
	      n: false                                // <- notify
	    };
	    this[RECORD] = record;
	    try {
	      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
	    } catch(err){
	      $reject.call(record, err);
	    }
	  };
	  __webpack_require__(/*! ./$.mix */ 144)(P.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var S = anObject(anObject(this).constructor)[SPECIES];
	      var react = {
	        ok:   typeof onFulfilled == 'function' ? onFulfilled : true,
	        fail: typeof onRejected == 'function'  ? onRejected  : false
	      };
	      var promise = react.P = new (S != undefined ? S : P)(function(res, rej){
	        react.res = res;
	        react.rej = rej;
	      });
	      aFunction(react.res);
	      aFunction(react.rej);
	      var record = this[RECORD];
	      record.c.push(react);
	      if(record.a)record.a.push(react);
	      if(record.s)notify(record, false);
	      return promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	}

	// export
	$def($def.G + $def.W + $def.F * !useNative, {Promise: P});
	__webpack_require__(/*! ./$.tag */ 39)(P, PROMISE);
	species(P);
	species(Wrapper = __webpack_require__(/*! ./$.core */ 18)[PROMISE]);

	// statics
	$def($def.S + $def.F * !useNative, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    return new this(function(res, rej){ rej(r); });
	  }
	});
	$def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    return isPromise(x) && sameConstructor(x.constructor, this)
	      ? x : new this(function(res){ res(x); });
	  }
	});
	$def($def.S + $def.F * !(useNative && __webpack_require__(/*! ./$.iter-detect */ 118)(function(iter){
	  P.all(iter)['catch'](function(){});
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C      = getConstructor(this)
	      , values = [];
	    return new C(function(res, rej){
	      forOf(iterable, false, values.push, values);
	      var remaining = values.length
	        , results   = Array(remaining);
	      if(remaining)$.each.call(values, function(promise, index){
	        C.resolve(promise).then(function(value){
	          results[index] = value;
	          --remaining || res(results);
	        }, rej);
	      });
	      else res(results);
	    });
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C = getConstructor(this);
	    return new C(function(res, rej){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(res, rej);
	      });
	    });
	  }
	});

/***/ },
/* 140 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.strict-new.js ***!
  \********************************************************/
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name){
	  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
	  return it;
	};

/***/ },
/* 141 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.for-of.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(/*! ./$.ctx */ 24)
	  , call        = __webpack_require__(/*! ./$.iter-call */ 115)
	  , isArrayIter = __webpack_require__(/*! ./$.is-array-iter */ 116)
	  , anObject    = __webpack_require__(/*! ./$.an-object */ 34)
	  , toLength    = __webpack_require__(/*! ./$.to-length */ 29)
	  , getIterFn   = __webpack_require__(/*! ./core.get-iterator-method */ 117);
	module.exports = function(iterable, entries, fn, that){
	  var iterFn = getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    call(iterator, f, step.value, entries);
	  }
	};

/***/ },
/* 142 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.microtask.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(/*! ./$.global */ 12)
	  , macrotask = __webpack_require__(/*! ./$.task */ 143).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , isNode    = __webpack_require__(/*! ./$.cof */ 16)(process) == 'process'
	  , head, last, notify;

	var flush = function(){
	  var parent, domain;
	  if(isNode && (parent = process.domain)){
	    process.domain = null;
	    parent.exit();
	  }
	  while(head){
	    domain = head.domain;
	    if(domain)domain.enter();
	    head.fn.call(); // <- currently we use it only for Promise - try / catch not required
	    if(domain)domain.exit();
	    head = head.next;
	  } last = undefined;
	  if(parent)parent.enter();
	};

	// Node.js
	if(isNode){
	  notify = function(){
	    process.nextTick(flush);
	  };
	// browsers with MutationObserver
	} else if(Observer){
	  var toggle = 1
	    , node   = document.createTextNode('');
	  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	  notify = function(){
	    node.data = toggle = -toggle;
	  };
	// for other environments - macrotask based on:
	// - setImmediate
	// - MessageChannel
	// - window.postMessag
	// - onreadystatechange
	// - setTimeout
	} else {
	  notify = function(){
	    // strange IE + webpack dev server bug - use .call(global)
	    macrotask.call(global, flush);
	  };
	}

	module.exports = function asap(fn){
	  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
	  if(last)last.next = task;
	  if(!head){
	    head = task;
	    notify();
	  } last = task;
	};

/***/ },
/* 143 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.task.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx                = __webpack_require__(/*! ./$.ctx */ 24)
	  , invoke             = __webpack_require__(/*! ./$.invoke */ 22)
	  , html               = __webpack_require__(/*! ./$.html */ 11)
	  , cel                = __webpack_require__(/*! ./$.dom-create */ 13)
	  , global             = __webpack_require__(/*! ./$.global */ 12)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listner = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(/*! ./$.cof */ 16)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listner;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listner, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 144 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.mix.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $redef = __webpack_require__(/*! ./$.redef */ 20);
	module.exports = function(target, src){
	  for(var key in src)$redef(target, key, src[key]);
	  return target;
	};

/***/ },
/* 145 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.map.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(/*! ./$.collection-strong */ 146);

	// 23.1 Map Objects
	__webpack_require__(/*! ./$.collection */ 147)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 146 */
/*!***************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.collection-strong.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $            = __webpack_require__(/*! ./$ */ 7)
	  , hide         = __webpack_require__(/*! ./$.hide */ 19)
	  , ctx          = __webpack_require__(/*! ./$.ctx */ 24)
	  , species      = __webpack_require__(/*! ./$.species */ 124)
	  , strictNew    = __webpack_require__(/*! ./$.strict-new */ 140)
	  , defined      = __webpack_require__(/*! ./$.defined */ 28)
	  , forOf        = __webpack_require__(/*! ./$.for-of */ 141)
	  , step         = __webpack_require__(/*! ./$.iter-step */ 122)
	  , ID           = __webpack_require__(/*! ./$.uid */ 21)('id')
	  , $has         = __webpack_require__(/*! ./$.has */ 15)
	  , isObject     = __webpack_require__(/*! ./$.is-object */ 14)
	  , isExtensible = Object.isExtensible || isObject
	  , SUPPORT_DESC = __webpack_require__(/*! ./$.support-desc */ 8)
	  , SIZE         = SUPPORT_DESC ? '_s' : 'size'
	  , id           = 0;

	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!$has(it, ID)){
	    // can't set id to frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add id
	    if(!create)return 'E';
	    // add missing object id
	    hide(it, ID, ++id);
	  // return object id with prefix
	  } return 'O' + it[ID];
	};

	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};

	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      strictNew(that, C, NAME);
	      that._i = $.create(null); // index
	      that._f = undefined;      // first entry
	      that._l = undefined;      // last entry
	      that[SIZE] = 0;           // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    __webpack_require__(/*! ./$.mix */ 144)(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(SUPPORT_DESC)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    __webpack_require__(/*! ./$.iter-define */ 102)(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    species(C);
	    species(__webpack_require__(/*! ./$.core */ 18)[NAME]); // for wrapper
	  }
	};

/***/ },
/* 147 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.collection.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global     = __webpack_require__(/*! ./$.global */ 12)
	  , $def       = __webpack_require__(/*! ./$.def */ 17)
	  , forOf      = __webpack_require__(/*! ./$.for-of */ 141)
	  , strictNew  = __webpack_require__(/*! ./$.strict-new */ 140);

	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    __webpack_require__(/*! ./$.redef */ 20)(proto, KEY,
	      KEY == 'delete' ? function(a){ return fn.call(this, a === 0 ? 0 : a); }
	      : KEY == 'has' ? function has(a){ return fn.call(this, a === 0 ? 0 : a); }
	      : KEY == 'get' ? function get(a){ return fn.call(this, a === 0 ? 0 : a); }
	      : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	      : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !__webpack_require__(/*! ./$.fails */ 9)(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    __webpack_require__(/*! ./$.mix */ 144)(C.prototype, methods);
	  } else {
	    var inst  = new C
	      , chain = inst[ADDER](IS_WEAK ? {} : -0, 1)
	      , buggyZero;
	    // wrap for init collections from iterable
	    if(!__webpack_require__(/*! ./$.iter-detect */ 118)(function(iter){ new C(iter); })){ // eslint-disable-line no-new
	      C = wrapper(function(target, iterable){
	        strictNew(target, C, NAME);
	        var that = new Base;
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    IS_WEAK || inst.forEach(function(val, key){
	      buggyZero = 1 / key === -Infinity;
	    });
	    // fix converting -0 key to +0
	    if(buggyZero){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    // + fix .add & .set for chaining
	    if(buggyZero || chain !== inst)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }

	  __webpack_require__(/*! ./$.tag */ 39)(C, NAME);

	  O[NAME] = C;
	  $def($def.G + $def.W + $def.F * (C != Base), O);

	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

	  return C;
	};

/***/ },
/* 148 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.set.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(/*! ./$.collection-strong */ 146);

	// 23.2 Set Objects
	__webpack_require__(/*! ./$.collection */ 147)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 149 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.weak-map.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $            = __webpack_require__(/*! ./$ */ 7)
	  , weak         = __webpack_require__(/*! ./$.collection-weak */ 150)
	  , isObject     = __webpack_require__(/*! ./$.is-object */ 14)
	  , has          = __webpack_require__(/*! ./$.has */ 15)
	  , frozenStore  = weak.frozenStore
	  , WEAK         = weak.WEAK
	  , isExtensible = Object.isExtensible || isObject
	  , tmp          = {};

	// 23.3 WeakMap Objects
	var $WeakMap = __webpack_require__(/*! ./$.collection */ 147)('WeakMap', function(get){
	  return function WeakMap(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      if(!isExtensible(key))return frozenStore(this).get(key);
	      if(has(key, WEAK))return key[WEAK][this._i];
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	}, weak, true, true);

	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  $.each.call(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    __webpack_require__(/*! ./$.redef */ 20)(proto, key, function(a, b){
	      // store frozen objects on leaky map
	      if(isObject(a) && !isExtensible(a)){
	        var result = frozenStore(this)[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 150 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.collection-weak.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide         = __webpack_require__(/*! ./$.hide */ 19)
	  , anObject     = __webpack_require__(/*! ./$.an-object */ 34)
	  , strictNew    = __webpack_require__(/*! ./$.strict-new */ 140)
	  , forOf        = __webpack_require__(/*! ./$.for-of */ 141)
	  , method       = __webpack_require__(/*! ./$.array-methods */ 23)
	  , WEAK         = __webpack_require__(/*! ./$.uid */ 21)('weak')
	  , isObject     = __webpack_require__(/*! ./$.is-object */ 14)
	  , $has         = __webpack_require__(/*! ./$.has */ 15)
	  , isExtensible = Object.isExtensible || isObject
	  , find         = method(5)
	  , findIndex    = method(6)
	  , id           = 0;

	// fallback for frozen keys
	var frozenStore = function(that){
	  return that._l || (that._l = new FrozenStore);
	};
	var FrozenStore = function(){
	  this.a = [];
	};
	var findFrozen = function(store, key){
	  return find(store.a, function(it){
	    return it[0] === key;
	  });
	};
	FrozenStore.prototype = {
	  get: function(key){
	    var entry = findFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = findIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};

	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      strictNew(that, C, NAME);
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    __webpack_require__(/*! ./$.mix */ 144)(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        if(!isExtensible(key))return frozenStore(this)['delete'](key);
	        return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        if(!isExtensible(key))return frozenStore(this).has(key);
	        return $has(key, WEAK) && $has(key[WEAK], this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    if(!isExtensible(anObject(key))){
	      frozenStore(that).set(key, value);
	    } else {
	      $has(key, WEAK) || hide(key, WEAK, {});
	      key[WEAK][that._i] = value;
	    } return that;
	  },
	  frozenStore: frozenStore,
	  WEAK: WEAK
	};

/***/ },
/* 151 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.weak-set.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(/*! ./$.collection-weak */ 150);

	// 23.4 WeakSet Objects
	__webpack_require__(/*! ./$.collection */ 147)('WeakSet', function(get){
	  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 152 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.apply.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $def   = __webpack_require__(/*! ./$.def */ 17)
	  , _apply = Function.apply;

	$def($def.S, 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList){
	    return _apply.call(target, thisArgument, argumentsList);
	  }
	});

/***/ },
/* 153 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.construct.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $         = __webpack_require__(/*! ./$ */ 7)
	  , $def      = __webpack_require__(/*! ./$.def */ 17)
	  , aFunction = __webpack_require__(/*! ./$.a-function */ 25)
	  , anObject  = __webpack_require__(/*! ./$.an-object */ 34)
	  , isObject  = __webpack_require__(/*! ./$.is-object */ 14)
	  , bind      = Function.bind || __webpack_require__(/*! ./$.core */ 18).Function.prototype.bind;

	// MS Edge supports only 2 arguments
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	$def($def.S + $def.F * __webpack_require__(/*! ./$.fails */ 9)(function(){
	  function F(){}
	  return !(Reflect.construct(function(){}, [], F) instanceof F);
	}), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/){
	    aFunction(Target);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if(Target == newTarget){
	      // w/o altered newTarget, optimization for 0-4 arguments
	      if(args != undefined)switch(anObject(args).length){
	        case 0: return new Target;
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args));
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto    = newTarget.prototype
	      , instance = $.create(isObject(proto) ? proto : Object.prototype)
	      , result   = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ },
/* 154 */
/*!***********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.define-property.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var $        = __webpack_require__(/*! ./$ */ 7)
	  , $def     = __webpack_require__(/*! ./$.def */ 17)
	  , anObject = __webpack_require__(/*! ./$.an-object */ 34);

	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$def($def.S + $def.F * __webpack_require__(/*! ./$.fails */ 9)(function(){
	  Reflect.defineProperty($.setDesc({}, 1, {value: 1}), 1, {value: 2});
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    anObject(target);
	    try {
	      $.setDesc(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 155 */
/*!***********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.delete-property.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $def     = __webpack_require__(/*! ./$.def */ 17)
	  , getDesc  = __webpack_require__(/*! ./$ */ 7).getDesc
	  , anObject = __webpack_require__(/*! ./$.an-object */ 34);

	$def($def.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = getDesc(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ },
/* 156 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.enumerate.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $def     = __webpack_require__(/*! ./$.def */ 17)
	  , anObject = __webpack_require__(/*! ./$.an-object */ 34);
	var Enumerate = function(iterated){
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = []       // keys
	    , key;
	  for(key in iterated)keys.push(key);
	};
	__webpack_require__(/*! ./$.iter-create */ 104)(Enumerate, 'Object', function(){
	  var that = this
	    , keys = that._k
	    , key;
	  do {
	    if(that._i >= keys.length)return {value: undefined, done: true};
	  } while(!((key = keys[that._i++]) in that._t));
	  return {value: key, done: false};
	});

	$def($def.S, 'Reflect', {
	  enumerate: function enumerate(target){
	    return new Enumerate(target);
	  }
	});

/***/ },
/* 157 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.get.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var $        = __webpack_require__(/*! ./$ */ 7)
	  , has      = __webpack_require__(/*! ./$.has */ 15)
	  , $def     = __webpack_require__(/*! ./$.def */ 17)
	  , isObject = __webpack_require__(/*! ./$.is-object */ 14)
	  , anObject = __webpack_require__(/*! ./$.an-object */ 34);

	function get(target, propertyKey/*, receiver*/){
	  var receiver = arguments.length < 3 ? target : arguments[2]
	    , desc, proto;
	  if(anObject(target) === receiver)return target[propertyKey];
	  if(desc = $.getDesc(target, propertyKey))return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if(isObject(proto = $.getProto(target)))return get(proto, propertyKey, receiver);
	}

	$def($def.S, 'Reflect', {get: get});

/***/ },
/* 158 */
/*!***********************************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.get-own-property-descriptor.js ***!
  \***********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var $        = __webpack_require__(/*! ./$ */ 7)
	  , $def     = __webpack_require__(/*! ./$.def */ 17)
	  , anObject = __webpack_require__(/*! ./$.an-object */ 34);

	$def($def.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return $.getDesc(anObject(target), propertyKey);
	  }
	});

/***/ },
/* 159 */
/*!************************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.get-prototype-of.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $def     = __webpack_require__(/*! ./$.def */ 17)
	  , getProto = __webpack_require__(/*! ./$ */ 7).getProto
	  , anObject = __webpack_require__(/*! ./$.an-object */ 34);

	$def($def.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(anObject(target));
	  }
	});

/***/ },
/* 160 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.has.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Reflect', {
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  }
	});

/***/ },
/* 161 */
/*!*********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.is-extensible.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $def          = __webpack_require__(/*! ./$.def */ 17)
	  , anObject      = __webpack_require__(/*! ./$.an-object */ 34)
	  , $isExtensible = Object.isExtensible;

	$def($def.S, 'Reflect', {
	  isExtensible: function isExtensible(target){
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ },
/* 162 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.own-keys.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $def = __webpack_require__(/*! ./$.def */ 17);

	$def($def.S, 'Reflect', {ownKeys: __webpack_require__(/*! ./$.own-keys */ 163)});

/***/ },
/* 163 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.own-keys.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var $        = __webpack_require__(/*! ./$ */ 7)
	  , anObject = __webpack_require__(/*! ./$.an-object */ 34)
	  , Reflect  = __webpack_require__(/*! ./$.global */ 12).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
	  var keys       = $.getNames(anObject(it))
	    , getSymbols = $.getSymbols;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 164 */
/*!**************************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.prevent-extensions.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $def               = __webpack_require__(/*! ./$.def */ 17)
	  , anObject           = __webpack_require__(/*! ./$.an-object */ 34)
	  , $preventExtensions = Object.preventExtensions;

	$def($def.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target){
	    anObject(target);
	    try {
	      if($preventExtensions)$preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 165 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.set.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var $          = __webpack_require__(/*! ./$ */ 7)
	  , has        = __webpack_require__(/*! ./$.has */ 15)
	  , $def       = __webpack_require__(/*! ./$.def */ 17)
	  , createDesc = __webpack_require__(/*! ./$.property-desc */ 10)
	  , anObject   = __webpack_require__(/*! ./$.an-object */ 34)
	  , isObject   = __webpack_require__(/*! ./$.is-object */ 14);

	function set(target, propertyKey, V/*, receiver*/){
	  var receiver = arguments.length < 4 ? target : arguments[3]
	    , ownDesc  = $.getDesc(anObject(target), propertyKey)
	    , existingDescriptor, proto;
	  if(!ownDesc){
	    if(isObject(proto = $.getProto(target))){
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if(has(ownDesc, 'value')){
	    if(ownDesc.writable === false || !isObject(receiver))return false;
	    existingDescriptor = $.getDesc(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    $.setDesc(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}

	$def($def.S, 'Reflect', {set: set});

/***/ },
/* 166 */
/*!************************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.set-prototype-of.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $def     = __webpack_require__(/*! ./$.def */ 17)
	  , setProto = __webpack_require__(/*! ./$.set-proto */ 49);

	if(setProto)$def($def.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto){
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 167 */
/*!**************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.array.includes.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $def      = __webpack_require__(/*! ./$.def */ 17)
	  , $includes = __webpack_require__(/*! ./$.array-includes */ 37)(true);
	$def($def.P, 'Array', {
	  // https://github.com/domenic/Array.prototype.includes
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(/*! ./$.unscope */ 121)('includes');

/***/ },
/* 168 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.string.at.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/mathiasbynens/String.prototype.at
	'use strict';
	var $def = __webpack_require__(/*! ./$.def */ 17)
	  , $at  = __webpack_require__(/*! ./$.string-at */ 101)(true);
	$def($def.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 169 */
/*!***************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.string.pad-left.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $def = __webpack_require__(/*! ./$.def */ 17)
	  , $pad = __webpack_require__(/*! ./$.string-pad */ 170);
	$def($def.P, 'String', {
	  padLeft: function padLeft(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ },
/* 170 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.string-pad.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-string-pad-left-right
	var toLength = __webpack_require__(/*! ./$.to-length */ 29)
	  , repeat   = __webpack_require__(/*! ./$.string-repeat */ 112)
	  , defined  = __webpack_require__(/*! ./$.defined */ 28);

	module.exports = function(that, maxLength, fillString, left){
	  var S            = String(defined(that))
	    , stringLength = S.length
	    , fillStr      = fillString === undefined ? ' ' : String(fillString)
	    , intMaxLength = toLength(maxLength);
	  if(intMaxLength <= stringLength)return S;
	  if(fillStr == '')fillStr = ' ';
	  var fillLen = intMaxLength - stringLength
	    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};

/***/ },
/* 171 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.string.pad-right.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $def = __webpack_require__(/*! ./$.def */ 17)
	  , $pad = __webpack_require__(/*! ./$.string-pad */ 170);
	$def($def.P, 'String', {
	  padRight: function padRight(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ },
/* 172 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.string.trim-left.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(/*! ./$.string-trim */ 99)('trimLeft', function($trim){
	  return function trimLeft(){
	    return $trim(this, 1);
	  };
	});

/***/ },
/* 173 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.string.trim-right.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(/*! ./$.string-trim */ 99)('trimRight', function($trim){
	  return function trimRight(){
	    return $trim(this, 2);
	  };
	});

/***/ },
/* 174 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.regexp.escape.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $def = __webpack_require__(/*! ./$.def */ 17)
	  , $re  = __webpack_require__(/*! ./$.replacer */ 175)(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	$def($def.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ },
/* 175 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.replacer.js ***!
  \******************************************************/
/***/ function(module, exports) {

	module.exports = function(regExp, replace){
	  var replacer = replace === Object(replace) ? function(part){
	    return replace[part];
	  } : replace;
	  return function(it){
	    return String(it).replace(regExp, replacer);
	  };
	};

/***/ },
/* 176 */
/*!***********************************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \***********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/WebReflection/9353781
	var $          = __webpack_require__(/*! ./$ */ 7)
	  , $def       = __webpack_require__(/*! ./$.def */ 17)
	  , ownKeys    = __webpack_require__(/*! ./$.own-keys */ 163)
	  , toIObject  = __webpack_require__(/*! ./$.to-iobject */ 35)
	  , createDesc = __webpack_require__(/*! ./$.property-desc */ 10);

	$def($def.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O       = toIObject(object)
	      , setDesc = $.setDesc
	      , getDesc = $.getDesc
	      , keys    = ownKeys(O)
	      , result  = {}
	      , i       = 0
	      , key, D;
	    while(keys.length > i){
	      D = getDesc(O, key = keys[i++]);
	      if(key in result)setDesc(result, key, createDesc(0, D));
	      else result[key] = D;
	    } return result;
	  }
	});

/***/ },
/* 177 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.object.values.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// http://goo.gl/XkBrjD
	var $def    = __webpack_require__(/*! ./$.def */ 17)
	  , $values = __webpack_require__(/*! ./$.object-to-array */ 178)(false);

	$def($def.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 178 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.object-to-array.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $         = __webpack_require__(/*! ./$ */ 7)
	  , toIObject = __webpack_require__(/*! ./$.to-iobject */ 35)
	  , isEnum    = $.isEnum;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = $.getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 179 */
/*!**************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.object.entries.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// http://goo.gl/XkBrjD
	var $def     = __webpack_require__(/*! ./$.def */ 17)
	  , $entries = __webpack_require__(/*! ./$.object-to-array */ 178)(true);

	$def($def.S, 'Object', {
	  entries: function entries(it){
	    return $entries(it);
	  }
	});

/***/ },
/* 180 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.map.to-json.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $def  = __webpack_require__(/*! ./$.def */ 17);

	$def($def.P, 'Map', {toJSON: __webpack_require__(/*! ./$.collection-to-json */ 181)('Map')});

/***/ },
/* 181 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.collection-to-json.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var forOf   = __webpack_require__(/*! ./$.for-of */ 141)
	  , classof = __webpack_require__(/*! ./$.classof */ 51);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    var arr = [];
	    forOf(this, false, arr.push, arr);
	    return arr;
	  };
	};

/***/ },
/* 182 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.set.to-json.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $def  = __webpack_require__(/*! ./$.def */ 17);

	$def($def.P, 'Set', {toJSON: __webpack_require__(/*! ./$.collection-to-json */ 181)('Set')});

/***/ },
/* 183 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/js.array.statics.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// JavaScript 1.6 / Strawman array statics shim
	var $       = __webpack_require__(/*! ./$ */ 7)
	  , $def    = __webpack_require__(/*! ./$.def */ 17)
	  , $Array  = __webpack_require__(/*! ./$.core */ 18).Array || Array
	  , statics = {};
	var setStatics = function(keys, length){
	  $.each.call(keys.split(','), function(key){
	    if(length == undefined && key in $Array)statics[key] = $Array[key];
	    else if(key in [])statics[key] = __webpack_require__(/*! ./$.ctx */ 24)(Function.call, [][key], length);
	  });
	};
	setStatics('pop,reverse,shift,keys,values,entries', 1);
	setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
	setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
	           'reduce,reduceRight,copyWithin,fill');
	$def($def.S, 'Array', statics);

/***/ },
/* 184 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/web.timers.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global     = __webpack_require__(/*! ./$.global */ 12)
	  , $def       = __webpack_require__(/*! ./$.def */ 17)
	  , invoke     = __webpack_require__(/*! ./$.invoke */ 22)
	  , partial    = __webpack_require__(/*! ./$.partial */ 185)
	  , navigator  = global.navigator
	  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      typeof fn == 'function' ? fn : Function(fn)
	    ), time);
	  } : set;
	};
	$def($def.G + $def.B + $def.F * MSIE, {
	  setTimeout:  wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ },
/* 185 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.partial.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path      = __webpack_require__(/*! ./$.path */ 186)
	  , invoke    = __webpack_require__(/*! ./$.invoke */ 22)
	  , aFunction = __webpack_require__(/*! ./$.a-function */ 25);
	module.exports = function(/* ...pargs */){
	  var fn     = aFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that  = this
	      , $$    = arguments
	      , $$len = $$.length
	      , j = 0, k = 0, args;
	    if(!holder && !$$len)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = $$[k++];
	    while($$len > k)args.push($$[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 186 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.path.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./$.global */ 12);

/***/ },
/* 187 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/web.immediate.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $def  = __webpack_require__(/*! ./$.def */ 17)
	  , $task = __webpack_require__(/*! ./$.task */ 143);
	$def($def.G + $def.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 188 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/web.dom.iterable.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./es6.array.iterator */ 120);
	var global      = __webpack_require__(/*! ./$.global */ 12)
	  , hide        = __webpack_require__(/*! ./$.hide */ 19)
	  , Iterators   = __webpack_require__(/*! ./$.iterators */ 103)
	  , ITERATOR    = __webpack_require__(/*! ./$.wks */ 32)('iterator')
	  , NL          = global.NodeList
	  , HTC         = global.HTMLCollection
	  , NLProto     = NL && NL.prototype
	  , HTCProto    = HTC && HTC.prototype
	  , ArrayValues = Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
	if(NL && !(ITERATOR in NLProto))hide(NLProto, ITERATOR, ArrayValues);
	if(HTC && !(ITERATOR in HTCProto))hide(HTCProto, ITERATOR, ArrayValues);

/***/ },
/* 189 */
/*!***********************************************!*\
  !*** ./~/babel-core/~/regenerator/runtime.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */

	!(function(global) {
	  "use strict";

	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var iteratorSymbol =
	    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }

	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);

	    generator._invoke = makeInvokeMethod(
	      innerFn, self || null,
	      new Context(tryLocsList || [])
	    );

	    return generator;
	  }
	  runtime.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  runtime.mark = function(genFun) {
	    genFun.__proto__ = GeneratorFunctionPrototype;
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };

	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }

	  function AsyncIterator(generator) {
	    // This invoke function is written in a style that assumes some
	    // calling function (or Promise) will handle exceptions.
	    function invoke(method, arg) {
	      var result = generator[method](arg);
	      var value = result.value;
	      return value instanceof AwaitArgument
	        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
	        : Promise.resolve(value).then(function(unwrapped) {
	            // When a yielded Promise is resolved, its final value becomes
	            // the .value of the Promise<{value,done}> result for the
	            // current iteration. If the Promise is rejected, however, the
	            // result for this iteration will be rejected with the same
	            // reason. Note that rejections of yielded Promises are not
	            // thrown back into the generator function, as is the case
	            // when an awaited Promise is rejected. This difference in
	            // behavior between yield and await is important, because it
	            // allows the consumer to decide what to do with the yielded
	            // rejection (swallow it and continue, manually .throw it back
	            // into the generator, abandon iteration, whatever). With
	            // await, by contrast, there is no opportunity to examine the
	            // rejection reason outside the generator function, so the
	            // only option is to throw it from the await expression, and
	            // let the generator function handle the exception.
	            result.value = unwrapped;
	            return result;
	          });
	    }

	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }

	    var invokeNext = invoke.bind(generator, "next");
	    var invokeThrow = invoke.bind(generator, "throw");
	    var invokeReturn = invoke.bind(generator, "return");
	    var previousPromise;

	    function enqueue(method, arg) {
	      var enqueueResult =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(function() {
	          return invoke(method, arg);
	        }) : new Promise(function(resolve) {
	          resolve(invoke(method, arg));
	        });

	      // Avoid propagating enqueueResult failures to Promises returned by
	      // later invocations of the iterator.
	      previousPromise = enqueueResult["catch"](function(ignored){});

	      return enqueueResult;
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;

	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }

	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }

	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );

	          if (record.type === "throw") {
	            context.delegate = null;

	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }

	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;

	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }

	          context.delegate = null;
	        }

	        if (method === "next") {
	          if (state === GenStateSuspendedYield) {
	            context.sent = arg;
	          } else {
	            context.sent = undefined;
	          }

	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }

	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }

	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          var info = {
	            value: record.arg,
	            done: context.done
	          };

	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;

	  function doneResult() {
	    return { value: undefined, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = undefined;
	      this.done = false;
	      this.delegate = null;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }

	      return ContinueSentinel;
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 190)))

/***/ },
/* 190 */
/*!**********************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/process/browser.js ***!
  \**********************************************************/
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 191 */
/*!*********************************!*\
  !*** ./~/stats.js/src/Stats.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var Stats = function () {

		var startTime = Date.now(), prevTime = startTime;
		var ms = 0, msMin = Infinity, msMax = 0;
		var fps = 0, fpsMin = Infinity, fpsMax = 0;
		var frames = 0, mode = 0;

		var container = document.createElement( 'div' );
		container.id = 'stats';
		container.addEventListener( 'mousedown', function ( event ) { event.preventDefault(); setMode( ++ mode % 2 ) }, false );
		container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer';

		var fpsDiv = document.createElement( 'div' );
		fpsDiv.id = 'fps';
		fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
		container.appendChild( fpsDiv );

		var fpsText = document.createElement( 'div' );
		fpsText.id = 'fpsText';
		fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
		fpsText.innerHTML = 'FPS';
		fpsDiv.appendChild( fpsText );

		var fpsGraph = document.createElement( 'div' );
		fpsGraph.id = 'fpsGraph';
		fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
		fpsDiv.appendChild( fpsGraph );

		while ( fpsGraph.children.length < 74 ) {

			var bar = document.createElement( 'span' );
			bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
			fpsGraph.appendChild( bar );

		}

		var msDiv = document.createElement( 'div' );
		msDiv.id = 'ms';
		msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
		container.appendChild( msDiv );

		var msText = document.createElement( 'div' );
		msText.id = 'msText';
		msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
		msText.innerHTML = 'MS';
		msDiv.appendChild( msText );

		var msGraph = document.createElement( 'div' );
		msGraph.id = 'msGraph';
		msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
		msDiv.appendChild( msGraph );

		while ( msGraph.children.length < 74 ) {

			var bar = document.createElement( 'span' );
			bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
			msGraph.appendChild( bar );

		}

		var setMode = function ( value ) {

			mode = value;

			switch ( mode ) {

				case 0:
					fpsDiv.style.display = 'block';
					msDiv.style.display = 'none';
					break;
				case 1:
					fpsDiv.style.display = 'none';
					msDiv.style.display = 'block';
					break;
			}

		};

		var updateGraph = function ( dom, value ) {

			var child = dom.appendChild( dom.firstChild );
			child.style.height = value + 'px';

		};

		return {

			REVISION: 12,

			domElement: container,

			setMode: setMode,

			begin: function () {

				startTime = Date.now();

			},

			end: function () {

				var time = Date.now();

				ms = time - startTime;
				msMin = Math.min( msMin, ms );
				msMax = Math.max( msMax, ms );

				msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
				updateGraph( msGraph, Math.min( 30, 30 - ( ms / 200 ) * 30 ) );

				frames ++;

				if ( time > prevTime + 1000 ) {

					fps = Math.round( ( frames * 1000 ) / ( time - prevTime ) );
					fpsMin = Math.min( fpsMin, fps );
					fpsMax = Math.max( fpsMax, fps );

					fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
					updateGraph( fpsGraph, Math.min( 30, 30 - ( fps / 100 ) * 30 ) );

					prevTime = time;
					frames = 0;

				}

				return time;

			},

			update: function () {

				startTime = this.end();

			}

		}

	};

	if ( true ) {

		module.exports = Stats;

	}

/***/ },
/* 192 */
/*!***************************!*\
  !*** ./static/js/game.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _classCallCheck = __webpack_require__(/*! babel-runtime/helpers/class-call-check */ 193)["default"];

	var _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 1)["default"];

	exports.__esModule = true;

	var _engine = __webpack_require__(/*! engine */ 194);

	var _materials = __webpack_require__(/*! materials */ 217);

	var _props = __webpack_require__(/*! props */ 218);

	var _utilGui = __webpack_require__(/*! util/gui */ 220);

	var _constMaterial = __webpack_require__(/*! const/material */ 219);

	var _constMaterial2 = _interopRequireDefault(_constMaterial);

	var _proceduralTerrain = __webpack_require__(/*! procedural/terrain */ 227);

	var _proceduralTerrain2 = _interopRequireDefault(_proceduralTerrain);

	var _proceduralNoise = __webpack_require__(/*! procedural/noise */ 228);

	var _proceduralBiome = __webpack_require__(/*! procedural/biome */ 243);

	var _proceduralNebula = __webpack_require__(/*! procedural/nebula */ 244);

	var _proceduralStarfield = __webpack_require__(/*! procedural/starfield */ 248);

	var _utilPlane = __webpack_require__(/*! util/plane */ 249);

	var _utilPlane2 = _interopRequireDefault(_utilPlane);

	var _amoeba = __webpack_require__(/*! amoeba */ 250);

	var _amoeba2 = _interopRequireDefault(_amoeba);

	var Game = (function () {
	    function Game(container_id) {
	        var _this = this;

	        var chunkSize = arguments.length <= 1 || arguments[1] === undefined ? 32 : arguments[1];

	        _classCallCheck(this, Game);

	        this.width = window.innerWidth;
	        this.height = window.innerHeight;
	        this.view_angle = 45;
	        this.aspect = this.width / this.height;
	        this.near = 0.1;
	        this.far = 1000000;
	        this.chunkSize = chunkSize;

	        this.clock = new _engine.THREE.Clock();
	        this.renderer = new _engine.THREE.WebGLRenderer({ alpha: true });
	        this.renderer.setSize(this.width, this.height);
	        this.renderer.setClearColor(0x000000, 1);

	        this.scene = new _engine.THREE.Scene();

	        this.camera = new _engine.THREE.PerspectiveCamera(this.view_angle, this.aspect, this.near, this.far);
	        this.camera.position.y = 5;
	        this.camera.position.x = -20;

	        this.composer = new _engine.THREE.EffectComposer(this.renderer);
	        this.composer.addPass(new _engine.THREE.RenderPass(this.scene, this.camera));

	        this.glitchPass = new _engine.THREE.GlitchPass();
	        this.glitchPass.renderToScreen = true;
	        this.composer.addPass(this.glitchPass);

	        this.controls = new _engine.OrbitControls(this.camera, this.renderer.domElement);
	        this.keyboard = new _engine.KeyboardState();

	        this.biome = new _proceduralBiome.Biome();

	        document.getElementById(container_id).appendChild(this.renderer.domElement);
	        window.addEventListener("resize", function () {
	            return _this.resize();
	        });
	    }

	    Game.prototype.init = function init() {
	        var _this2 = this;

	        this.gui = new _utilGui.dat.GUI();

	        this.propConfig = {
	            "starfield": true,
	            "nebulas": true,
	            "axes": true,
	            "grid": true
	        };

	        // don't put stars too close to the terrain
	        this.propConfig._starfield = _proceduralStarfield.Starfield(1500, this.chunkSize * 64, function (x, y, z, R) {
	            return Math.abs(y) < _this2.chunkSize * 4 && R < _this2.chunkSize * 48;
	        });
	        this.propConfig._nebulas = _proceduralNebula.Nebula(8 * this.chunkSize);
	        this.propConfig._axes = _props.Axes(16 * this.chunkSize);
	        this.propConfig._grid = _props.Grid(16 * this.chunkSize, this.chunkSize);

	        var props = this.gui.addFolder("Props");
	        props.add(this.propConfig, "starfield").onChange(_utilGui.toggleObject("starfield", this.propConfig, this.scene, this.propConfig.starfield));
	        props.add(this.propConfig, "nebulas").onChange(_utilGui.toggleObject("nebulas", this.propConfig, this.scene, this.propConfig.nebulas));
	        props.add(this.propConfig, "axes").onChange(_utilGui.toggleObject("axes", this.propConfig, this.scene, this.propConfig.axes));
	        props.add(this.propConfig, "grid").onChange(_utilGui.toggleObject("grid", this.propConfig, this.scene, this.propConfig.grid));

	        this.lightConfig = {
	            "ambientLightColor": 0x222222,
	            "sunColor": _constMaterial2["default"].SUN.color.getHex(),
	            "sunX": this.chunkSize * 16,
	            "sunY": this.chunkSize * 8,
	            "sunZ": 0,
	            "spotLightColor": 0xAA5533,
	            "spotLightX": 0,
	            "spotLightY": this.chunkSize * 16,
	            "spotLightZ": 0,
	            "spotLightHelper": false
	        };

	        var ambientLight = new _engine.THREE.AmbientLight(this.lightConfig.ambientLightColor);
	        this.scene.add(ambientLight);

	        this.sun = _props.Sun(20);
	        this.sun.position.set(this.lightConfig.sunX, this.lightConfig.sunY, this.lightConfig.sunZ);
	        this.scene.add(this.sun);

	        var spotLight = new _engine.THREE.SpotLight(0xAA5533);
	        spotLight.position.set(this.lightConfig.spotLightX, this.lightConfig.spotLightY, this.lightConfig.spotLightZ);
	        this.scene.add(spotLight);

	        var lights = this.gui.addFolder("Lights");
	        lights.addColor(this.lightConfig, "ambientLightColor").onChange(function (color) {
	            return ambientLight.color = new _engine.THREE.Color(color);
	        });
	        lights.addColor(this.lightConfig, "sunColor").onChange(function (color) {
	            _constMaterial2["default"].SUN.color = new _engine.THREE.Color(color);
	            _this2.sun.color = new _engine.THREE.Color(color);
	        });
	        lights.add(this.lightConfig, "sunX").onChange(function (x) {
	            return _this2.sun.position.x = x;
	        });
	        lights.add(this.lightConfig, "sunY").onChange(function (y) {
	            return _this2.sun.position.y = y;
	        });
	        lights.add(this.lightConfig, "sunZ").onChange(function (z) {
	            return _this2.sun.position.z = z;
	        });
	        lights.addColor(this.lightConfig, "spotLightColor").onChange(function (color) {
	            return spotLight.color = new _engine.THREE.Color(color);
	        });
	        lights.add(this.lightConfig, "spotLightX").onChange(function (x) {
	            return spotLight.position.x = x;
	        });
	        lights.add(this.lightConfig, "spotLightY").onChange(function (y) {
	            return spotLight.position.y = y;
	        });
	        lights.add(this.lightConfig, "spotLightZ").onChange(function (z) {
	            return spotLight.position.z = z;
	        });
	        lights.add(this.lightConfig, "spotLightHelper").onChange(function (enabled) {
	            if (enabled) {
	                _this2.lightConfig._spotLightHelper = new _engine.THREE.SpotLightHelper(spotLight);
	                _this2.scene.add(_this2.lightConfig._spotLightHelper);
	            } else {
	                _this2.scene.remove(_this2.lightConfig._spotLightHelper);
	                delete _this2.lightConfig._spotLightHelper;
	            }
	        });

	        this.amoeba = new _engine.THREE.Mesh(new _engine.THREE.SphereGeometry(0.1, 8, 8), new _engine.THREE.MeshLambertMaterial({ color: 0xFFFF00, emissive: 0xAA0033 }));
	        this.amoeba.add(this.camera);
	        this.amoeba.position.y = this.chunkSize;
	        this.scene.add(this.amoeba);

	        this.terrainConfig = {
	            "groundColor": _constMaterial2["default"].GROUND.color.getHex(),
	            "groundEmissive": _constMaterial2["default"].GROUND.emissive.getHex(),
	            "groundShininess": _constMaterial2["default"].GROUND.shininess,
	            "waterColor": _constMaterial2["default"].WATER.color.getHex(),
	            "waterEmissive": _constMaterial2["default"].WATER.emissive.getHex(),
	            "waterShininess": _constMaterial2["default"].WATER.shininess,
	            "waterOpacity": _constMaterial2["default"].WATER.opacity,
	            "lod": "camera",
	            "visibility": 20,
	            "fogColor": 0x1E1C19,
	            "fogDensity": 0.0000
	        };

	        this.scene.fog = new _engine.THREE.FogExp2(this.terrainConfig.fogColor, this.terrainConfig.fogDensity);
	        this.terrainConfig.lodTarget = this.camera;

	        var terrain = this.gui.addFolder("Terrain");
	        terrain.addColor(this.terrainConfig, "groundColor").onChange(function (color) {
	            return _constMaterial2["default"].GROUND.color = new _engine.THREE.Color(color);
	        });
	        terrain.addColor(this.terrainConfig, "groundEmissive").onChange(function (color) {
	            return _constMaterial2["default"].GROUND.emissive = new _engine.THREE.Color(color);
	        });
	        terrain.add(this.terrainConfig, "groundShininess").min(0).max(100).onChange(function (val) {
	            return _constMaterial2["default"].GROUND.shininess = val;
	        });
	        terrain.addColor(this.terrainConfig, "waterColor").onChange(function (color) {
	            return _constMaterial2["default"].WATER.color = new _engine.THREE.Color(color);
	        });
	        terrain.addColor(this.terrainConfig, "waterEmissive").onChange(function (color) {
	            return _constMaterial2["default"].WATER.emissive = new _engine.THREE.Color(color);
	        });
	        terrain.add(this.terrainConfig, "waterShininess").min(0).max(255).onChange(function (val) {
	            return _constMaterial2["default"].WATER.shininess = val;
	        });
	        terrain.add(this.terrainConfig, "waterOpacity", 0, 1).onChange(function (val) {
	            return _constMaterial2["default"].WATER.opacity = val;
	        });
	        terrain.add(this.terrainConfig, "lod").options(["camera", "amoeba"]).onChange(function (val) {
	            if (val === "camera") {
	                _this2.terrainConfig.lodTarget = _this2.camera;
	            } else {
	                _this2.terrainConfig.lodTarget = _this2.amoeba;
	            }
	        });
	        terrain.add(this.terrainConfig, "visibility").min(1).max(100).step(1);
	        terrain.addColor(this.terrainConfig, "fogColor").onChange(function (color) {
	            return _this2.scene.fog.color = new _engine.THREE.Color(color);
	        });
	        terrain.add(this.terrainConfig, "fogDensity").min(0).max(0.01).onChange(function (val) {
	            return _this2.scene.fog.density = val;
	        });
	    };

	    Game.prototype.resize = function resize() {
	        this.width = window.innerWidth;
	        this.height = window.innerHeight;
	        this.renderer.setSize(this.width, this.height);
	        this.camera.aspect = this.width / this.height;
	        this.camera.updateProjectionMatrix();
	    };

	    Game.prototype.update = function update() {
	        var _this3 = this;

	        var delta = this.clock.getDelta();
	        var timestamp = this.clock.getElapsedTime();

	        if (this.keyboard.pressed("a")) {
	            this.amoeba.rotation.y += 0.05;
	        }
	        if (this.keyboard.pressed("d")) {
	            this.amoeba.rotation.y -= 0.05;
	        }

	        var n = new _engine.THREE.Vector3(1, 0, 0).applyEuler(this.amoeba.rotation);
	        if (this.keyboard.pressed("w")) {
	            this.amoeba.position.add(n);
	        }
	        if (this.keyboard.pressed("s")) {
	            this.amoeba.position.add(n.negate());
	        }

	        if (this.keyboard.pressed("e")) {
	            this.amoeba.position.y += 1;
	        }
	        if (this.keyboard.pressed("q")) {
	            this.amoeba.position.y -= 1;
	        }

	        if (this.keyboard.pressed("g")) {
	            this.glitchPass.goWild = true;
	        } else {
	            this.glitchPass.goWild = false;
	        }

	        this.controls.update(delta);
	        var chunkX = Math.floor(this.amoeba.position.x / this.chunkSize + 0.5);
	        var chunkY = Math.floor(this.amoeba.position.z / this.chunkSize + 0.5);
	        var visibility = this.terrainConfig.visibility;

	        for (var i = -visibility; i <= visibility; i++) {
	            for (var j = -visibility; j <= visibility; j++) {
	                var x = chunkX + i;
	                var y = chunkY + j;
	                if (Math.pow(chunkX - x, 2) + Math.pow(chunkY - y, 2) > visibility) continue;
	                if (!this.biome.get(x, y)) {
	                    var terrainChunk = _proceduralTerrain2["default"].Ground(this.chunkSize, x, y);
	                    this.scene.add(terrainChunk);
	                    var waterChunk = _proceduralTerrain2["default"].Water(this.chunkSize, x, y);
	                    this.scene.add(waterChunk);
	                    this.biome.put(x, y, new _proceduralBiome.BiomeChunk(terrainChunk, waterChunk));
	                }

	                var chunk = this.biome.get(x, y);
	                chunk.terrain.update(this.terrainConfig.lodTarget);

	                var size = Math.sqrt(chunk.water.geometry.vertices.length);
	                var Fanimate = 2.3;
	                var Pa = 100;
	                var A = 0.2;
	                for (var _i = 0; _i < chunk.water.geometry.vertices.length; _i++) {
	                    var v = chunk.water.geometry.vertices[_i];
	                    var x0 = this.chunkSize * x + v.x;
	                    var y0 = this.chunkSize * y + v.z;
	                    var Fo = 2 * Math.PI / 3 * (Math.pow(x0 - y0, 2) % 3) + Pa * _proceduralNoise.perlin(x0 / Fanimate, y0 / Fanimate);
	                    v.y = A * Math.sin(Fanimate * timestamp + Fo);
	                }

	                chunk.water.geometry.verticesNeedUpdate = true;
	                chunk.water.geometry.normalsNeedUpdate = true;
	                chunk.water.geometry.computeFaceNormals();
	            }
	        }

	        //TODO move culling logic into biome
	        //TODO add a universal dispose method
	        this.biome.cull(function (x, y, chunk) {
	            if (Math.pow(chunkX - x, 2) + Math.pow(chunkY - y, 2) <= visibility) {
	                return false;
	            }

	            _this3.scene.remove(chunk.terrain);
	            for (var i = 0; i < chunk.terrain.levels.length; i++) {
	                chunk.terrain.levels[i].object.geometry.dispose();
	            }
	            _this3.scene.remove(chunk.water);
	            chunk.water.geometry.dispose();
	            return true;
	        });
	    };

	    Game.prototype.render = function render() {
	        this.composer.render();
	    };

	    return Game;
	})();

	exports["default"] = Game;
	module.exports = exports["default"];

/***/ },
/* 193 */
/*!*****************************************************!*\
  !*** ./~/babel-runtime/helpers/class-call-check.js ***!
  \*****************************************************/
/***/ function(module, exports) {

	"use strict";

	exports["default"] = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	exports.__esModule = true;

/***/ },
/* 194 */
/*!*****************************!*\
  !*** ./static/js/engine.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 1)["default"];

	exports.__esModule = true;

	var _threeJs = __webpack_require__(/*! three.js */ 195);

	var _threeJs2 = _interopRequireDefault(_threeJs);

	var _cannon = __webpack_require__(/*! cannon */ 196);

	var _cannon2 = _interopRequireDefault(_cannon);

	var _threeOrbitControls = __webpack_require__(/*! three-orbit-controls */ 197);

	var _threeOrbitControls2 = _interopRequireDefault(_threeOrbitControls);

	var _vendorKeyboard_state = __webpack_require__(/*! vendor/keyboard_state */ 198);

	var _vendorKeyboard_state2 = _interopRequireDefault(_vendorKeyboard_state);

	var _utilEcs = __webpack_require__(/*! util/ecs */ 209);

	var _utilEcs2 = _interopRequireDefault(_utilEcs);

	var _vendorThreeCopyShader = __webpack_require__(/*! vendor/three/CopyShader */ 210);

	var _vendorThreeCopyShader2 = _interopRequireDefault(_vendorThreeCopyShader);

	var _vendorThreeDigitalGlitch = __webpack_require__(/*! vendor/three/DigitalGlitch */ 211);

	var _vendorThreeDigitalGlitch2 = _interopRequireDefault(_vendorThreeDigitalGlitch);

	var _vendorThreeEffectComposer = __webpack_require__(/*! vendor/three/EffectComposer */ 212);

	var _vendorThreeEffectComposer2 = _interopRequireDefault(_vendorThreeEffectComposer);

	var _vendorThreeRenderPass = __webpack_require__(/*! vendor/three/RenderPass */ 213);

	var _vendorThreeRenderPass2 = _interopRequireDefault(_vendorThreeRenderPass);

	var _vendorThreeMaskPass = __webpack_require__(/*! vendor/three/MaskPass */ 214);

	var _vendorThreeShaderPass = __webpack_require__(/*! vendor/three/ShaderPass */ 215);

	var _vendorThreeShaderPass2 = _interopRequireDefault(_vendorThreeShaderPass);

	var _vendorThreeGlitchPass = __webpack_require__(/*! vendor/three/GlitchPass */ 216);

	var _vendorThreeGlitchPass2 = _interopRequireDefault(_vendorThreeGlitchPass);

	var OrbitControls = _threeOrbitControls2["default"](_threeJs2["default"]);

	_threeJs2["default"].CopyShader = _vendorThreeCopyShader2["default"];
	_threeJs2["default"].DigitalGlitch = _vendorThreeDigitalGlitch2["default"];
	_threeJs2["default"].EffectComposer = _vendorThreeEffectComposer2["default"](_threeJs2["default"]);
	_threeJs2["default"].RenderPass = _vendorThreeRenderPass2["default"](_threeJs2["default"]);
	_threeJs2["default"].MaskPass = _vendorThreeMaskPass.MaskPass;
	_threeJs2["default"].ClearMaskPass = _vendorThreeMaskPass.ClearMaskPass;
	_threeJs2["default"].ShaderPass = _vendorThreeShaderPass2["default"](_threeJs2["default"]);
	_threeJs2["default"].GlitchPass = _vendorThreeGlitchPass2["default"](_threeJs2["default"]);

	exports["default"] = { THREE: _threeJs2["default"], OrbitControls: OrbitControls, CANNON: _cannon2["default"], KeyboardState: _vendorKeyboard_state2["default"], ECS: _utilEcs2["default"] };
	module.exports = exports["default"];

/***/ },
/* 195 */
/*!***********************************!*\
  !*** ./~/three.js/build/three.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// File:src/Three.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var THREE = { REVISION: '72' };

	//

	if ( true ) {

			!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

			module.exports = THREE;

	}


	// polyfills

	if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

		// Missing in Android stock browser.

		( function () {

			var lastTime = 0;
			var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

			for ( var x = 0; x < vendors.length && ! self.requestAnimationFrame; ++ x ) {

				self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
				self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

			}

			if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

				self.requestAnimationFrame = function ( callback ) {

					var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
					var id = self.setTimeout( function () {

						callback( currTime + timeToCall );

					}, timeToCall );
					lastTime = currTime + timeToCall;
					return id;

				};

			}

			if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

				self.cancelAnimationFrame = function ( id ) {

					self.clearTimeout( id );

				};

			}

		}() );

	}

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

		};

	}

	if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

		// Missing in IE9-11.
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty( Function.prototype, 'name', {

			get: function () {

				return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

			}

		} );

	}

	// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

	THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

	// GL STATE CONSTANTS

	THREE.CullFaceNone = 0;
	THREE.CullFaceBack = 1;
	THREE.CullFaceFront = 2;
	THREE.CullFaceFrontBack = 3;

	THREE.FrontFaceDirectionCW = 0;
	THREE.FrontFaceDirectionCCW = 1;

	// SHADOWING TYPES

	THREE.BasicShadowMap = 0;
	THREE.PCFShadowMap = 1;
	THREE.PCFSoftShadowMap = 2;

	// MATERIAL CONSTANTS

	// side

	THREE.FrontSide = 0;
	THREE.BackSide = 1;
	THREE.DoubleSide = 2;

	// shading

	THREE.FlatShading = 1;
	THREE.SmoothShading = 2;

	// colors

	THREE.NoColors = 0;
	THREE.FaceColors = 1;
	THREE.VertexColors = 2;

	// blending modes

	THREE.NoBlending = 0;
	THREE.NormalBlending = 1;
	THREE.AdditiveBlending = 2;
	THREE.SubtractiveBlending = 3;
	THREE.MultiplyBlending = 4;
	THREE.CustomBlending = 5;

	// custom blending equations
	// (numbers start from 100 not to clash with other
	// mappings to OpenGL constants defined in Texture.js)

	THREE.AddEquation = 100;
	THREE.SubtractEquation = 101;
	THREE.ReverseSubtractEquation = 102;
	THREE.MinEquation = 103;
	THREE.MaxEquation = 104;

	// custom blending destination factors

	THREE.ZeroFactor = 200;
	THREE.OneFactor = 201;
	THREE.SrcColorFactor = 202;
	THREE.OneMinusSrcColorFactor = 203;
	THREE.SrcAlphaFactor = 204;
	THREE.OneMinusSrcAlphaFactor = 205;
	THREE.DstAlphaFactor = 206;
	THREE.OneMinusDstAlphaFactor = 207;

	// custom blending source factors

	//THREE.ZeroFactor = 200;
	//THREE.OneFactor = 201;
	//THREE.SrcAlphaFactor = 204;
	//THREE.OneMinusSrcAlphaFactor = 205;
	//THREE.DstAlphaFactor = 206;
	//THREE.OneMinusDstAlphaFactor = 207;
	THREE.DstColorFactor = 208;
	THREE.OneMinusDstColorFactor = 209;
	THREE.SrcAlphaSaturateFactor = 210;

	// depth modes

	THREE.NeverDepth = 0;
	THREE.AlwaysDepth = 1;
	THREE.LessDepth = 2;
	THREE.LessEqualDepth = 3;
	THREE.EqualDepth = 4;
	THREE.GreaterEqualDepth = 5;
	THREE.GreaterDepth = 6;
	THREE.NotEqualDepth = 7;


	// TEXTURE CONSTANTS

	THREE.MultiplyOperation = 0;
	THREE.MixOperation = 1;
	THREE.AddOperation = 2;

	// Mapping modes

	THREE.UVMapping = 300;

	THREE.CubeReflectionMapping = 301;
	THREE.CubeRefractionMapping = 302;

	THREE.EquirectangularReflectionMapping = 303;
	THREE.EquirectangularRefractionMapping = 304;

	THREE.SphericalReflectionMapping = 305;

	// Wrapping modes

	THREE.RepeatWrapping = 1000;
	THREE.ClampToEdgeWrapping = 1001;
	THREE.MirroredRepeatWrapping = 1002;

	// Filters

	THREE.NearestFilter = 1003;
	THREE.NearestMipMapNearestFilter = 1004;
	THREE.NearestMipMapLinearFilter = 1005;
	THREE.LinearFilter = 1006;
	THREE.LinearMipMapNearestFilter = 1007;
	THREE.LinearMipMapLinearFilter = 1008;

	// Data types

	THREE.UnsignedByteType = 1009;
	THREE.ByteType = 1010;
	THREE.ShortType = 1011;
	THREE.UnsignedShortType = 1012;
	THREE.IntType = 1013;
	THREE.UnsignedIntType = 1014;
	THREE.FloatType = 1015;
	THREE.HalfFloatType = 1025;

	// Pixel types

	//THREE.UnsignedByteType = 1009;
	THREE.UnsignedShort4444Type = 1016;
	THREE.UnsignedShort5551Type = 1017;
	THREE.UnsignedShort565Type = 1018;

	// Pixel formats

	THREE.AlphaFormat = 1019;
	THREE.RGBFormat = 1020;
	THREE.RGBAFormat = 1021;
	THREE.LuminanceFormat = 1022;
	THREE.LuminanceAlphaFormat = 1023;
	// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
	THREE.RGBEFormat = THREE.RGBAFormat; //1024;

	// DDS / ST3C Compressed texture formats

	THREE.RGB_S3TC_DXT1_Format = 2001;
	THREE.RGBA_S3TC_DXT1_Format = 2002;
	THREE.RGBA_S3TC_DXT3_Format = 2003;
	THREE.RGBA_S3TC_DXT5_Format = 2004;


	// PVRTC compressed texture formats

	THREE.RGB_PVRTC_4BPPV1_Format = 2100;
	THREE.RGB_PVRTC_2BPPV1_Format = 2101;
	THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
	THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


	// DEPRECATED

	THREE.Projector = function () {

		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

		this.projectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );

		};

		this.unprojectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );

		};

		this.pickingRay = function ( vector, camera ) {

			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

		};

	};

	THREE.CanvasRenderer = function () {

		console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

		this.domElement = document.createElement( 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};

	};

	// File:src/math/Color.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Color = function ( color ) {

		if ( arguments.length === 3 ) {

			return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

		}

		return this.set( color );

	};

	THREE.Color.prototype = {

		constructor: THREE.Color,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value instanceof THREE.Color ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function () {

			function hue2rgb ( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			}

			return function ( h, s, l ) {

				// h,s,l ranges are in 0.0 - 1.0
				h = THREE.Math.euclideanModulo( h, 1 );
				s = THREE.Math.clamp( s, 0, 1 );
				l = THREE.Math.clamp( l, 0, 1 );

				if ( s === 0 ) {

					this.r = this.g = this.b = l;

				} else {

					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;

					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );

				}

				return this;

			};

		}(),

		setStyle: function ( style ) {

			var parseAlpha = function ( strAlpha ) {

				var alpha = parseFloat( strAlpha );

				if ( alpha < 1 ) {

					console.warn( 'THREE.Color: Alpha component of color ' + style + ' will be ignored.' );

				}

				return alpha;

			}


			var m;

			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];

				switch ( name ) {

					case 'rgb':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*$/.exec( components ) ) {

							// rgb(255,0,0)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*$/.exec( components ) ) {

							// rgb(100%,0%,0%)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							return this;

						}

						break;

					case 'rgba':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

							// rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
							parseAlpha( color[ 4 ] );

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

							// rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
							parseAlpha( color[ 4 ] );

							return this;

						}

						break;

					case 'hsl':

						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*$/.exec( components ) ) {

							// hsl(120,50%,50%)
							var h = parseFloat( color[ 1 ] );
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;

							return this.setHSL( h, s, l );

						}

						break;

					case 'hsla':

						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

							// hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] );
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;
							parseAlpha( color[ 4 ] );

							return this.setHSL( h, s, l );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

				// hex color

				var hex = m[ 1 ];
				var size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				// color keywords
				var hex = THREE.ColorKeywords[ style ];

				if ( hex !== undefined ) {

					// red
					this.setHex( hex );

				} else {

					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );

				}

			}

			return this;

		},

		clone: function () {

			return new this.constructor( this.r, this.g, this.b );

		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		},

		copyLinearToGamma: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		},

		convertGammaToLinear: function () {

			var r = this.r, g = this.g, b = this.b;

			this.r = r * r;
			this.g = g * g;
			this.b = b * b;

			return this;

		},

		convertLinearToGamma: function () {

			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( optionalTarget ) {

			// h,s,l ranges are in 0.0 - 1.0

			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;

			return hsl;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function ( h, s, l ) {

			var hsl = this.getHSL();

			hsl.h += h; hsl.s += s; hsl.l += l;

			this.setHSL( hsl.h, hsl.s, hsl.l );

			return this;

		},

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array ) {

			this.r = array[ 0 ];
			this.g = array[ 1 ];
			this.b = array[ 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		}

	};

	THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	// File:src/math/Quaternion.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Quaternion = function ( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	};

	THREE.Quaternion.prototype = {

		constructor: THREE.Quaternion,

		get x () {

			return this._x;

		},

		set x ( value ) {

			this._x = value;
			this.onChangeCallback();

		},

		get y () {

			return this._y;

		},

		set y ( value ) {

			this._y = value;
			this.onChangeCallback();

		},

		get z () {

			return this._z;

		},

		set z ( value ) {

			this._z = value;
			this.onChangeCallback();

		},

		get w () {

			return this._w;

		},

		set w ( value ) {

			this._w = value;
			this.onChangeCallback();

		},

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( euler instanceof THREE.Euler === false ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );

			var order = euler.order;

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function () {

			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

			// assumes direction vectors vFrom and vTo are normalized

			var v1, r;

			var EPS = 0.000001;

			return function ( vFrom, vTo ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				r = vFrom.dot( vTo ) + 1;

				if ( r < EPS ) {

					r = 0;

					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

						v1.set( - vFrom.y, vFrom.x, 0 );

					} else {

						v1.set( 0, - vFrom.z, vFrom.y );

					}

				} else {

					v1.crossVectors( vFrom, vTo );

				}

				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;

				this.normalize();

				return this;

			}

		}(),

		inverse: function () {

			this.conjugate().normalize();

			return this;

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var halfTheta = Math.acos( cosHalfTheta );
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

			if ( Math.abs( sinHalfTheta ) < 0.001 ) {

				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );

				return this;

			}

			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this.onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	};

	THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	};

	// File:src/math/Vector2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.Vector2 = function ( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	};

	THREE.Vector2.prototype = {

		constructor: THREE.Vector2,

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.x *= s;
			this.y *= s;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;

			}

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector2();
					max = new THREE.Vector2();

				}

				min.set( minVal, minVal );
				max.set( maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		lengthManhattan: function() {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength ) {

				this.multiplyScalar( l / oldLength );

			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];

			return this;

		}

	};

	// File:src/math/Vector3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector3 = function ( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	};

	THREE.Vector3.prototype = {

		constructor: THREE.Vector3,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion;

			return function applyEuler( euler ) {

				if ( euler instanceof THREE.Euler === false ) {

					console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

				}

				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

				this.applyQuaternion( quaternion.setFromEuler( euler ) );

				return this;

			};

		}(),

		applyAxisAngle: function () {

			var quaternion;

			return function applyAxisAngle( axis, angle ) {

				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

				this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

				return this;

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			// input: THREE.Matrix4 affine matrix

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

			return this;

		},

		applyProjection: function ( m ) {

			// input: THREE.Matrix4 projection matrix

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;
			var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;

			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;

			// calculate quat * vector

			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function () {

			var matrix;

			return function project( camera ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyProjection( matrix );

			};

		}(),

		unproject: function () {

			var matrix;

			return function unproject( camera ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyProjection( matrix );

			};

		}(),

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			this.normalize();

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;
				this.z = 0;

			}

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			if ( this.z > v.z ) {

				this.z = v.z;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			if ( this.z < v.z ) {

				this.z = v.z;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			if ( this.z < min.z ) {

				this.z = min.z;

			} else if ( this.z > max.z ) {

				this.z = max.z;

			}

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector3();
					max = new THREE.Vector3();

				}

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength  ) {

				this.multiplyScalar( l / oldLength );

			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			var x = this.x, y = this.y, z = this.z;

			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;

			return this;

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function () {

			var v1, dot;

			return function projectOnVector( vector ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				v1.copy( vector ).normalize();

				dot = this.dot( v1 );

				return this.copy( v1 ).multiplyScalar( dot );

			};

		}(),

		projectOnPlane: function () {

			var v1;

			return function projectOnPlane( planeNormal ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			}

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1;

			return function reflect( normal ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			}

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( this.length() * v.length() );

			// clamp, to handle numerical problems

			return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		setEulerFromRotationMatrix: function ( m, order ) {

			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},

		setEulerFromQuaternion: function ( q, order ) {

			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},

		getPositionFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

			return this.setFromMatrixPosition( m );

		},

		getScaleFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

			return this.setFromMatrixScale( m );

		},

		getColumnFromMatrix: function ( index, matrix ) {

			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

			return this.setFromMatrixColumn( index, matrix );

		},

		setFromMatrixPosition: function ( m ) {

			this.x = m.elements[ 12 ];
			this.y = m.elements[ 13 ];
			this.z = m.elements[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
			var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
			var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( index, matrix ) {

			var offset = index * 4;

			var me = matrix.elements;

			this.x = me[ offset ];
			this.y = me[ offset + 1 ];
			this.z = me[ offset + 2 ];

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];

			return this;

		}

	};

	// File:src/math/Vector4.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector4 = function ( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	};

	THREE.Vector4.prototype = {

		constructor: THREE.Vector4,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;
			var w = this.w;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;
				this.w *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 1;

			}

			return this;

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				 this.x = 1;
				 this.y = 0;
				 this.z = 0;

			} else {

				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon )
			   && ( Math.abs( m13 - m31 ) < epsilon )
			   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 )
				   && ( Math.abs( m13 + m31 ) < epsilon2 )
				   && ( Math.abs( m23 + m32 ) < epsilon2 )
				   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
							  + ( m13 - m31 ) * ( m13 - m31 )
							  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			if ( this.z > v.z ) {

				this.z = v.z;

			}

			if ( this.w > v.w ) {

				this.w = v.w;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			if ( this.z < v.z ) {

				this.z = v.z;

			}

			if ( this.w < v.w ) {

				this.w = v.w;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			if ( this.z < min.z ) {

				this.z = min.z;

			} else if ( this.z > max.z ) {

				this.z = max.z;

			}

			if ( this.w < min.w ) {

				this.w = min.w;

			} else if ( this.w > max.w ) {

				this.w = max.w;

			}

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector4();
					max = new THREE.Vector4();

				}

				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength ) {

				this.multiplyScalar( l / oldLength );

			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
			this.w = attribute.array[ index + 3 ];

			return this;

		}

	};

	// File:src/math/Euler.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Euler = function ( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;

	};

	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	THREE.Euler.DefaultOrder = 'XYZ';

	THREE.Euler.prototype = {

		constructor: THREE.Euler,

		get x () {

			return this._x;

		},

		set x ( value ) {

			this._x = value;
			this.onChangeCallback();

		},

		get y () {

			return this._y;

		},

		set y ( value ) {

			this._y = value;
			this.onChangeCallback();

		},

		get z () {

			return this._z;

		},

		set z ( value ) {

			this._z = value;
			this.onChangeCallback();

		},

		get order () {

			return this._order;

		},

		set order ( value ) {

			this._order = value;
			this.onChangeCallback();

		},

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order);

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = THREE.Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.99999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.99999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

			}

			this._order = order;

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function () {

			var matrix;

			return function ( q, order, update ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();
				matrix.makeRotationFromQuaternion( q );
				this.setFromRotationMatrix( matrix, order, update );

				return this;

			};

		}(),

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new THREE.Quaternion();

			return function ( newOrder ) {

				q.setFromEuler( this );
				this.setFromQuaternion( q, newOrder );

			};

		}(),

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new THREE.Vector3( this._x, this._y, this._z );

			}

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	};

	// File:src/math/Line3.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Line3 = function ( start, end ) {

		this.start = ( start !== undefined ) ? start : new THREE.Vector3();
		this.end = ( end !== undefined ) ? end : new THREE.Vector3();

	};

	THREE.Line3.prototype = {

		constructor: THREE.Line3,

		set: function ( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		},

		delta: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.end, this.start );

		},

		distanceSq: function () {

			return this.start.distanceToSquared( this.end );

		},

		distance: function () {

			return this.start.distanceTo( this.end );

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		closestPointToPointParameter: function () {

			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();

			return function ( point, clampToLine ) {

				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );

				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = THREE.Math.clamp( t, 0, 1 );

				}

				return t;

			};

		}(),

		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

			var t = this.closestPointToPointParameter( point, clampToLine );

			var result = optionalTarget || new THREE.Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		applyMatrix4: function ( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		},

		equals: function ( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

	};

	// File:src/math/Box2.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Box2 = function ( min, max ) {

		this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

	};

	THREE.Box2.prototype = {

		constructor: THREE.Box2,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] )

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector2();

			return function ( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),
		
		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		empty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		size: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {

				return false;

			}

			return true;

		},

		containsBox: function ( box ) {

			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

				return true;

			}

			return false;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector2();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		},

		isIntersectionBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.

			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {

				return false;

			}

			return true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector2();

			return function ( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	};

	// File:src/math/Box3.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Box3 = function ( min, max ) {

		this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

	};

	THREE.Box3.prototype = {

		constructor: THREE.Box3,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector3();

			return function ( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		setFromObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			var v1 = new THREE.Vector3();

			return function ( object ) {

				var scope = this;

				object.updateMatrixWorld( true );

				this.makeEmpty();

				object.traverse( function ( node ) {

					var geometry = node.geometry;

					if ( geometry !== undefined ) {

						if ( geometry instanceof THREE.Geometry ) {

							var vertices = geometry.vertices;

							for ( var i = 0, il = vertices.length; i < il; i ++ ) {

								v1.copy( vertices[ i ] );

								v1.applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

							var positions = geometry.attributes[ 'position' ].array;

							for ( var i = 0, il = positions.length; i < il; i += 3 ) {

								v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

								v1.applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				} );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		empty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		size: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ||
			     point.z < this.min.z || point.z > this.max.z ) {

				return false;

			}

			return true;

		},

		containsBox: function ( box ) {

			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

				return true;

			}

			return false;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector3();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		isIntersectionBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.

			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ||
			     box.max.z < this.min.z || box.min.z > this.max.z ) {

				return false;

			}

			return true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector3();

			return function ( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new THREE.Vector3();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Sphere();

				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;

				return result;

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function () {

			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];

			return function ( matrix ) {

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

				this.makeEmpty();
				this.setFromPoints( points );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	};

	// File:src/math/Matrix3.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Matrix3 = function () {

		this.elements = new Float32Array( [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		] );

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix3.prototype = {

		constructor: THREE.Matrix3,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
			te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
			te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 3 ], me[ 6 ],
				me[ 1 ], me[ 4 ], me[ 7 ],
				me[ 2 ], me[ 5 ], me[ 8 ]

			);

			return this;

		},

		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},

		multiplyVector3Array: function ( a ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );

		},

		applyToVector3Array: function () {

			var v1;

			return function ( array, offset, length ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;

				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

					v1.fromArray( array, j );
					v1.applyMatrix3( this );
					v1.toArray( array, j );

				}

				return array;

			};

		}(),

		applyToBuffer: function () {

			var v1;

			return function applyToBuffer( buffer, offset, length ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;

				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );

					v1.applyMatrix3( this );

					buffer.setXYZ( v1.x, v1.y, v1.z );

				}

				return buffer;

			};

		}(),

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnInvertible ) {

			// input: THREE.Matrix4
			// ( based on http://code.google.com/p/webgl-mjs/ )

			var me = matrix.elements;
			var te = this.elements;

			te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
			te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
			te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
			te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
			te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
			te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
			te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
			te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
			te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

			// no inverse

			if ( det === 0 ) {

				var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

				if ( throwOnInvertible || false ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				this.identity();

				return this;

			}

			this.multiplyScalar( 1.0 / det );

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		flattenToArrayOffset: function ( array, offset ) {

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ]  = te[ 8 ];

			return array;

		},

		getNormalMatrix: function ( m ) {

			// input: THREE.Matrix4

			this.getInverse( m ).transpose();

			return this;

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		fromArray: function ( array ) {

			this.elements.set( array );

			return this;

		},

		toArray: function () {

			var te = this.elements;

			return [
				te[ 0 ], te[ 1 ], te[ 2 ],
				te[ 3 ], te[ 4 ], te[ 5 ],
				te[ 6 ], te[ 7 ], te[ 8 ]
			];

		}

	};

	// File:src/math/Matrix4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Matrix4 = function () {

		this.elements = new Float32Array( [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		] );

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix4.prototype = {

		constructor: THREE.Matrix4,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new THREE.Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			this.elements.set( m.elements );

			return this;

		},

		extractPosition: function ( m ) {

			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},

		copyPosition: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			var te = this.elements;

			xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
			yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
			zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0,       0,       0,       1
			);

			return this;

		},

		extractRotation: function () {

			var v1;

			return function ( m ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
				var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
				var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;

				return this;

			};

		}(),

		makeRotationFromEuler: function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		setRotationFromQuaternion: function ( q ) {

			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

			return this.makeRotationFromQuaternion( q );

		},

		makeRotationFromQuaternion: function ( q ) {

			var te = this.elements;

			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;

			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;

			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		lookAt: function () {

			var x, y, z;

			return function ( eye, target, up ) {

				if ( x === undefined ) x = new THREE.Vector3();
				if ( y === undefined ) y = new THREE.Vector3();
				if ( z === undefined ) z = new THREE.Vector3();

				var te = this.elements;

				z.subVectors( eye, target ).normalize();

				if ( z.length() === 0 ) {

					z.z = 1;

				}

				x.crossVectors( up, z ).normalize();

				if ( x.length() === 0 ) {

					z.x += 0.0001;
					x.crossVectors( up, z ).normalize();

				}

				y.crossVectors( z, x );


				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

				return this;

			};

		}(),

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyToArray: function ( a, b, r ) {

			var te = this.elements;

			this.multiplyMatrices( a, b );

			r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
			r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
			r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
			r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection( this );

		},

		multiplyVector4: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},

		multiplyVector3Array: function ( a ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );

		},

		applyToVector3Array: function () {

			var v1;

			return function ( array, offset, length ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;

				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

					v1.fromArray( array, j );
					v1.applyMatrix4( this );
					v1.toArray( array, j );

				}

				return array;

			};

		}(),

		applyToBuffer: function () {

			var v1;

			return function applyToBuffer( buffer, offset, length ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;

				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );

					v1.applyMatrix4( this );

					buffer.setXYZ( v1.x, v1.y, v1.z );

				}

				return buffer;

			};

		}(),

		rotateAxis: function ( v ) {

			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

			v.transformDirection( this );

		},

		crossVector: function ( vector ) {

			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		flattenToArrayOffset: function ( array, offset ) {

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ]  = te[ 8 ];
			array[ offset + 9 ]  = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		},

		getPosition: function () {

			var v1;

			return function () {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

				var te = this.elements;
				return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

			};

		}(),

		setPosition: function ( v ) {

			var te = this.elements;

			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;

			return this;

		},

		getInverse: function ( m, throwOnInvertible ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements;
			var me = m.elements;

			var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
			var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
			var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
			var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

			te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
			te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
			te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
			te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
			te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
			te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
			te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
			te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
			te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
			te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
			te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
			te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
			te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
			te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
			te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

			var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

			if ( det === 0 ) {

				var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

				if ( throwOnInvertible || false ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				this.identity();

				return this;

			}

			this.multiplyScalar( 1 / det );

			return this;

		},

		translate: function ( v ) {

			console.error( 'THREE.Matrix4: .translate() has been removed.' );

		},

		rotateX: function ( angle ) {

			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

		},

		rotateY: function ( angle ) {

			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

		},

		rotateZ: function ( angle ) {

			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},

		rotateByAxis: function ( axis, angle ) {

			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0,  0, 0,
				0, c, - s, 0,
				0, s,  c, 0,
				0, 0,  0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );

			return this;

		},

		decompose: function () {

			var vector, matrix;

			return function ( position, quaternion, scale ) {

				if ( vector === undefined ) vector = new THREE.Vector3();
				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				var te = this.elements;

				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) {

					sx = - sx;

				}

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part

				matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;

				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;

				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( matrix );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makeFrustum: function ( left, right, bottom, top, near, far ) {

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makePerspective: function ( fov, aspect, near, far ) {

			var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;

			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = right - left;
			var h = top - bottom;
			var p = far - near;

			var x = ( right + left ) / w;
			var y = ( top + bottom ) / h;
			var z = ( far + near ) / p;

			te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array ) {

			this.elements.set( array );

			return this;

		},

		toArray: function () {

			var te = this.elements;

			return [
				te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
				te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
				te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
				te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
			];

		}

	};

	// File:src/math/Ray.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Ray = function ( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

	};

	THREE.Ray.prototype = {

		constructor: THREE.Ray,

		set: function ( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		},

		recast: function () {

			var v1 = new THREE.Vector3();

			return function ( t ) {

				this.origin.copy( this.at( t, v1 ) );

				return this;

			};

		}(),

		closestPointToPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );

			if ( directionDistance < 0 ) {

				return result.copy( this.origin );

			}

			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		},

		distanceToPoint: function ( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		},

		distanceSqToPoint: function () {

			var v1 = new THREE.Vector3();

			return function ( point ) {

				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceToSquared( point );

				}

				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return v1.distanceToSquared( point );

			};

		}(),

		distanceSqToSegment: function () {

			var segCenter = new THREE.Vector3();
			var segDir = new THREE.Vector3();
			var diff = new THREE.Vector3();

			return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

				// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );

				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;

				if ( det > 0 ) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if ( s0 >= 0 ) {

						if ( s1 >= - extDet ) {

							if ( s1 <= extDet ) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						if ( s1 <= - extDet ) {

							// region 4

							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						} else if ( s1 <= extDet ) {

							// region 3

							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

						} else {

							// region 2

							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

				if ( optionalPointOnRay ) {

					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

				}

				if ( optionalPointOnSegment ) {

					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

				}

				return sqrDist;

			};

		}(),


		isIntersectionSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) <= sphere.radius;

		},

		intersectSphere: function () {

			// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

			var v1 = new THREE.Vector3();

			return function ( sphere, optionalTarget ) {

				v1.subVectors( sphere.center, this.origin );

				var tca = v1.dot( this.direction );

				var d2 = v1.dot( v1 ) - tca * tca;

				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) return null;

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );

				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, optionalTarget );

			}

		}(),

		isIntersectionPlane: function ( plane ) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			var denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		distanceToPlane: function ( plane ) {

			var denominator = plane.normal.dot( this.direction );
			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t :  null;

		},

		intersectPlane: function ( plane, optionalTarget ) {

			var t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, optionalTarget );

		},

		isIntersectionBox: function () {

			var v = new THREE.Vector3();

			return function ( box ) {

				return this.intersectBox( box, v ) !== null;

			};

		}(),

		intersectBox: function ( box, optionalTarget ) {

			// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

			var tmin, tmax, tymin, tymax, tzmin, tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

		},

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();

			return function ( a, b, c, backfaceCulling, optionalTarget ) {

				// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) return null;
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );

			};

		}(),

		applyMatrix4: function ( matrix4 ) {

			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
			this.direction.normalize();

			return this;

		},

		equals: function ( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

	};

	// File:src/math/Sphere.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Sphere = function ( center, radius ) {

		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	};

	THREE.Sphere.prototype = {

		constructor: THREE.Sphere,

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		},

		setFromPoints: function () {

			var box = new THREE.Box3();

			return function ( points, optionalCenter ) {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					box.setFromPoints( points ).center( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		clampPoint: function ( point, optionalTarget ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			var result = optionalTarget || new THREE.Vector3();
			result.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );

			}

			return result;

		},

		getBoundingBox: function ( optionalTarget ) {

			var box = optionalTarget || new THREE.Box3();

			box.set( this.center, this.center );
			box.expandByScalar( this.radius );

			return box;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

	};

	// File:src/math/Frustum.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()

		];

	};

	THREE.Frustum.prototype = {

		constructor: THREE.Frustum,

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new THREE.Sphere();

			return function ( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();

			return function ( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6 ; i ++ ) {

					var plane = planes[ i ];

					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );

					// if both outside plane, no intersection

					if ( d1 < 0 && d2 < 0 ) {

						return false;

					}

				}

				return true;

			};

		}(),


		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

	};

	// File:src/math/Plane.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Plane = function ( normal, constant ) {

		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	};

	THREE.Plane.prototype = {

		constructor: THREE.Plane,

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();

			return function ( a, b, c ) {

				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, optionalTarget ) {

			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

		},

		orthoPoint: function ( point, optionalTarget ) {

			var perpendicularMagnitude = this.distanceToPoint( point );

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

		},

		isIntersectionLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectLine: function () {

			var v1 = new THREE.Vector3();

			return function ( line, optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				var direction = line.delta( v1 );

				var denominator = this.normal.dot( direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {

						return result.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return result.copy( direction ).multiplyScalar( t ).add( line.start );

			};

		}(),


		coplanarPoint: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();

			return function ( matrix, optionalNormalMatrix ) {

				// compute new normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
				var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

				var newCoplanarPoint = this.coplanarPoint( v2 );
				newCoplanarPoint.applyMatrix4( matrix );

				this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.constant = this.constant - offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

	};

	// File:src/math/Math.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Math = {

		generateUUID: function () {

			// http://www.broofa.com/Tools/Math.uuid.htm

			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;

			return function () {

				for ( var i = 0; i < 36; i ++ ) {

					if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

						uuid[ i ] = '-';

					} else if ( i === 14 ) {

						uuid[ i ] = '4';

					} else {

						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

					}

				}

				return uuid.join( '' );

			};

		}(),

		// Clamp value to range <a, b>

		clamp: function ( x, a, b ) {

			return ( x < a ) ? a : ( ( x > b ) ? b : x );

		},

		// Clamp value to range <a, inf)

		clampBottom: function ( x, a ) {

			return x < a ? a : x;

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random float from <0, 1> with 16 bits of randomness
		// (standard Math.random() creates repetitive patterns when applied over larger space)

		random16: function () {

			return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function () {

			var degreeToRadiansFactor = Math.PI / 180;

			return function ( degrees ) {

				return degrees * degreeToRadiansFactor;

			};

		}(),

		radToDeg: function () {

			var radianToDegreesFactor = 180 / Math.PI;

			return function ( radians ) {

				return radians * radianToDegreesFactor;

			};

		}(),

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		nextPowerOfTwo: function ( value ) {

			value --;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value ++;

			return value;

		}

	};

	// File:src/math/Spline.js

	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Spline = function ( points ) {

		this.points = points;

		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;

		this.initFromArray = function ( a ) {

			this.points = [];

			for ( var i = 0; i < a.length; i ++ ) {

				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

			}

		};

		this.getPoint = function ( k ) {

			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];

			w2 = weight * weight;
			w3 = weight * w2;

			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

			return v3;

		};

		this.getControlPointsArray = function () {

			var i, p, l = this.points.length,
				coords = [];

			for ( i = 0; i < l; i ++ ) {

				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];

			}

			return coords;

		};

		// approximate length by summing linear segments

		this.getLength = function ( nSubDivisions ) {

			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;

			// first point has 0 length

			chunkLengths[ 0 ] = 0;

			if ( ! nSubDivisions ) nSubDivisions = 100;

			nSamples = this.points.length * nSubDivisions;

			oldPosition.copy( this.points[ 0 ] );

			for ( i = 1; i < nSamples; i ++ ) {

				index = i / nSamples;

				position = this.getPoint( index );
				tmpVec.copy( position );

				totalLength += tmpVec.distanceTo( oldPosition );

				oldPosition.copy( position );

				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );

				if ( intPoint !== oldIntPoint ) {

					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;

				}

			}

			// last point ends with total length

			chunkLengths[ chunkLengths.length ] = totalLength;

			return { chunks: chunkLengths, total: totalLength };

		};

		this.reparametrizeByArcLength = function ( samplingCoef ) {

			var i, j,
				index, indexCurrent, indexNext,
				realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();

			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

			for ( i = 1; i < this.points.length; i ++ ) {

				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );

				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

				sampling = Math.ceil( samplingCoef * realDistance / sl.total );

				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );

				for ( j = 1; j < sampling - 1; j ++ ) {

					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );

				}

				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

			}

			this.points = newpoints;

		};

		// Catmull-Rom

		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;

			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	};

	// File:src/math/Triangle.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Triangle = function ( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();

	};

	THREE.Triangle.normal = function () {

		var v0 = new THREE.Vector3();

		return function ( a, b, c, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );

			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {

				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

			}

			return result.set( 0, 0, 0 );

		};

	}();

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( point, a, b, c, optionalTarget ) {

			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );

			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );

			var denom = ( dot00 * dot11 - dot01 * dot01 );

			var result = optionalTarget || new THREE.Vector3();

			// collinear or singular triangle
			if ( denom === 0 ) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( - 2, - 1, - 1 );

			}

			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return result.set( 1 - u - v, v, u );

		};

	}();

	THREE.Triangle.containsPoint = function () {

		var v1 = new THREE.Vector3();

		return function ( point, a, b, c ) {

			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

		};

	}();

	THREE.Triangle.prototype = {

		constructor: THREE.Triangle,

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		area: function () {

			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();

			return function () {

				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );

				return v0.cross( v1 ).length() * 0.5;

			};

		}(),

		midpoint: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		normal: function ( optionalTarget ) {

			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

		},

		plane: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Plane();

			return result.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		barycoordFromPoint: function ( point, optionalTarget ) {

			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

		},

		containsPoint: function ( point ) {

			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	};

	// File:src/core/Clock.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Clock = function ( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	};

	THREE.Clock.prototype = {

		constructor: THREE.Clock,

		start: function () {

			this.startTime = self.performance !== undefined && self.performance.now !== undefined
						 ? self.performance.now()
						 : Date.now();

			this.oldTime = this.startTime;
			this.running = true;

		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();

			}

			if ( this.running ) {

				var newTime = self.performance !== undefined && self.performance.now !== undefined
						 ? self.performance.now()
						 : Date.now();

				diff = 0.001 * ( newTime - this.oldTime );
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	};

	// File:src/core/EventDispatcher.js

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	THREE.EventDispatcher = function () {};

	THREE.EventDispatcher.prototype = {

		constructor: THREE.EventDispatcher,

		apply: function ( object ) {

			object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
			object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
			object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
			object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

		},

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

				return true;

			}

			return false;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = [];
				var length = listenerArray.length;

				for ( var i = 0; i < length; i ++ ) {

					array[ i ] = listenerArray[ i ];

				}

				for ( var i = 0; i < length; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	};

	// File:src/core/Raycaster.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://exocortex.com/
	 * @author stephomi / http://stephaneginier.com/
	 */

	( function ( THREE ) {

		THREE.Raycaster = function ( origin, direction, near, far ) {

			this.ray = new THREE.Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near || 0;
			this.far = far || Infinity;

			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};

			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );

		};

		function descSort( a, b ) {

			return a.distance - b.distance;

		}

		var intersectObject = function ( object, raycaster, intersects, recursive ) {

			if ( object.visible === false ) return;

			object.raycast( raycaster, intersects );

			if ( recursive === true ) {

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					intersectObject( children[ i ], raycaster, intersects, true );

				}

			}

		};

		//

		THREE.Raycaster.prototype = {

			constructor: THREE.Raycaster,

			linePrecision: 1,

			set: function ( origin, direction ) {

				// direction is assumed to be normalized (for accurate distance calculations)

				this.ray.set( origin, direction );

			},

			setFromCamera: function ( coords, camera ) {

				if ( camera instanceof THREE.PerspectiveCamera ) {

					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

				} else if ( camera instanceof THREE.OrthographicCamera ) {

					this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

				} else {

					console.error( 'THREE.Raycaster: Unsupported camera type.' );

				}

			},

			intersectObject: function ( object, recursive ) {

				var intersects = [];

				intersectObject( object, this, intersects, recursive );

				intersects.sort( descSort );

				return intersects;

			},

			intersectObjects: function ( objects, recursive ) {

				var intersects = [];

				if ( Array.isArray( objects ) === false ) {

					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;

				}

				for ( var i = 0, l = objects.length; i < l; i ++ ) {

					intersectObject( objects[ i ], this, intersects, recursive );

				}

				intersects.sort( descSort );

				return intersects;

			}

		};

	}( THREE ) );

	// File:src/core/Object3D.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */

	THREE.Object3D = function () {

		Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = THREE.Object3D.DefaultUp.clone();

		var position = new THREE.Vector3();
		var rotation = new THREE.Euler();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3( 1, 1, 1 );

		var onRotationChange = function () {

			quaternion.setFromEuler( rotation, false );

		};

		var onQuaternionChange = function () {

			rotation.setFromQuaternion( quaternion, undefined, false );

		};

		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new THREE.Matrix4()
			},
			normalMatrix: {
				value: new THREE.Matrix3()
			}
		} );

		this.rotationAutoUpdate = true;

		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();

		this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	};

	THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
	THREE.Object3D.DefaultMatrixAutoUpdate = true;

	THREE.Object3D.prototype = {

		constructor: THREE.Object3D,

		get eulerOrder () {

			console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

			return this.rotation.order;

		},

		set eulerOrder ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

			this.rotation.order = value;

		},

		get useQuaternion () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},

		set useQuaternion ( value ) {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},

		set renderDepth ( value ) {

			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

		},

		applyMatrix: function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new THREE.Quaternion();

			return function ( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( q1 );

				return this;

			};

		}(),

		rotateX: function () {

			var v1 = new THREE.Vector3( 1, 0, 0 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateY: function () {

			var v1 = new THREE.Vector3( 0, 1, 0 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateZ: function () {

			var v1 = new THREE.Vector3( 0, 0, 1 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new THREE.Vector3();

			return function ( axis, distance ) {

				v1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( v1.multiplyScalar( distance ) );

				return this;

			};

		}(),

		translate: function ( distance, axis ) {

			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		},

		translateX: function () {

			var v1 = new THREE.Vector3( 1, 0, 0 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateY: function () {

			var v1 = new THREE.Vector3( 0, 1, 0 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateZ: function () {

			var v1 = new THREE.Vector3( 0, 0, 1 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function () {

			var m1 = new THREE.Matrix4();

			return function ( vector ) {

				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

			};

		}(),

		lookAt: function () {

			// This routine does not support objects with rotated and/or translated parent(s)

			var m1 = new THREE.Matrix4();

			return function ( vector ) {

				m1.lookAt( vector, this.position, this.up );

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}(),

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if ( object instanceof THREE.Object3D ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				object.dispatchEvent( { type: 'added' } );

				this.children.push( object );

			} else {

				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

			}

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;

				object.dispatchEvent( { type: 'removed' } );

				this.children.splice( index, 1 );

			}

		},

		getChildByName: function ( name ) {

			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			return result.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function () {

			var position = new THREE.Vector3();
			var scale = new THREE.Vector3();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Quaternion();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, result, scale );

				return result;

			};

		}(),

		getWorldRotation: function () {

			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Euler();

				this.getWorldQuaternion( quaternion );

				return result.setFromQuaternion( quaternion, this.rotation.order, false );

			};

		}(),

		getWorldScale: function () {

			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, quaternion, result );

				return result;

			};

		}(),

		getWorldDirection: function () {

			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

			};

		}(),

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			var parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate === true ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate === true || force === true ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].updateMatrixWorld( force );

			}

		},

		toJSON: function ( meta ) {

			var isRootObject = ( meta === undefined );

			var data = {};
			var output = { object: data };

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {}
				};

				output.metadata = {
					version: 4.4,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;
			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;
			if ( this.visible !== true ) data.visible = this.visible;

			data.matrix = this.matrix.toArray();

			if ( this.children.length > 0 ) {

				data.children = [];

				for ( var i = 0; i < this.children.length; i ++ ) {

					data.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			if ( isRootObject ) {

				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;

			}

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache ( cache ) {

				var values = [];
				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}
				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive ) {

			if ( recursive === undefined ) recursive = true;

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.rotationAutoUpdate = source.rotationAutoUpdate;

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < source.children.length; i ++ ) {

					var child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

	THREE.Object3DIdCount = 0;

	// File:src/core/Face3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];

		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = Array.isArray( color ) ? color : [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	};

	THREE.Face3.prototype = {

		constructor: THREE.Face3,

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy( source.normal );
			this.color.copy( source.color );

			this.materialIndex = source.materialIndex;

			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

				this.vertexColors[ i ] = source.vertexColors[ i ].clone();

			}

			return this;

		}

	};

	// File:src/core/Face4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new THREE.Face3( a, b, c, normal, color, materialIndex );

	};

	// File:src/core/BufferAttribute.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferAttribute = function ( array, itemSize ) {

		this.uuid = THREE.Math.generateUUID();

		this.array = array;
		this.itemSize = itemSize;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	};

	THREE.BufferAttribute.prototype = {

		constructor: THREE.BufferAttribute,

		get length() {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;

		},

		get count() {

			return this.array.length / this.itemSize;

		},

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;

			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = colors.length; i < l; i ++ ) {

				var color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new THREE.Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyIndicesArray: function ( indices ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				var index = indices[ i ];

				array[ offset ++ ] = index.a;
				array[ offset ++ ] = index.b;
				array[ offset ++ ] = index.c;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new THREE.Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new THREE.Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new THREE.Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	};

	//

	THREE.Int8Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

	};

	THREE.Uint8Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

	};

	THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

	};

	THREE.Int16Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

	};

	THREE.Uint16Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

	};

	THREE.Int32Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

	};

	THREE.Uint32Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

	};

	THREE.Float32Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

	};

	THREE.Float64Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

	};


	// Deprecated

	THREE.DynamicBufferAttribute = function ( array, itemSize ) {

		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

	};

	// File:src/core/InstancedBufferAttribute.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {

		THREE.BufferAttribute.call( this, array, itemSize );

		this.meshPerAttribute = meshPerAttribute || 1;

	};

	THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
	THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

	THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {

		THREE.BufferAttribute.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	};

	// File:src/core/InterleavedBuffer.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InterleavedBuffer = function ( array, stride ) {

		this.uuid = THREE.Math.generateUUID();

		this.array = array;
		this.stride = stride;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	};

	THREE.InterleavedBuffer.prototype = {

		constructor: THREE.InterleavedBuffer,

		get length () {

			return this.array.length;

		},

		get count () {

			return this.array.length / this.stride;

		},

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.stride = source.stride;
			this.dynamic = source.dynamic;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( var i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	};

	// File:src/core/InstancedInterleavedBuffer.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {

		THREE.InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	};

	THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
	THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

	THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {

		THREE.InterleavedBuffer.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	};

	// File:src/core/InterleavedBufferAttribute.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

		this.uuid = THREE.Math.generateUUID();

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

	};


	THREE.InterleavedBufferAttribute.prototype = {

		constructor: THREE.InterleavedBufferAttribute,

		get length() {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;

		},

		get count() {

			return this.data.array.length / this.data.stride;

		},

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

	};

	// File:src/core/Geometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Geometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];

		this.morphTargets = [];
		this.morphColors = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;

	};

	THREE.Geometry.prototype = {

		constructor: THREE.Geometry,

		applyMatrix: function ( matrix ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1;

			return function rotateX( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1;

			return function rotateY( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1;

			return function rotateZ( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1;

			return function translate( x, y, z ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1;

			return function scale( x, y, z ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj;

			return function lookAt( vector ) {

				if ( obj === undefined ) obj = new THREE.Object3D();

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;

			var vertices = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];

			for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {

				scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

				if ( normals !== undefined ) {

					tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

				}

				if ( colors !== undefined ) {

					scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

				}

				if ( uvs !== undefined ) {

					tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

				}

				if ( uvs2 !== undefined ) {

					tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

				}

			}

			var addFace = function ( a, b, c ) {

				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

				var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

				scope.faces.push( face );

				if ( uvs !== undefined ) {

					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

				}

				if ( uvs2 !== undefined ) {

					scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

				}

			};

			if ( indices !== undefined ) {

				var groups = geometry.groups;

				if ( groups.length > 0 ) {

					for ( var i = 0; i < groups.length; i ++ ) {

						var group = groups[ i ];

						var start = group.start;
						var count = group.count;

						for ( var j = start, jl = start + count; j < jl; j += 3 ) {

							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

						}

					}

				} else {

					for ( var i = 0; i < indices.length; i += 3 ) {

						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

					}

				}

			} else {

				for ( var i = 0; i < vertices.length / 3; i += 3 ) {

					addFace( i, i + 1, i + 2 );

				}

			}

			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.center().negate();

			this.translate( offset.x, offset.y, offset.z );

			return offset;

		},

		normalize: function () {

			this.computeBoundingSphere();

			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;

			var s = radius === 0 ? 1 : 1.0 / radius;

			var matrix = new THREE.Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);

			this.applyMatrix( matrix );

			return this;

		},

		computeFaceNormals: function () {

			var cb = new THREE.Vector3(), ab = new THREE.Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new THREE.Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );

				} else {

					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();

				}

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeTangents: function () {

			console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

		},

		computeLineDistances: function () {

			var d = 0;
			var vertices = this.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				if ( i > 0 ) {

					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

				}

				this.lineDistances[ i ] = d;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( geometry instanceof THREE.Geometry === false ) {

				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ];

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;

				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

				var uv = uvs2[ i ], uvCopy = [];

				if ( uv === undefined ) {

					continue;

				}

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( uv[ j ].clone() );

				}

				uvs1.push( uvCopy );

			}

		},

		mergeMesh: function ( mesh ) {

			if ( mesh instanceof THREE.Mesh === false ) {

				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			mesh.matrixAutoUpdate && mesh.updateMatrix();

			this.merge( mesh.geometry, mesh.matrix );

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			}


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				var dupIndex = - 1;

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {

					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;

					}

				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.4,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};

			// standard Geometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = false; // face.materialIndex !== undefined;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 );
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			data.data = {};

			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.vertices = [];
			this.faces = [];
			this.faceVertexUvs = [ [] ];

			var vertices = source.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				this.vertices.push( vertices[ i ].clone() );

			}

			var faces = source.faces;

			for ( var i = 0, il = faces.length; i < il; i ++ ) {

				this.faces.push( faces[ i ].clone() );

			}

			for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs = source.faceVertexUvs[ i ];

				if ( this.faceVertexUvs[ i ] === undefined ) {

					this.faceVertexUvs[ i ] = [];

				}

				for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

					var uvs = faceVertexUvs[ j ], uvsCopy = [];

					for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

						var uv = uvs[ k ];

						uvsCopy.push( uv.clone() );

					}

					this.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

	THREE.GeometryIdCount = 0;

	// File:src/core/DirectGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.DirectGeometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'DirectGeometry';

		this.indices = [];
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];

		this.groups = [];

		this.morphTargets = {};

		this.skinWeights = [];
		this.skinIndices = [];

		// this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;

	};

	THREE.DirectGeometry.prototype = {

		constructor: THREE.DirectGeometry,

		computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
		computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

		computeFaceNormals: function () {

			console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

		},

		computeVertexNormals: function () {

			console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

		},

		computeGroups: function ( geometry ) {

			var group;
			var groups = [];
			var materialIndex;

			var faces = geometry.faces;

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				// materials

				if ( face.materialIndex !== materialIndex ) {

					materialIndex = face.materialIndex;

					if ( group !== undefined ) {

						group.count = ( i * 3 ) - group.start;
						groups.push( group );

					}

					group = {
						start: i * 3,
						materialIndex: materialIndex
					};

				}

			}

			if ( group !== undefined ) {

				group.count = ( i * 3 ) - group.start;
				groups.push( group );

			}

			this.groups = groups;

		},

		fromGeometry: function ( geometry ) {

			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;

			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

			// morphs

			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;

			if ( morphTargetsLength > 0 ) {

				var morphTargetsPosition = [];

				for ( var i = 0; i < morphTargetsLength; i ++ ) {

					morphTargetsPosition[ i ] = [];

				}

				this.morphTargets.position = morphTargetsPosition;

			}

			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;

			if ( morphNormalsLength > 0 ) {

				var morphTargetsNormal = [];

				for ( var i = 0; i < morphNormalsLength; i ++ ) {

					morphTargetsNormal[ i ] = [];

				}

				this.morphTargets.normal = morphTargetsNormal;

			}

			// skins

			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;

			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;

			//

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

				} else {

					var normal = face.normal;

					this.normals.push( normal, normal, normal );

				}

				var vertexColors = face.vertexColors;

				if ( vertexColors.length === 3 ) {

					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

				} else {

					var color = face.color;

					this.colors.push( color, color, color );

				}

				if ( hasFaceVertexUv === true ) {

					var vertexUvs = faceVertexUvs[ 0 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

						this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

					}

				}

				if ( hasFaceVertexUv2 === true ) {

					var vertexUvs = faceVertexUvs[ 1 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

						this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

					}

				}

				// morphs

				for ( var j = 0; j < morphTargetsLength; j ++ ) {

					var morphTarget = morphTargets[ j ].vertices;

					morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

				}

				for ( var j = 0; j < morphNormalsLength; j ++ ) {

					var morphNormal = morphNormals[ j ].vertexNormals[ i ];

					morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

				}

				// skins

				if ( hasSkinIndices ) {

					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

				}

				if ( hasSkinWeights ) {

					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

				}

			}

			this.computeGroups( geometry );

			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

	// File:src/core/BufferGeometry.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

	};

	THREE.BufferGeometry.prototype = {

		constructor: THREE.BufferGeometry,

		addIndex: function ( index ) {

			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );

		},

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			this.index = index;

		},

		addAttribute: function ( name, attribute ) {

			if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

				return;

			}

			if ( name === 'index' ) {

				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );

				return;

			}

			this.attributes[ name ] = attribute;

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		removeAttribute: function ( name ) {

			delete this.attributes[ name ];

		},

		get drawcalls() {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		},

		get offsets() {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		},

		addDrawCall: function ( start, count, indexOffset ) {

			if ( indexOffset !== undefined ) {

				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

			}

			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );

		},

		clearDrawCalls: function () {

			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();

		},

		addGroup: function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				matrix.applyToVector3Array( position.array );
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

				normalMatrix.applyToVector3Array( normal.array );
				normal.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1;

			return function rotateX( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1;

			return function rotateY( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1;

			return function rotateZ( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1;

			return function translate( x, y, z ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1;

			return function scale( x, y, z ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj;

			return function lookAt( vector ) {

				if ( obj === undefined ) obj = new THREE.Object3D();

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.center().negate();

			this.translate( offset.x, offset.y, offset.z );

			return offset;

		},

		setFromObject: function ( object ) {

			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			var geometry = object.geometry;

			if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

				var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
				var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

					var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

					this.addAttribute( 'lineDistance',  lineDistances.copyArray( geometry.lineDistances ) );

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

			} else if ( object instanceof THREE.Mesh ) {

				if ( geometry instanceof THREE.Geometry ) {

					this.fromGeometry( geometry );

				}

			}

			return this;

		},

		updateFromObject: function ( object ) {

			var geometry = object.geometry;

			if ( object instanceof THREE.Mesh ) {

				var direct = geometry.__directGeometry;

				if ( direct === undefined ) {

					return this.fromGeometry( geometry );

				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;

			}

			if ( geometry.verticesNeedUpdate === true ) {

				var attribute = this.attributes.position;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;

				}

				geometry.verticesNeedUpdate = false;

			}

			if ( geometry.normalsNeedUpdate === true ) {

				var attribute = this.attributes.normal;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;

				}

				geometry.normalsNeedUpdate = false;

			}

			if ( geometry.colorsNeedUpdate === true ) {

				var attribute = this.attributes.color;

				if ( attribute !== undefined ) {

					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;

				}

				geometry.colorsNeedUpdate = false;

			}

			if ( geometry.lineDistancesNeedUpdate ) {

				var attribute = this.attributes.lineDistance;

				if ( attribute !== undefined ) {

					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;

				}

				geometry.lineDistancesNeedUpdate = false;

			}

			if ( geometry.groupsNeedUpdate ) {

				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;

			}

			return this;

		},

		fromGeometry: function ( geometry ) {

			geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

			return this.fromDirectGeometry( geometry.__directGeometry );

		},

		fromDirectGeometry: function ( geometry ) {

			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

			if ( geometry.normals.length > 0 ) {

				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

			}

			if ( geometry.colors.length > 0 ) {

				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

			}

			if ( geometry.uvs.length > 0 ) {

				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

			}

			if ( geometry.uvs2.length > 0 ) {

				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

			}

			if ( geometry.indices.length > 0 ) {

				var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
				var indices = new TypeArray( geometry.indices.length * 3 );
				this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for ( var name in geometry.morphTargets ) {

				var array = [];
				var morphTargets = geometry.morphTargets[ name ];

				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

					var morphTarget = morphTargets[ i ];

					var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

					array.push( attribute.copyVector3sArray( morphTarget ) );

				}

				this.morphAttributes[ name ] = array;

			}

			// skinning

			if ( geometry.skinIndices.length > 0 ) {

				var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

			}

			if ( geometry.skinWeights.length > 0 ) {

				var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

			}

			//

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		},

		computeBoundingBox: function () {

			var vector = new THREE.Vector3();

			return function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new THREE.Box3();

				}

				var positions = this.attributes.position.array;

				if ( positions ) {

					var bb = this.boundingBox;
					bb.makeEmpty();

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.fromArray( positions, i );
						bb.expandByPoint( vector );

					}

				}

				if ( positions === undefined || positions.length === 0 ) {

					this.boundingBox.min.set( 0, 0, 0 );
					this.boundingBox.max.set( 0, 0, 0 );

				}

				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

				}

			};

		}(),

		computeBoundingSphere: function () {

			var box = new THREE.Box3();
			var vector = new THREE.Vector3();

			return function () {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new THREE.Sphere();

				}

				var positions = this.attributes.position.array;

				if ( positions ) {

					box.makeEmpty();

					var center = this.boundingSphere.center;

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.fromArray( positions, i );
						box.expandByPoint( vector );

					}

					box.center( center );

					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.fromArray( positions, i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

					}

				}

			};

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var index = this.index;
			var attributes = this.attributes;
			var groups = this.groups;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var normals = attributes.normal.array;

					for ( var i = 0, il = normals.length; i < il; i ++ ) {

						normals[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC,

				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),

				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();

				// indexed elements

				if ( index ) {

					var indices = index.array;

					if ( groups.length === 0 ) {

						this.addGroup( 0, indices.length );

					}

					for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

						var group = groups[ j ];

						var start = group.start;
						var count = group.count;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							vA = indices[ i + 0 ] * 3;
							vB = indices[ i + 1 ] * 3;
							vC = indices[ i + 2 ] * 3;

							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ vA ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;

							normals[ vB ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;

							normals[ vC ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;

						}

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		computeTangents: function () {

			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

		},

		computeOffsets: function ( size ) {

			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.')

		},

		merge: function ( geometry, offset ) {

			if ( geometry instanceof THREE.BufferGeometry === false ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) offset = 0;

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeSize = attribute2.itemSize;

				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var normals = this.attributes.normal.array;

			var x, y, z, n;

			for ( var i = 0, il = normals.length; i < il; i += 3 ) {

				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];

				n = 1.0 / Math.sqrt( x * x + y * y + z * z );

				normals[ i ] *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;

			}

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.4,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			data.data = { attributes: {} };

			var index = this.index;

			if ( index !== null ) {

				var array = Array.prototype.slice.call( index.array );

				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var array = Array.prototype.slice.call( attribute.array );

				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array
				};

			}

			var groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			var boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			var attributes = source.attributes;

			for ( var name in attributes ) {

				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );

			}

			var groups = source.groups;

			for ( var i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count );

			}

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

	THREE.BufferGeometry.MaxIndex = 65535;

	// File:src/core/InstancedBufferGeometry.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InstancedBufferGeometry = function () {

		THREE.BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;

	};

	THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

	THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

		this.groups.push( {

			start: start,
			count: count,
			instances: instances

		} );

	};

	THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		var attributes = source.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		var groups = source.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.instances );

		}

		return this;

	};

	THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

	// File:src/cameras/Camera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.Camera = function () {

		THREE.Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();

	};

	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Camera.prototype.constructor = THREE.Camera;

	THREE.Camera.prototype.getWorldDirection = function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

		};

	}();

	THREE.Camera.prototype.lookAt = function () {

		// This routine does not support cameras with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( this.position, vector, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}();

	THREE.Camera.prototype.clone = function () {

		return new this.constructor().copy( this );

	};

	THREE.Camera.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );
		this.projectionMatrix.copy( source.projectionMatrix );

		return this;

	};

	// File:src/cameras/CubeCamera.js

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CubeCamera = function ( near, far, cubeResolution ) {

		THREE.Object3D.call( this );

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

		this.updateCubeMap = function ( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.generateMipmaps;

			renderTarget.generateMipmaps = false;

			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );

			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );

			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );

			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );

			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );

			renderTarget.generateMipmaps = generateMipmaps;

			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );

			renderer.setRenderTarget( null );

		};

	};

	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

	// File:src/cameras/OrthographicCamera.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

		THREE.Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

	THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

	};

	THREE.OrthographicCamera.prototype.copy = function ( source ) {
		
		THREE.Camera.prototype.copy.call( this, source );
		
		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;
		
		this.zoom = source.zoom;
		
		return this;
			
	};

	THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		return data;

	};

	// File:src/cameras/PerspectiveCamera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

		THREE.Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.zoom = 1;

		this.fov = fov !== undefined ? fov : 50;
		this.aspect = aspect !== undefined ? aspect : 1;
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


	/**
	 * Uses Focal Length (in mm) to estimate and set FOV
	 * 35mm (full-frame) camera is used if frame size is not specified;
	 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	 */

	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

		if ( frameHeight === undefined ) frameHeight = 24;

		this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
		this.updateProjectionMatrix();

	};


	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */

	THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

		this.fullWidth = fullWidth;
		this.fullHeight = fullHeight;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;

		this.updateProjectionMatrix();

	};


	THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

		var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

		if ( this.fullWidth ) {

			var aspect = this.fullWidth / this.fullHeight;
			var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
			var bottom = - top;
			var left = aspect * bottom;
			var right = aspect * top;
			var width = Math.abs( right - left );
			var height = Math.abs( top - bottom );

			this.projectionMatrix.makeFrustum(
				left + this.x * width / this.fullWidth,
				left + ( this.x + this.width ) * width / this.fullWidth,
				top - ( this.y + this.height ) * height / this.fullHeight,
				top - this.y * height / this.fullHeight,
				this.near,
				this.far
			);

		} else {

			this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

		}

	};

	THREE.PerspectiveCamera.prototype.copy = function ( source ) {
		
		THREE.Camera.prototype.copy.call( this, source );
		
		this.fov = source.fov;
		this.aspect = source.aspect;
		this.near = source.near;
		this.far = source.far;
		
		this.zoom = source.zoom;
		
		return this;
			
	};

	THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.fov = this.fov;
		data.object.aspect = this.aspect;
		data.object.near = this.near;
		data.object.far = this.far;

		return data;

	};

	// File:src/lights/Light.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Light = function ( color ) {

		THREE.Object3D.call( this );

		this.type = 'Light';

		this.color = new THREE.Color( color );

	};

	THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Light.prototype.constructor = THREE.Light;

	THREE.Light.prototype.copy = function ( source ) {
		
		THREE.Object3D.prototype.copy.call( this, source );
		
		this.color.copy( source.color );
		
		return this;

	};
	// File:src/lights/AmbientLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AmbientLight = function ( color ) {

		THREE.Light.call( this, color );

		this.type = 'AmbientLight';

	};

	THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
	THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

	THREE.AmbientLight.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();

		return data;

	};

	// File:src/lights/DirectionalLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DirectionalLight = function ( color, intensity ) {

		THREE.Light.call( this, color );

		this.type = 'DirectionalLight';

		this.position.set( 0, 1, 0 );
		this.updateMatrix();

		this.target = new THREE.Object3D();

		this.intensity = ( intensity !== undefined ) ? intensity : 1;

		this.castShadow = false;
		this.onlyShadow = false;

		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;

		this.shadowCameraLeft = - 500;
		this.shadowCameraRight = 500;
		this.shadowCameraTop = 500;
		this.shadowCameraBottom = - 500;

		this.shadowCameraVisible = false;

		this.shadowBias = 0;
		this.shadowDarkness = 0.5;

		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;

		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;

	};

	THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
	THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

	THREE.DirectionalLight.prototype.copy = function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.intensity = source.intensity;
		this.target = source.target.clone();

		this.castShadow = source.castShadow;
		this.onlyShadow = source.onlyShadow;

		this.shadowCameraNear = source.shadowCameraNear;
		this.shadowCameraFar = source.shadowCameraFar;

		this.shadowCameraLeft = source.shadowCameraLeft;
		this.shadowCameraRight = source.shadowCameraRight;
		this.shadowCameraTop = source.shadowCameraTop;
		this.shadowCameraBottom = source.shadowCameraBottom;

		this.shadowCameraVisible = source.shadowCameraVisible;

		this.shadowBias = source.shadowBias;
		this.shadowDarkness = source.shadowDarkness;

		this.shadowMapWidth = source.shadowMapWidth;
		this.shadowMapHeight = source.shadowMapHeight;

		return this;

	};

	THREE.DirectionalLight.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		return data;

	};

	// File:src/lights/HemisphereLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

		THREE.Light.call( this, skyColor );

		this.type = 'HemisphereLight';

		this.position.set( 0, 1, 0 );
		this.updateMatrix();

		this.groundColor = new THREE.Color( groundColor );
		this.intensity = ( intensity !== undefined ) ? intensity : 1;

	};

	THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
	THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

	THREE.HemisphereLight.prototype.copy = function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );
		this.intensity = source.intensity;

		return this;

	};

	THREE.HemisphereLight.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.groundColor = this.groundColor.getHex();
		data.object.intensity = this.intensity;

		return data;

	};

	// File:src/lights/PointLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PointLight = function ( color, intensity, distance, decay ) {

		THREE.Light.call( this, color );

		this.type = 'PointLight';

		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	};

	THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
	THREE.PointLight.prototype.constructor = THREE.PointLight;

	THREE.PointLight.prototype.copy = function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.intensity = source.intensity;
		this.distance = source.distance;
		this.decay = source.decay;

		return this;

	};

	THREE.PointLight.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;
		data.object.distance = this.distance;
		data.object.decay = this.decay;

		return data;

	};

	// File:src/lights/SpotLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

		THREE.Light.call( this, color );

		this.type = 'SpotLight';

		this.position.set( 0, 1, 0 );
		this.updateMatrix();

		this.target = new THREE.Object3D();

		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.exponent = ( exponent !== undefined ) ? exponent : 10;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.castShadow = false;
		this.onlyShadow = false;

		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;
		this.shadowCameraFov = 50;

		this.shadowCameraVisible = false;

		this.shadowBias = 0;
		this.shadowDarkness = 0.5;

		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;

		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;

	};

	THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
	THREE.SpotLight.prototype.constructor = THREE.SpotLight;

	THREE.SpotLight.prototype.copy = function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.intensity = source.intensity;
		this.distance = source.distance;
		this.angle = source.angle;
		this.exponent = source.exponent;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.castShadow = source.castShadow;
		this.onlyShadow = source.onlyShadow;

		this.shadowCameraNear = source.shadowCameraNear;
		this.shadowCameraFar = source.shadowCameraFar;
		this.shadowCameraFov = source.shadowCameraFov;

		this.shadowCameraVisible = source.shadowCameraVisible;

		this.shadowBias = source.shadowBias;
		this.shadowDarkness = source.shadowDarkness;

		this.shadowMapWidth = source.shadowMapWidth;
		this.shadowMapHeight = source.shadowMapHeight;

		return this;
	}

	THREE.SpotLight.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;
		data.object.distance = this.distance;
		data.object.angle = this.angle;
		data.object.exponent = this.exponent;
		data.object.decay = this.decay;

		return data;

	};

	// File:src/loaders/Cache.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	// File:src/loaders/Loader.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Loader = function () {

		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};

	};

	THREE.Loader.prototype = {

		constructor: THREE.Loader,

		crossOrigin: undefined,

		extractUrlBase: function ( url ) {

			var parts = url.split( '/' );

			if ( parts.length === 1 ) return './';

			parts.pop();

			return parts.join( '/' ) + '/';

		},

		initMaterials: function ( materials, texturePath, crossOrigin ) {

			var array = [];

			for ( var i = 0; i < materials.length; ++ i ) {

				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

			}

			return array;

		},

		createMaterial: ( function () {

			var imageLoader;

			return function createMaterial( m, texturePath, crossOrigin ) {

				var scope = this;

				if ( crossOrigin === undefined && scope.crossOrigin !== undefined ) crossOrigin = scope.crossOrigin;

				if ( imageLoader === undefined ) imageLoader = new THREE.ImageLoader();

				function nearest_pow2( n ) {

					var l = Math.log( n ) / Math.LN2;
					return Math.pow( 2, Math.round(  l ) );

				}

				function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

					var fullPath = texturePath + sourceFile;

					var texture;

					var loader = THREE.Loader.Handlers.get( fullPath );

					if ( loader !== null ) {

						texture = loader.load( fullPath );

					} else {

						texture = new THREE.Texture();

						loader = imageLoader;
						loader.setCrossOrigin( crossOrigin );
						loader.load( fullPath, function ( image ) {

							if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
								THREE.Math.isPowerOfTwo( image.height ) === false ) {

								var width = nearest_pow2( image.width );
								var height = nearest_pow2( image.height );

								var canvas = document.createElement( 'canvas' );
								canvas.width = width;
								canvas.height = height;

								var context = canvas.getContext( '2d' );
								context.drawImage( image, 0, 0, width, height );

								texture.image = canvas;

							} else {

								texture.image = image;

							}

							texture.needsUpdate = true;

						} );

					}

					texture.sourceFile = sourceFile;

					if ( repeat ) {

						texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

						if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

					}

					if ( offset ) {

						texture.offset.set( offset[ 0 ], offset[ 1 ] );

					}

					if ( wrap ) {

						var wrapMap = {
							'repeat': THREE.RepeatWrapping,
							'mirror': THREE.MirroredRepeatWrapping
						};

						if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
						if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

					}

					if ( anisotropy ) {

						texture.anisotropy = anisotropy;

					}

					where[ name ] = texture;

				}

				function rgb2hex( rgb ) {

					return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

				}

				// defaults

				var mtype = 'MeshLambertMaterial';
				var mpars = {};

				// parameters from model file

				if ( m.shading ) {

					var shading = m.shading.toLowerCase();

					if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
					else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

				}

				if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

					mpars.blending = THREE[ m.blending ];

				}

				if ( m.transparent !== undefined ) {

					mpars.transparent = m.transparent;

				}

				if ( m.opacity !== undefined && m.opacity < 1.0 ) {

					mpars.transparent = true;

				}

				if ( m.depthTest !== undefined ) {

					mpars.depthTest = m.depthTest;

				}

				if ( m.depthWrite !== undefined ) {

					mpars.depthWrite = m.depthWrite;

				}

				if ( m.visible !== undefined ) {

					mpars.visible = m.visible;

				}

				if ( m.flipSided !== undefined ) {

					mpars.side = THREE.BackSide;

				}

				if ( m.doubleSided !== undefined ) {

					mpars.side = THREE.DoubleSide;

				}

				if ( m.wireframe !== undefined ) {

					mpars.wireframe = m.wireframe;

				}

				if ( m.vertexColors !== undefined ) {

					if ( m.vertexColors === 'face' ) {

						mpars.vertexColors = THREE.FaceColors;

					} else if ( m.vertexColors ) {

						mpars.vertexColors = THREE.VertexColors;

					}

				}

				// colors

				if ( m.colorDiffuse ) {

					mpars.color = rgb2hex( m.colorDiffuse );

				} else if ( m.DbgColor ) {

					mpars.color = m.DbgColor;

				}

				if ( m.colorEmissive ) {

					mpars.emissive = rgb2hex( m.colorEmissive );

				}

				if ( mtype === 'MeshPhongMaterial' ) {

					if ( m.colorSpecular ) {

						mpars.specular = rgb2hex( m.colorSpecular );

					}

					if ( m.specularCoef ) {

						mpars.shininess = m.specularCoef;

					}

				}

				// modifiers

				if ( m.transparency !== undefined ) {

					console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
					m.opacity = m.transparency;

				}

				if ( m.opacity !== undefined ) {

					mpars.opacity = m.opacity;

				}

				// textures

				if ( texturePath ) {

					if ( m.mapDiffuse ) {

						create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

					}

					if ( m.mapLight ) {

						create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

					}

					if ( m.mapAO ) {

						create_texture( mpars, 'aoMap', m.mapAO, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );

					}

					if ( m.mapBump ) {

						create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

					}

					if ( m.mapNormal ) {

						create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

					}

					if ( m.mapSpecular ) {

						create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

					}

					if ( m.mapAlpha ) {

						create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

					}

				}

				//

				if ( m.mapBumpScale ) {

					mpars.bumpScale = m.mapBumpScale;

				}

				if ( m.mapNormalFactor ) {

					mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );

				}

				var material = new THREE[ mtype ]( mpars );

				if ( m.DbgName !== undefined ) material.name = m.DbgName;

				return material;

			};

		} )()

	};

	THREE.Loader.Handlers = {

		handlers: [],

		add: function ( regex, loader ) {

			this.handlers.push( regex, loader );

		},

		get: function ( file ) {

			for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

				var regex = this.handlers[ i ];
				var loader  = this.handlers[ i + 1 ];

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		}

	};

	// File:src/loaders/XHRLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.XHRLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.XHRLoader.prototype = {

		constructor: THREE.XHRLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var cached = THREE.Cache.get( url );

			if ( cached !== undefined ) {

				if ( onLoad ) {

					setTimeout( function () {

						onLoad( cached );

					}, 0 );

				}

				return cached;

			}

			var request = new XMLHttpRequest();
			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				THREE.Cache.add( url, this.response );

				if ( onLoad ) onLoad( this.response );

				scope.manager.itemEnd( url );

			}, false );

			if ( onProgress !== undefined ) {

				request.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			request.addEventListener( 'error', function ( event ) {

				if ( onError ) onError( event );

				scope.manager.itemError( url );

			}, false );

			if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			request.send( null );

			scope.manager.itemStart( url );

			return request;

		},

		setResponseType: function ( value ) {

			this.responseType = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;

		}

	};

	// File:src/loaders/ImageLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ImageLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.ImageLoader.prototype = {

		constructor: THREE.ImageLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var cached = THREE.Cache.get( url );

			if ( cached !== undefined ) {

				if ( onLoad ) {

					setTimeout( function () {

						onLoad( cached );

					}, 0 );

				}

				return cached;

			}

			var image = document.createElement( 'img' );

			image.addEventListener( 'load', function ( event ) {

				THREE.Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}, false );

			if ( onProgress !== undefined ) {

				image.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			image.addEventListener( 'error', function ( event ) {

				if ( onError ) onError( event );

				scope.manager.itemError( url );

			}, false );

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/JSONLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.JSONLoader = function ( manager ) {

		if ( typeof manager === 'boolean' ) {

			console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;

		}

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

		this.withCredentials = false;

	};

	THREE.JSONLoader.prototype = {

		constructor: THREE.JSONLoader,

		// Deprecated
		
		get statusDomElement () {

			if ( this._statusDomElement === undefined ) {

				this._statusDomElement = document.createElement( 'div' );

			}

			console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
			return this._statusDomElement;

		},

		load: function( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

			var loader = new THREE.XHRLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {

				var json = JSON.parse( text );
				var metadata = json.metadata;

				if ( metadata !== undefined ) {

					if ( metadata.type === 'object' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
						return;

					}

					if ( metadata.type === 'scene' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
						return;

					}

				}

				var object = scope.parse( json, texturePath );
				onLoad( object.geometry, object.materials );

			} );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;

		},

		parse: function ( json, texturePath ) {

			var geometry = new THREE.Geometry(),
			scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

			parseModel( scale );

			parseSkin();
			parseMorphing( scale );

			geometry.computeFaceNormals();
			geometry.computeBoundingSphere();

			function parseModel( scale ) {

				function isBitSet( value, position ) {

					return value & ( 1 << position );

				}

				var i, j, fi,

				offset, zLength,

			colorIndex, normalIndex, uvIndex, materialIndex,

				type,
				isQuad,
				hasMaterial,
				hasFaceVertexUv,
				hasFaceNormal, hasFaceVertexNormal,
				hasFaceColor, hasFaceVertexColor,

			vertex, face, faceA, faceB, hex, normal,

				uvLayer, uv, u, v,

				faces = json.faces,
				vertices = json.vertices,
				normals = json.normals,
				colors = json.colors,

				nUvLayers = 0;

				if ( json.uvs !== undefined ) {

					// disregard empty arrays

					for ( i = 0; i < json.uvs.length; i ++ ) {

						if ( json.uvs[ i ].length ) nUvLayers ++;

					}

					for ( i = 0; i < nUvLayers; i ++ ) {

						geometry.faceVertexUvs[ i ] = [];

					}

				}

				offset = 0;
				zLength = vertices.length;

				while ( offset < zLength ) {

					vertex = new THREE.Vector3();

					vertex.x = vertices[ offset ++ ] * scale;
					vertex.y = vertices[ offset ++ ] * scale;
					vertex.z = vertices[ offset ++ ] * scale;

					geometry.vertices.push( vertex );

				}

				offset = 0;
				zLength = faces.length;

				while ( offset < zLength ) {

					type = faces[ offset ++ ];


					isQuad              = isBitSet( type, 0 );
					hasMaterial         = isBitSet( type, 1 );
					hasFaceVertexUv     = isBitSet( type, 3 );
					hasFaceNormal       = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor	     = isBitSet( type, 6 );
					hasFaceVertexColor  = isBitSet( type, 7 );

					// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

					if ( isQuad ) {

						faceA = new THREE.Face3();
						faceA.a = faces[ offset ];
						faceA.b = faces[ offset + 1 ];
						faceA.c = faces[ offset + 3 ];

						faceB = new THREE.Face3();
						faceB.a = faces[ offset + 1 ];
						faceB.b = faces[ offset + 2 ];
						faceB.c = faces[ offset + 3 ];

						offset += 4;

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];
								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

								for ( j = 0; j < 4; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new THREE.Vector2( u, v );

									if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
									if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							faceA.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							faceB.normal.copy( faceA.normal );

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 4; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);


								if ( i !== 2 ) faceA.vertexNormals.push( normal );
								if ( i !== 0 ) faceB.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							faceA.color.setHex( hex );
							faceB.color.setHex( hex );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 4; i ++ ) {

								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];

								if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
								if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

							}

						}

						geometry.faces.push( faceA );
						geometry.faces.push( faceB );

					} else {

						face = new THREE.Face3();
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							face.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];

								for ( j = 0; j < 3; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new THREE.Vector2( u, v );

									geometry.faceVertexUvs[ i ][ fi ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							face.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 3; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

								face.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							face.color.setHex( colors[ colorIndex ] );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 3; i ++ ) {

								colorIndex = faces[ offset ++ ];
								face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

							}

						}

						geometry.faces.push( face );

					}

				}

			};

			function parseSkin() {

				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

				if ( json.skinWeights ) {

					for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

						var x =                               json.skinWeights[ i ];
						var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
						var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
						var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

						geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

					}

				}

				if ( json.skinIndices ) {

					for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

						var a =                               json.skinIndices[ i ];
						var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
						var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
						var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

						geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

					}

				}

				geometry.bones = json.bones;

				if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

				}


				// could change this to json.animations[0] or remove completely

				geometry.animation = json.animation;
				geometry.animations = json.animations;

			};

			function parseMorphing( scale ) {

				if ( json.morphTargets !== undefined ) {

					var i, l, v, vl, dstVertices, srcVertices;

					for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

						geometry.morphTargets[ i ] = {};
						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
						geometry.morphTargets[ i ].vertices = [];

						dstVertices = geometry.morphTargets[ i ].vertices;
						srcVertices = json.morphTargets[ i ].vertices;

						for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

							var vertex = new THREE.Vector3();
							vertex.x = srcVertices[ v ] * scale;
							vertex.y = srcVertices[ v + 1 ] * scale;
							vertex.z = srcVertices[ v + 2 ] * scale;

							dstVertices.push( vertex );

						}

					}

				}

				if ( json.morphColors !== undefined ) {

					var i, l, c, cl, dstColors, srcColors, color;

					for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

						geometry.morphColors[ i ] = {};
						geometry.morphColors[ i ].name = json.morphColors[ i ].name;
						geometry.morphColors[ i ].colors = [];

						dstColors = geometry.morphColors[ i ].colors;
						srcColors = json.morphColors[ i ].colors;

						for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

							color = new THREE.Color( 0xffaa00 );
							color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
							dstColors.push( color );

						}

					}

				}

			};

			if ( json.materials === undefined || json.materials.length === 0 ) {

				return { geometry: geometry };

			} else {

				var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

				return { geometry: geometry, materials: materials };

			}

		}

	};

	// File:src/loaders/LoadingManager.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

		var scope = this;

		var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

	};

	THREE.DefaultLoadingManager = new THREE.LoadingManager();

	// File:src/loaders/BufferGeometryLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometryLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.BufferGeometryLoader.prototype = {

		constructor: THREE.BufferGeometryLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json ) {

			var geometry = new THREE.BufferGeometry();

			var index = json.data.index;

			if ( index !== undefined ) {

				var typedArray = new self[ index.type ]( index.array );
				geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

			}

			var attributes = json.data.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];
				var typedArray = new self[ attribute.type ]( attribute.array );

				geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

			}

			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if ( groups !== undefined ) {

				for ( var i = 0, n = groups.length; i !== n; ++ i ) {

					var group = groups[ i ];

					geometry.addGroup( group.start, group.count );

				}

			}

			var boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				var center = new THREE.Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

			}

			return geometry;

		}

	};

	// File:src/loaders/MaterialLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MaterialLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.textures = {};

	};

	THREE.MaterialLoader.prototype = {

		constructor: THREE.MaterialLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		setTextures: function ( value ) {

			this.textures = value;

		},

		getTexture: function ( name ) {

			var textures = this.textures;

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		},

		parse: function ( json ) {

			var material = new THREE[ json.type ];
			material.uuid = json.uuid;

			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.shading !== undefined ) material.shading = json.shading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

			// for PointsMaterial
			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if ( json.map !== undefined ) material.map = this.getTexture( json.map );

			if ( json.alphaMap !== undefined ) {

				material.alphaMap = this.getTexture( json.alphaMap );
				material.transparent = true;

			}

			if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

			if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
			if ( json.normalScale )	material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );

			if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

			if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

			if ( json.envMap !== undefined ) {

				material.envMap = this.getTexture( json.envMap );
				material.combine = THREE.MultiplyOperation;

			}

			if ( json.reflectivity ) material.reflectivity = json.reflectivity;

			if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

			if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

			// MeshFaceMaterial

			if ( json.materials !== undefined ) {

				for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

					material.materials.push( this.parse( json.materials[ i ] ) );

				}

			}

			return material;

		}

	};

	// File:src/loaders/ObjectLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ObjectLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.texturePath = '';

	};

	THREE.ObjectLoader.prototype = {

		constructor: THREE.ObjectLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			if ( this.texturePath === '' ) {

				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

			}

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				scope.parse( JSON.parse( text ), onLoad );

			}, onProgress, onError );

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json, onLoad ) {

			var geometries = this.parseGeometries( json.geometries );

			var images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );

			var textures  = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );
			var object = this.parseObject( json.object, geometries, materials );

			if ( json.images === undefined || json.images.length === 0 ) {

				if ( onLoad !== undefined ) onLoad( object );

			}

			return object;

		},

		parseGeometries: function ( json ) {

			var geometries = {};

			if ( json !== undefined ) {

				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var geometry;
					var data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new THREE[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new THREE.BoxGeometry(
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleBufferGeometry':

							geometry = new THREE.CircleBufferGeometry(
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CircleGeometry':

							geometry = new THREE.CircleGeometry(
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CylinderGeometry':

							geometry = new THREE.CylinderGeometry(
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereGeometry':

							geometry = new THREE.SphereGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereBufferGeometry':

							geometry = new THREE.SphereBufferGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'DodecahedronGeometry':

							geometry = new THREE.DodecahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'IcosahedronGeometry':

							geometry = new THREE.IcosahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'OctahedronGeometry':

							geometry = new THREE.OctahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'TetrahedronGeometry':

							geometry = new THREE.TetrahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'RingGeometry':

							geometry = new THREE.RingGeometry(
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'TorusGeometry':

							geometry = new THREE.TorusGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':

							geometry = new THREE.TorusKnotGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.p,
								data.q,
								data.heightScale
							);

							break;

						case 'TextGeometry':

							geometry = new THREE.TextGeometry(
								data.text,
								data.data
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse( data );

							break;

						case 'Geometry':

							geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

							break;

						default:

							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

							continue;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function ( json, textures ) {

			var materials = {};

			if ( json !== undefined ) {

				var loader = new THREE.MaterialLoader();
				loader.setTextures( textures );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var material = loader.parse( json[ i ] );
					materials[ material.uuid ] = material;

				}

			}

			return materials;

		},

		parseImages: function ( json, onLoad ) {

			var scope = this;
			var images = {};

			function loadImage( url ) {

				scope.manager.itemStart( url );

				return loader.load( url, function () {

					scope.manager.itemEnd( url );

				} );

			}

			if ( json !== undefined && json.length > 0 ) {

				var manager = new THREE.LoadingManager( onLoad );

				var loader = new THREE.ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var image = json[ i ];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

					images[ image.uuid ] = loadImage( path );

				}

			}

			return images;

		},

		parseTextures: function ( json, images ) {

			function parseConstant( value ) {

				if ( typeof( value ) === 'number' ) return value;

				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

				return THREE[ value ];

			}

			var textures = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.image === undefined ) {

						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					var texture = new THREE.Texture( images[ data.image ] );
					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;
					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
					if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
					if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
					if ( Array.isArray( data.wrap ) ) {

						texture.wrapS = parseConstant( data.wrap[ 0 ] );
						texture.wrapT = parseConstant( data.wrap[ 1 ] );

					}

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		},

		parseObject: function () {

			var matrix = new THREE.Matrix4();

			return function ( data, geometries, materials ) {

				var object;

				var getGeometry = function ( name ) {

					if ( geometries[ name ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

					}

					return geometries[ name ];

				};

				var getMaterial = function ( name ) {

					if ( materials[ name ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', name );

					}

					return materials[ name ];

				};

				switch ( data.type ) {

					case 'Scene':

						object = new THREE.Scene();

						break;

					case 'PerspectiveCamera':

						object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

						break;

					case 'OrthographicCamera':

						object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

						break;

					case 'AmbientLight':

						object = new THREE.AmbientLight( data.color );

						break;

					case 'DirectionalLight':

						object = new THREE.DirectionalLight( data.color, data.intensity );

						break;

					case 'PointLight':

						object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

						break;

					case 'SpotLight':

						object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

						break;

					case 'HemisphereLight':

						object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

						break;

					case 'Mesh':

						object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'LOD':

						object = new THREE.LOD();

						break;

					case 'Line':

						object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

						break;

					case 'PointCloud':
					case 'Points':

						object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'Sprite':

						object = new THREE.Sprite( getMaterial( data.material ) );

						break;

					case 'Group':

						object = new THREE.Group();

						break;

					default:

						object = new THREE.Object3D();

				}

				object.uuid = data.uuid;

				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {

					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );

				} else {

					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

				}

				if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
				if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;

				if ( data.children !== undefined ) {

					for ( var child in data.children ) {

						object.add( this.parseObject( data.children[ child ], geometries, materials ) );

					}

				}

				if ( data.type === 'LOD' ) {

					var levels = data.levels;

					for ( var l = 0; l < levels.length; l ++ ) {

						var level = levels[ l ];
						var child = object.getObjectByProperty( 'uuid', level.object );

						if ( child !== undefined ) {

							object.addLevel( child, level.distance );

						}

					}

				}

				return object;

			}

		}()

	};

	// File:src/loaders/TextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.TextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.TextureLoader.prototype = {

		constructor: THREE.TextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.ImageLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( image ) {

				var texture = new THREE.Texture( image );
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/BinaryTextureLoader.js

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	};

	THREE.BinaryTextureLoader.prototype = {

		constructor: THREE.BinaryTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texture = new THREE.DataTexture();

			var loader = new THREE.XHRLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setResponseType( 'arraybuffer' );

			loader.load( url, function ( buffer ) {

				var texData = scope._parser( buffer );

				if ( ! texData ) return;

				if ( undefined !== texData.image ) {

					texture.image = texData.image;

				} else if ( undefined !== texData.data ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

				if ( undefined !== texData.format ) {

					texture.format = texData.format;

				}
				if ( undefined !== texData.type ) {

					texture.type = texData.type;

				}

				if ( undefined !== texData.mipmaps ) {

					texture.mipmaps = texData.mipmaps;

				}

				if ( 1 === texData.mipmapCount ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/CompressedTextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	THREE.CompressedTextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	};


	THREE.CompressedTextureLoader.prototype = {

		constructor: THREE.CompressedTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var images = [];

			var texture = new THREE.CompressedTexture();
			texture.image = images;

			var loader = new THREE.XHRLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setResponseType( 'arraybuffer' );

			if ( Array.isArray( url ) ) {

				var loaded = 0;

				var loadTexture = function ( i ) {

					loader.load( url[ i ], function ( buffer ) {

						var texDatas = scope._parser( buffer, true );

						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};

						loaded += 1;

						if ( loaded === 6 ) {

							if ( texDatas.mipmapCount === 1 )
	 							texture.minFilter = THREE.LinearFilter;

							texture.format = texDatas.format;
							texture.needsUpdate = true;

							if ( onLoad ) onLoad( texture );

						}

					}, onProgress, onError );

				};

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps : [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = THREE.LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}, onProgress, onError );

			}

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/materials/Material.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Material = function () {

		Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.side = THREE.FrontSide;

		this.opacity = 1;
		this.transparent = false;

		this.blending = THREE.NormalBlending;

		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = THREE.LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.alphaTest = 0;

		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

		this.visible = true;

		this._needsUpdate = true;

	};

	THREE.Material.prototype = {

		constructor: THREE.Material,

		get needsUpdate () {

			return this._needsUpdate;

		},

		set needsUpdate ( value ) {

			if ( value === true ) this.update();

			this._needsUpdate = value;

		},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				var currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;

				}

				if ( currentValue instanceof THREE.Color ) {

					currentValue.set( newValue );

				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

					currentValue.copy( newValue );

				} else if ( key === 'overdraw' ) {

					// ensure overdraw is backwards-compatible with legacy boolean type
					this[ key ] = Number( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			var data = {
				metadata: {
					version: 4.4,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
			if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
			if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;

			if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
			if ( this.bumpMap instanceof THREE.Texture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}
			if ( this.normalMap instanceof THREE.Texture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js

			}
			if ( this.displacementMap instanceof THREE.Texture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}
			if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
			if ( this.envMap instanceof THREE.Texture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap

			}

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
			if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
			if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
			if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;
			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.side = source.side;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blending = source.blending;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.alphaTest = source.alphaTest;

			this.overdraw = source.overdraw;

			this.visible = source.visible;

			return this;

		},

		update: function () {

			this.dispatchEvent( { type: 'update' } );

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		// Deprecated

		get wrapAround () {

			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

		},

		set wrapAround ( boolean ) {

			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

		},

		get wrapRGB () {

			console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
			return new THREE.Color();

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

	THREE.MaterialIdCount = 0;

	// File:src/materials/LineBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round",
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.LineBasicMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

	THREE.LineBasicMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.vertexColors = source.vertexColors;

		this.fog = source.fog;

		return this;

	};

	// File:src/materials/LineDashedMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>,
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.LineDashedMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'LineDashedMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.linewidth = 1;

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.vertexColors = false;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

	THREE.LineDashedMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		
		this.linewidth = source.linewidth;

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		this.vertexColors = source.vertexColors;

		this.fog = source.fog;

		return this;

	};

	// File:src/materials/MeshBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.MeshBasicMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new THREE.Color( 0xffffff ); // emissive

		this.map = null;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;

		this.setValues( parameters );

	};

	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

	THREE.MeshBasicMaterial.prototype.copy = function ( source ) {
		
		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.fog = source.fog;

		this.shading = source.shading;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.vertexColors = source.vertexColors;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		
		return this;

	};

	// File:src/materials/MeshLambertMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.MeshLambertMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );

		this.map = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	};

	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

	THREE.MeshLambertMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.emissive.copy( source.emissive );

		this.map = source.map;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.fog = source.fog;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.vertexColors = source.vertexColors;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	// File:src/materials/MeshPhongMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.MeshPhongMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;

		this.metal = false;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	};

	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

	THREE.MeshPhongMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.emissive.copy( source.emissive );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.metal = source.metal;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissiveMap = source.emissiveMap;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.fog = source.fog;

		this.shading = source.shading;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.vertexColors = source.vertexColors;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	// File:src/materials/MeshDepthMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshDepthMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.morphTargets = false;
		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.setValues( parameters );

	};

	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

	THREE.MeshDepthMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	// File:src/materials/MeshNormalMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  shading: THREE.FlatShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshNormalMaterial = function ( parameters ) {

		THREE.Material.call( this, parameters );

		this.type = 'MeshNormalMaterial';

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.morphTargets = false;

		this.setValues( parameters );

	};

	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

	THREE.MeshNormalMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	// File:src/materials/MultiMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MultiMaterial = function ( materials ) {

		this.uuid = THREE.Math.generateUUID();

		this.type = 'MultiMaterial';

		this.materials = materials instanceof Array ? materials : [];

		this.visible = true;

	};

	THREE.MultiMaterial.prototype = {

		constructor: THREE.MultiMaterial,

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			};

			for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

				output.materials.push( this.materials[ i ].toJSON() );

			}

			output.visible = this.visible;

			return output;

		},

		clone: function () {

			var material = new this.constructor();

			for ( var i = 0; i < this.materials.length; i ++ ) {

				material.materials.push( this.materials[ i ].clone() );

			}

			material.visible = this.visible;

			return material;

		}

	};

	// backwards compatibility

	THREE.MeshFaceMaterial = THREE.MultiMaterial;

	// File:src/materials/PointsMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  vertexColors: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.PointsMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'PointsMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.vertexColors = THREE.NoColors;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

	THREE.PointsMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.vertexColors = source.vertexColors;

		this.fog = source.fog;

		return this;

	};

	// backwards compatibility

	THREE.PointCloudMaterial = function ( parameters ) {

		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );

	};

	THREE.ParticleBasicMaterial = function ( parameters ) {

		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );

	};

	THREE.ParticleSystemMaterial = function ( parameters ) {

		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );

	};

	// File:src/materials/ShaderMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.ShaderMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

		this.shading = THREE.SmoothShading;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog

		this.lights = false; // set to use scene lights

		this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

		this.skinning = false; // set to use skinning attribute streams

		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.derivatives = false; // set to use derivatives

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	};

	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

	THREE.ShaderMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

		this.attributes = source.attributes;
		this.defines = source.defines;

		this.shading = source.shading;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.fog = source.fog;

		this.lights = source.lights;

		this.vertexColors = source.vertexColors;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.derivatives = source.derivatives;

		return this;

	};

	THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

		var data = THREE.Material.prototype.toJSON.call( this, meta );

		data.uniforms = this.uniforms;
		data.attributes = this.attributes;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		return data;

	};

	// File:src/materials/RawShaderMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.RawShaderMaterial = function ( parameters ) {

		THREE.ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	};

	THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
	THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
	// File:src/materials/SpriteMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2(),
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.SpriteMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'SpriteMaterial';

		this.color = new THREE.Color( 0xffffff );
		this.map = null;

		this.rotation = 0;

		this.fog = false;

		// set parameters

		this.setValues( parameters );

	};

	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

	THREE.SpriteMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.map = source.map;

		this.rotation = source.rotation;

		this.fog = source.fog;

		return this;

	};

	// File:src/textures/Texture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.sourceFile = '';

		this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;

		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		this.version = 0;
		this.onUpdate = null;

	};

	THREE.Texture.DEFAULT_IMAGE = undefined;
	THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

	THREE.Texture.prototype = {

		constructor: THREE.Texture,

		set needsUpdate ( value ) {

			if ( value === true ) this.version ++;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;

			return this;

		},

		toJSON: function ( meta ) {

			if ( meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			function getDataURL( image ) {

				var canvas;

				if ( image.toDataURL !== undefined ) {

					canvas = image;

				} else {

					canvas = document.createElement( 'canvas' );
					canvas.width = image.width;
					canvas.height = image.height;

					canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

				}

				if ( canvas.width > 2048 || canvas.height > 2048 ) {

					return canvas.toDataURL( 'image/jpeg', 0.6 );

				} else {

					return canvas.toDataURL( 'image/png' );

				}

			}

			var output = {
				metadata: {
					version: 4.4,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				wrap: [ this.wrapS, this.wrapT ],

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy
			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				var image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = THREE.Math.generateUUID(); // UGH

				}

				if ( meta.images[ image.uuid ] === undefined ) {

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: getDataURL( image )
					};

				}

				output.image = image.uuid;

			}

			meta.textures[ this.uuid ] = output;

			return output;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		transformUv: function ( uv ) {

			if ( this.mapping !== THREE.UVMapping )  return;

			uv.multiply( this.repeat );
			uv.add( this.offset );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case THREE.RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case THREE.ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case THREE.MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}
						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case THREE.RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case THREE.ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case THREE.MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}
						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

	THREE.TextureIdCount = 0;

	// File:src/textures/CanvasTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	};

	THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

	// File:src/textures/CubeTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

		THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.images = images;
		this.flipY = false;

	};

	THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

	THREE.CubeTexture.prototype.copy = function ( source ) {

		THREE.Texture.prototype.copy.call( this, source );
		
		this.images = source.images;
		
		return this;

	};
	// File:src/textures/CompressedTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	};

	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

	// File:src/textures/DataTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { data: data, width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
		
		this.flipY = false;
		this.generateMipmaps  = false;

	};

	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.DataTexture.prototype.constructor = THREE.DataTexture;

	// File:src/textures/VideoTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.generateMipmaps = false;

		var scope = this;

		var update = function () {

			requestAnimationFrame( update );

			if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

				scope.needsUpdate = true;

			}

		};

		update();

	};

	THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

	// File:src/objects/Group.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Group = function () {

		THREE.Object3D.call( this );

		this.type = 'Group';

	};

	THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Group.prototype.constructor = THREE.Group;
	// File:src/objects/Points.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Points = function ( geometry, material ) {

		THREE.Object3D.call( this );

		this.type = 'Points';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );

	};

	THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Points.prototype.constructor = THREE.Points;

	THREE.Points.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();

		return function raycast( raycaster, intersects ) {

			var object = this;
			var geometry = object.geometry;
			var threshold = raycaster.params.Points.threshold;

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

					return;

				}

			}

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;
			var position = new THREE.Vector3();

			function testPoint( point, index ) {

				var rayPointDistanceSq = ray.distanceSqToPoint( point );

				if ( rayPointDistanceSq < localThresholdSq ) {

					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

					if ( distance < raycaster.near || distance > raycaster.far ) return;

					intersects.push( {

						distance: distance,
						distanceToRay: Math.sqrt( rayPointDistanceSq ),
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object

					} );

				}

			}

			if ( geometry instanceof THREE.BufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, il = indices.length; i < il; i ++ ) {

						var a = indices[ i ];

						position.fromArray( positions, a * 3 );

						testPoint( position, a );

					}

				} else {

					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

						position.fromArray( positions, i * 3 );

						testPoint( position, i );

					}

				}

			} else {

				var vertices = geometry.vertices;

				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

					testPoint( vertices[ i ], i );

				}

			}

		};

	}() );

	THREE.Points.prototype.clone = function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	};

	THREE.Points.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		// only serialize if not in meta geometries cache
		if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

			meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();

		}

		// only serialize if not in meta materials cache
		if ( meta.materials[ this.material.uuid ] === undefined ) {

			meta.materials[ this.material.uuid ] = this.material.toJSON();

		}

		data.object.geometry = this.geometry.uuid;
		data.object.material = this.material.uuid;

		return data;

	};

	// Backwards compatibility

	THREE.PointCloud = function ( geometry, material ) {

		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new THREE.Points( geometry, material );

	};

	THREE.ParticleSystem = function ( geometry, material ) {

		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new THREE.Points( geometry, material );

	};

	// File:src/objects/Line.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Line = function ( geometry, material, mode ) {

		if ( mode === 1 ) {

			console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
			return new THREE.LineSegments( geometry, material );

		}

		THREE.Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

	};

	THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Line.prototype.constructor = THREE.Line;

	THREE.Line.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		return function raycast( raycaster, intersects ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = this.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			// Checking boundingSphere distance to ray

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return;

			}

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var vStart = new THREE.Vector3();
			var vEnd = new THREE.Vector3();
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this instanceof THREE.LineSegments ? 2 : 1;

			if ( geometry instanceof THREE.BufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;

				if ( index !== null ) {

					var indices = index.array;
					var positions = attributes.position.array;

					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

						var a = indices[ i ];
						var b = indices[ i + 1 ];

						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				} else {

					var positions = attributes.position.array;

					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;

				for ( var i = 0; i < nbVertices - 1; i += step ) {

					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		};

	}() );

	THREE.Line.prototype.clone = function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	};

	THREE.Line.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		// only serialize if not in meta geometries cache
		if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

			meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();

		}

		// only serialize if not in meta materials cache
		if ( meta.materials[ this.material.uuid ] === undefined ) {

			meta.materials[ this.material.uuid ] = this.material.toJSON();

		}

		data.object.geometry = this.geometry.uuid;
		data.object.material = this.material.uuid;

		return data;

	};

	// DEPRECATED

	THREE.LineStrip = 0;
	THREE.LinePieces = 1;

	// File:src/objects/LineSegments.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LineSegments = function ( geometry, material ) {

		THREE.Line.call( this, geometry, material );

		this.type = 'LineSegments';

	};

	THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
	THREE.LineSegments.prototype.constructor = THREE.LineSegments;

	// File:src/objects/Mesh.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	THREE.Mesh = function ( geometry, material ) {

		THREE.Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

		this.updateMorphTargets();

	};

	THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Mesh.prototype.constructor = THREE.Mesh;

	THREE.Mesh.prototype.updateMorphTargets = function () {

		if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

			this.morphTargetBase = - 1;
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};

			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

			}

		}

	};

	THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

		if ( this.morphTargetDictionary[ name ] !== undefined ) {

			return this.morphTargetDictionary[ name ];

		}

		console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

		return 0;

	};


	THREE.Mesh.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		var vA = new THREE.Vector3();
		var vB = new THREE.Vector3();
		var vC = new THREE.Vector3();

		var tempA = new THREE.Vector3();
		var tempB = new THREE.Vector3();
		var tempC = new THREE.Vector3();

		var uvA = new THREE.Vector2();
		var uvB = new THREE.Vector2();
		var uvC = new THREE.Vector2();

		var barycoord = new THREE.Vector3();

		var intersectionPoint = new THREE.Vector3();
		var intersectionPointWorld = new THREE.Vector3();

		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

			THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

			uv1.multiplyScalar( barycoord.x );
			uv2.multiplyScalar( barycoord.y );
			uv3.multiplyScalar( barycoord.z );

			uv1.add( uv2 ).add( uv3 );

			return uv1.clone();

		}

		return function raycast( raycaster, intersects ) {

			var geometry = this.geometry;
			var material = this.material;

			if ( material === undefined ) return;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return;

			}

			// Check boundingBox before continuing

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

					return;

				}

			}

			var a, b, c;

			if ( geometry instanceof THREE.BufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;

				if ( index !== null ) {

					var indices = index.array;
					var positions = attributes.position.array;

					for ( var i = 0, l = indices.length; i < l; i += 3 ) {

						a = indices[ i ];
						b = indices[ i + 1 ];
						c = indices[ i + 2 ];

						vA.fromArray( positions, a * 3 );
						vB.fromArray( positions, b * 3 );
						vC.fromArray( positions, c * 3 );

						if ( material.side === THREE.BackSide ) {

							if ( ray.intersectTriangle( vC, vB, vA, true, intersectionPoint ) === null ) continue;

						} else {

							if ( ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

						}

						intersectionPointWorld.copy( intersectionPoint );
						intersectionPointWorld.applyMatrix4( this.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						var uv;

						if ( attributes.uv !== undefined ) {

							var uvs = attributes.uv.array;
							uvA.fromArray( uvs, a * 2 );
							uvB.fromArray( uvs, b * 2 );
							uvC.fromArray( uvs, c * 2 );
							uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

						}

						intersects.push( {

							distance: distance,
							point: intersectionPointWorld.clone(),
							uv: uv,
							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
							faceIndex: Math.floor( i / 3 ), // triangle number in indices buffer semantics
							object: this

						} );

					}

				} else {

					var positions = attributes.position.array;

					for ( var i = 0, l = positions.length; i < l; i += 9 ) {

						vA.fromArray( positions, i );
						vB.fromArray( positions, i + 3 );
						vC.fromArray( positions, i + 6 );

						if ( material.side === THREE.BackSide ) {

							if ( ray.intersectTriangle( vC, vB, vA, true, intersectionPoint ) === null ) continue;

						} else {

							if ( ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

						}

						intersectionPointWorld.copy( intersectionPoint );
						intersectionPointWorld.applyMatrix4( this.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						var uv;

						if ( attributes.uv !== undefined ) {

							var uvs = attributes.uv.array;
							uvA.fromArray( uvs, i );
							uvB.fromArray( uvs, i + 2 );
							uvC.fromArray( uvs, i + 4 );
							uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

						}

						a = i / 3;
						b = a + 1;
						c = a + 2;

						intersects.push( {

							distance: distance,
							point: intersectionPointWorld.clone(),
							uv: uv,
							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
							index: a, // triangle number in positions buffer semantics
							object: this

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
				var materials = isFaceMaterial === true ? material.materials : null;

				var vertices = geometry.vertices;
				var faces = geometry.faces;

				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

					var face = faces[ f ];
					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

					if ( faceMaterial === undefined ) continue;

					a = vertices[ face.a ];
					b = vertices[ face.b ];
					c = vertices[ face.c ];

					if ( faceMaterial.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.addScaledVector( tempA.subVectors( targets[ face.a ], a ), influence );
							vB.addScaledVector( tempB.subVectors( targets[ face.b ], b ), influence );
							vC.addScaledVector( tempC.subVectors( targets[ face.c ], c ), influence );

						}

						vA.add( a );
						vB.add( b );
						vC.add( c );

						a = vA;
						b = vB;
						c = vC;

					}

					if ( faceMaterial.side === THREE.BackSide ) {

						if ( ray.intersectTriangle( c, b, a, true, intersectionPoint ) === null ) continue;

					} else {

						if ( ray.intersectTriangle( a, b, c, faceMaterial.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

					}

					intersectionPointWorld.copy( intersectionPoint );
					intersectionPointWorld.applyMatrix4( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					var uv;

					if ( geometry.faceVertexUvs[ 0 ].length > 0 ) {

						var uvs = geometry.faceVertexUvs[ 0 ][ f ];
						uvA.copy( uvs[ 0 ] );
						uvB.copy( uvs[ 1 ] );
						uvC.copy( uvs[ 2 ] );
						uv = uvIntersection( intersectionPoint, a, b, c, uvA, uvB, uvC );

					}

					intersects.push( {

						distance: distance,
						point: intersectionPointWorld.clone(),
						uv: uv,
						face: face,
						faceIndex: f,
						object: this

					} );

				}

			}

		};

	}() );

	THREE.Mesh.prototype.clone = function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	};

	THREE.Mesh.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		// only serialize if not in meta geometries cache
		if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

			meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

		}

		// only serialize if not in meta materials cache
		if ( meta.materials[ this.material.uuid ] === undefined ) {

			meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

		}

		data.object.geometry = this.geometry.uuid;
		data.object.material = this.material.uuid;

		return data;

	};

	// File:src/objects/Bone.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.Bone = function ( skin ) {

		THREE.Object3D.call( this );

		this.type = 'Bone';

		this.skin = skin;

	};

	THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Bone.prototype.constructor = THREE.Bone;

	THREE.Bone.prototype.copy = function ( source ) {
		
		THREE.Object3D.prototype.copy.call( this, source );
		
		this.skin = source.skin;
		
		return this;

	};

	// File:src/objects/Skeleton.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

		this.identityMatrix = new THREE.Matrix4();

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice( 0 );

		// create a bone texture or an array of floats

		if ( this.useVertexTexture ) {

			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
			//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
			//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
			//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

			
			var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
			size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
			size = Math.max( size, 4 );

			this.boneTextureWidth = size;
			this.boneTextureHeight = size;

			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

		} else {

			this.boneMatrices = new Float32Array( 16 * this.bones.length );

		}

		// use the supplied bone inverses or calculate the inverses

		if ( boneInverses === undefined ) {

			this.calculateInverses();

		} else {

			if ( this.bones.length === boneInverses.length ) {

				this.boneInverses = boneInverses.slice( 0 );

			} else {

				console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

				this.boneInverses = [];

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					this.boneInverses.push( new THREE.Matrix4() );

				}

			}

		}

	};

	THREE.Skeleton.prototype.calculateInverses = function () {

		this.boneInverses = [];

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			var inverse = new THREE.Matrix4();

			if ( this.bones[ b ] ) {

				inverse.getInverse( this.bones[ b ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	};

	THREE.Skeleton.prototype.pose = function () {

		var bone;

		// recover the bind-time world matrices

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				if ( bone.parent ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	};

	THREE.Skeleton.prototype.update = ( function () {

		var offsetMatrix = new THREE.Matrix4();

		return function update() {

			// flatten bone matrices to array

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				// compute the offset between the current and the original transform

				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

			}

			if ( this.useVertexTexture ) {

				this.boneTexture.needsUpdate = true;

			}

		};

	} )();

	THREE.Skeleton.prototype.clone = function () {

		return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

	};

	// File:src/objects/SkinnedMesh.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

		THREE.Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = "attached";
		this.bindMatrix = new THREE.Matrix4();
		this.bindMatrixInverse = new THREE.Matrix4();

		// init bones

		// TODO: remove bone creation as there is no reason (other than
		// convenience) for THREE.SkinnedMesh to do this.

		var bones = [];

		if ( this.geometry && this.geometry.bones !== undefined ) {

			var bone, gbone;

			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

				gbone = this.geometry.bones[ b ];

				bone = new THREE.Bone( this );
				bones.push( bone );

				bone.name = gbone.name;
				bone.position.fromArray( gbone.pos );
				bone.quaternion.fromArray( gbone.rotq );
				if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

			}

			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

				gbone = this.geometry.bones[ b ];

				if ( gbone.parent !== - 1 ) {

					bones[ gbone.parent ].add( bones[ b ] );

				} else {

					this.add( bones[ b ] );

				}

			}

		}

		this.normalizeSkinWeights();

		this.updateMatrixWorld( true );
		this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

	};


	THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

	THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );
			
			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	};

	THREE.SkinnedMesh.prototype.pose = function () {

		this.skeleton.pose();

	};

	THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

		if ( this.geometry instanceof THREE.Geometry ) {

			for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

				var sw = this.geometry.skinWeights[ i ];

				var scale = 1.0 / sw.lengthManhattan();

				if ( scale !== Infinity ) {

					sw.multiplyScalar( scale );

				} else {

					sw.set( 1 ); // this will be normalized by the shader anyway

				}

			}

		} else {

			// skinning weights assumed to be normalized for THREE.BufferGeometry

		}

	};

	THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

		THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

		if ( this.bindMode === "attached" ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === "detached" ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

		}

	};

	THREE.SkinnedMesh.prototype.clone = function() {

		return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

	};

	// File:src/objects/MorphAnimMesh.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MorphAnimMesh = function ( geometry, material ) {

		THREE.Mesh.call( this, geometry, material );

		this.type = 'MorphAnimMesh';

		// API

		this.duration = 1000; // milliseconds
		this.mirroredLoop = false;
		this.time = 0;

		// internals

		this.lastKeyframe = 0;
		this.currentKeyframe = 0;

		this.direction = 1;
		this.directionBackwards = false;

		this.setFrameRange( 0, geometry.morphTargets.length - 1 );

	};

	THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

	THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

		this.startKeyframe = start;
		this.endKeyframe = end;

		this.length = this.endKeyframe - this.startKeyframe + 1;

	};

	THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

		this.direction = 1;
		this.directionBackwards = false;

	};

	THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

		this.direction = - 1;
		this.directionBackwards = true;

	};

	THREE.MorphAnimMesh.prototype.parseAnimations = function () {

		var geometry = this.geometry;

		if ( ! geometry.animations ) geometry.animations = {};

		var firstAnimation, animations = geometry.animations;

		var pattern = /([a-z]+)_?(\d+)/;

		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

			var morph = geometry.morphTargets[ i ];
			var parts = morph.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var label = parts[ 1 ];

				if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

				var animation = animations[ label ];

				if ( i < animation.start ) animation.start = i;
				if ( i > animation.end ) animation.end = i;

				if ( ! firstAnimation ) firstAnimation = label;

			}

		}

		geometry.firstAnimation = firstAnimation;

	};

	THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

		if ( ! this.geometry.animations ) this.geometry.animations = {};

		this.geometry.animations[ label ] = { start: start, end: end };

	};

	THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

		var animation = this.geometry.animations[ label ];

		if ( animation ) {

			this.setFrameRange( animation.start, animation.end );
			this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
			this.time = 0;

		} else {

			console.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );

		}

	};

	THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

		var frameTime = this.duration / this.length;

		this.time += this.direction * delta;

		if ( this.mirroredLoop ) {

			if ( this.time > this.duration || this.time < 0 ) {

				this.direction *= - 1;

				if ( this.time > this.duration ) {

					this.time = this.duration;
					this.directionBackwards = true;

				}

				if ( this.time < 0 ) {

					this.time = 0;
					this.directionBackwards = false;

				}

			}

		} else {

			this.time = this.time % this.duration;

			if ( this.time < 0 ) this.time += this.duration;

		}

		var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

		var influences = this.morphTargetInfluences;

		if ( keyframe !== this.currentKeyframe ) {

			influences[ this.lastKeyframe ] = 0;
			influences[ this.currentKeyframe ] = 1;
			influences[ keyframe ] = 0;

			this.lastKeyframe = this.currentKeyframe;
			this.currentKeyframe = keyframe;

		}

		var mix = ( this.time % frameTime ) / frameTime;

		if ( this.directionBackwards ) {

			mix = 1 - mix;

		}

		influences[ this.currentKeyframe ] = mix;
		influences[ this.lastKeyframe ] = 1 - mix;

	};

	THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

		var influences = this.morphTargetInfluences;

		for ( var i = 0, l = influences.length; i < l; i ++ ) {

			influences[ i ] = 0;

		}

		if ( a > - 1 ) influences[ a ] = 1 - t;
		if ( b > - 1 ) influences[ b ] = t;

	};

	THREE.MorphAnimMesh.prototype.copy = function ( source ) {

		THREE.Mesh.prototype.copy.call( this, source );

		this.duration = source.duration;
		this.mirroredLoop = source.mirroredLoop;
		this.time = source.time;

		this.lastKeyframe = source.lastKeyframe;
		this.currentKeyframe = source.currentKeyframe;

		this.direction = source.direction;
		this.directionBackwards = source.directionBackwards;

		return this;

	};

	// File:src/objects/LOD.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LOD = function () {

		THREE.Object3D.call( this );

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			objects: {
				get: function () {

					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;

				}
			}
		} );

	};


	THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LOD.prototype.constructor = THREE.LOD;

	THREE.LOD.prototype.addLevel = function ( object, distance ) {

		if ( distance === undefined ) distance = 0;

		distance = Math.abs( distance );

		var levels = this.levels;

		for ( var l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

	};

	THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

		var levels = this.levels;

		for ( var i = 1, l = levels.length; i < l; i ++ ) {

			if ( distance < levels[ i ].distance ) {

				break;

			}

		}

		return levels[ i - 1 ].object;

	};

	THREE.LOD.prototype.raycast = ( function () {

		var matrixPosition = new THREE.Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		};

	}() );

	THREE.LOD.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function update( camera ) {

			var levels = this.levels;

			if ( levels.length > 1 ) {

				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );

				var distance = v1.distanceTo( v2 );

				levels[ 0 ].object.visible = true;

				for ( var i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance >= levels[ i ].distance ) {

						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;

					} else {

						break;

					}

				}

				for ( ; i < l; i ++ ) {

					levels[ i ].object.visible = false;

				}

			}

		};

	}();

	THREE.LOD.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source, false );

		var levels = source.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		return this;

	};

	THREE.LOD.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.levels = [];

		var levels = this.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	};

	// File:src/objects/Sprite.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Sprite = ( function () {

		var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
		var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
		var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		return function Sprite( material ) {

			THREE.Object3D.call( this );

			this.type = 'Sprite';

			this.geometry = geometry;
			this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

		};

	} )();

	THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Sprite.prototype.constructor = THREE.Sprite;

	THREE.Sprite.prototype.raycast = ( function () {

		var matrixPosition = new THREE.Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
			var guessSizeSq = this.scale.x * this.scale.y;

			if ( distanceSq > guessSizeSq ) {

				return;

			}

			intersects.push( {

				distance: Math.sqrt( distanceSq ),
				point: this.position,
				face: null,
				object: this

			} );

		};

	}() );

	THREE.Sprite.prototype.clone = function () {

		return new this.constructor( this.material ).copy( this );

	};

	THREE.Sprite.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		// only serialize if not in meta materials cache
		if ( meta.materials[ this.material.uuid ] === undefined ) {

			meta.materials[ this.material.uuid ] = this.material.toJSON();

		}

		data.object.material = this.material.uuid;

		return data;

	};

	// Backwards compatibility

	THREE.Particle = THREE.Sprite;

	// File:src/objects/LensFlare.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlare = function ( texture, size, distance, blending, color ) {

		THREE.Object3D.call( this );

		this.lensFlares = [];

		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;

		if ( texture !== undefined ) {

			this.add( texture, size, distance, blending, color );

		}

	};

	THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LensFlare.prototype.constructor = THREE.LensFlare;


	/*
	 * Add: adds another flare
	 */

	THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new THREE.Color( 0xffffff );
		if ( blending === undefined ) blending = THREE.NormalBlending;

		distance = Math.min( distance, Math.max( 0, distance ) );

		this.lensFlares.push( {
			texture: texture,	// THREE.Texture
			size: size, 		// size in pixels (-1 = use texture.width)
			distance: distance, 	// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
			scale: 1, 		// scale
			rotation: 0, 		// rotation
			opacity: opacity,	// opacity
			color: color,		// color
			blending: blending	// blending
		} );

	};

	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */

	THREE.LensFlare.prototype.updateLensFlares = function () {

		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;

		for ( f = 0; f < fl; f ++ ) {

			flare = this.lensFlares[ f ];

			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;

			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

		}

	};

	THREE.LensFlare.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		this.positionScreen.copy( source.positionScreen );
		this.customUpdateCallback = source.customUpdateCallback;

		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

			this.lensFlares.push( source.lensFlares[ i ] );

		}

		return this;

	};

	// File:src/scenes/Scene.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Scene = function () {

		THREE.Object3D.call( this );

		this.type = 'Scene';

		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	};

	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Scene.prototype.constructor = THREE.Scene;

	THREE.Scene.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		if ( source.fog !== null ) this.fog = source.fog.clone();
		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	};

	// File:src/scenes/Fog.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Fog = function ( color, near, far ) {

		this.name = '';

		this.color = new THREE.Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	};

	THREE.Fog.prototype.clone = function () {

		return new THREE.Fog( this.color.getHex(), this.near, this.far );

	};

	// File:src/scenes/FogExp2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.FogExp2 = function ( color, density ) {

		this.name = '';

		this.color = new THREE.Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	};

	THREE.FogExp2.prototype.clone = function () {

		return new THREE.FogExp2( this.color.getHex(), this.density );

	};

	// File:src/renderers/shaders/ShaderChunk.js

	THREE.ShaderChunk = {};

	// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

	THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

	THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

	THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

	THREE.ShaderChunk[ 'aomap_fragment'] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

	THREE.ShaderChunk[ 'aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

	THREE.ShaderChunk[ 'begin_vertex'] = "\nvec3 transformed = vec3( position );\n";

	// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

	THREE.ShaderChunk[ 'beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";

	// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

	THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

	THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

	THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

	THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/common.glsl

	THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n	// Original approximation by Christophe Schlick '94\n	//;float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n	// Optimized variant (presented by Epic at SIGGRAPH '13)\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n	// geometry term is (nl)(nv) / 4(nl)(nv)\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n	// factor of 1/PI in distribution term omitted\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	//float dotNL = saturate( dot( normal, lightDir ) );\n	//float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";

	// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

	THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

	// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

	THREE.ShaderChunk[ 'displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

	THREE.ShaderChunk[ 'emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

	THREE.ShaderChunk[ 'emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

	THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

	THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

	THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

	THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

	THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

	THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

	THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		// attenuation\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n			// attenuation\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n			// diffuse\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack += ambientLightColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

	THREE.ShaderChunk[ 'lights_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		// attenuation\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		// diffuse\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n		// specular\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n			// attenuation\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n			// diffuse\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n			// specular\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n		// diffuse\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n		// specular\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalDiffuseLight += lightColor;\n\n		// specular (sky term only)\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * max( dotProduct, 0.0 );\n\n	}\n\n#endif\n\n#ifdef METAL\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;\n\n#else\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

	THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

	THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

	THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

	THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

	THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

	THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

	THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

	THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

	THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

	THREE.ShaderChunk[ 'map_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

	THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

	THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

	THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

	THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

	THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

	THREE.ShaderChunk[ 'project_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

	THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n		#endif\n\n	}\n\n	outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

	THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

	THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

	THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

	THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

	THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

	THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

	THREE.ShaderChunk[ 'uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

	THREE.ShaderChunk[ 'uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

	THREE.ShaderChunk[ 'uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

	THREE.ShaderChunk[ 'uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

	THREE.ShaderChunk[ 'uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

	THREE.ShaderChunk[ 'uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

	THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/UniformsUtils.js

	/**
	 * Uniform Utilities
	 */

	THREE.UniformsUtils = {

		merge: function ( uniforms ) {

			var merged = {};

			for ( var u = 0; u < uniforms.length; u ++ ) {

				var tmp = this.clone( uniforms[ u ] );

				for ( var p in tmp ) {

					merged[ p ] = tmp[ p ];

				}

			}

			return merged;

		},

		clone: function ( uniforms_src ) {

			var uniforms_dst = {};

			for ( var u in uniforms_src ) {

				uniforms_dst[ u ] = {};

				for ( var p in uniforms_src[ u ] ) {

					var parameter_src = uniforms_src[ u ][ p ];

					if ( parameter_src instanceof THREE.Color ||
						 parameter_src instanceof THREE.Vector2 ||
						 parameter_src instanceof THREE.Vector3 ||
						 parameter_src instanceof THREE.Vector4 ||
						 parameter_src instanceof THREE.Matrix3 ||
						 parameter_src instanceof THREE.Matrix4 ||
						 parameter_src instanceof THREE.Texture ) {

						uniforms_dst[ u ][ p ] = parameter_src.clone();

					} else if ( Array.isArray( parameter_src ) ) {

						uniforms_dst[ u ][ p ] = parameter_src.slice();

					} else {

						uniforms_dst[ u ][ p ] = parameter_src;

					}

				}

			}

			return uniforms_dst;

		}

	};

	// File:src/renderers/shaders/UniformsLib.js

	/**
	 * Uniforms library for shared webgl shaders
	 */

	THREE.UniformsLib = {

		common: {

			"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },

			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

			"specularMap" : { type: "t", value: null },
			"alphaMap" : { type: "t", value: null },

			"envMap" : { type: "t", value: null },
			"flipEnvMap" : { type: "f", value: - 1 },
			"reflectivity" : { type: "f", value: 1.0 },
			"refractionRatio" : { type: "f", value: 0.98 }

		},

		aomap: {

			"aoMap" : { type: "t", value: null },
			"aoMapIntensity" : { type: "f", value: 1 },

		},

		lightmap: {

			"lightMap" : { type: "t", value: null },
			"lightMapIntensity" : { type: "f", value: 1 },

		},

		emissivemap: {

			"emissiveMap" : { type: "t", value: null },

		},

		bumpmap: {

			"bumpMap" : { type: "t", value: null },
			"bumpScale" : { type: "f", value: 1 }

		},

		normalmap: {

			"normalMap" : { type: "t", value: null },
			"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }

		},

		displacementmap: {

			"displacementMap" : { type: "t", value: null },
			"displacementScale" : { type: "f", value: 1 },
			"displacementBias" : { type: "f", value: 0 }

		},

		fog : {

			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

		},

		lights: {

			"ambientLightColor" : { type: "fv", value: [] },

			"directionalLightDirection" : { type: "fv", value: [] },
			"directionalLightColor" : { type: "fv", value: [] },

			"hemisphereLightDirection" : { type: "fv", value: [] },
			"hemisphereLightSkyColor" : { type: "fv", value: [] },
			"hemisphereLightGroundColor" : { type: "fv", value: [] },

			"pointLightColor" : { type: "fv", value: [] },
			"pointLightPosition" : { type: "fv", value: [] },
			"pointLightDistance" : { type: "fv1", value: [] },
			"pointLightDecay" : { type: "fv1", value: [] },

			"spotLightColor" : { type: "fv", value: [] },
			"spotLightPosition" : { type: "fv", value: [] },
			"spotLightDirection" : { type: "fv", value: [] },
			"spotLightDistance" : { type: "fv1", value: [] },
			"spotLightAngleCos" : { type: "fv1", value: [] },
			"spotLightExponent" : { type: "fv1", value: [] },
			"spotLightDecay" : { type: "fv1", value: [] }

		},

		points: {

			"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
			"size" : { type: "f", value: 1.0 },
			"scale" : { type: "f", value: 1.0 },
			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

		},

		shadowmap: {

			"shadowMap": { type: "tv", value: [] },
			"shadowMapSize": { type: "v2v", value: [] },

			"shadowBias" : { type: "fv1", value: [] },
			"shadowDarkness": { type: "fv1", value: [] },

			"shadowMatrix" : { type: "m4v", value: [] }

		}

	};

	// File:src/renderers/shaders/ShaderLib.js

	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */


	THREE.ShaderLib = {

		'basic': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "shadowmap" ]

			] ),

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],

				"	#ifdef USE_ENVMAP",

					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"	#endif",

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	vec3 totalAmbientLight = vec3( 1.0 );", // hardwired

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "aomap_fragment" ],

				"	outgoingLight = diffuseColor.rgb * totalAmbientLight;", // simple shader

					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],		// TODO: Shadows on an otherwise unlit surface doesn't make sense.

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'lambert': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
				}

			] ),

			vertexShader: [

				"#define LAMBERT",

				"varying vec3 vLightFront;",

				"#ifdef DOUBLE_SIDED",

				"	varying vec3 vLightBack;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],

					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform float opacity;",

				"varying vec3 vLightFront;",

				"#ifdef DOUBLE_SIDED",

				"	varying vec3 vLightBack;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],

				"	#ifdef DOUBLE_SIDED",

				"		if ( gl_FrontFacing )",
				"			outgoingLight += diffuseColor.rgb * vLightFront + emissive;",
				"		else",
				"			outgoingLight += diffuseColor.rgb * vLightBack + emissive;",

				"	#else",

				"		outgoingLight += diffuseColor.rgb * vLightFront + emissive;",

				"	#endif",

					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'phong': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "lightmap" ],
				THREE.UniformsLib[ "emissivemap" ],
				THREE.UniformsLib[ "bumpmap" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "displacementmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
					"shininess": { type: "f", value: 30 }
				}

			] ),

			vertexShader: [

				"#define PHONG",

				"varying vec3 vViewPosition;",

				"#ifndef FLAT_SHADED",

				"	varying vec3 vNormal;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],

					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

				"	vNormal = normalize( transformedNormal );",

				"#endif",

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "displacementmap_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"	vViewPosition = - mvPosition.xyz;",

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_phong_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"#define PHONG",

				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform vec3 specular;",
				"uniform float shininess;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	vec3 totalAmbientLight = ambientLightColor;",
				"	vec3 totalEmissiveLight = emissive;",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "aomap_fragment" ],
					THREE.ShaderChunk[ "emissivemap_fragment" ],

					THREE.ShaderChunk[ "lights_phong_fragment" ],

					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'points': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "points" ],
				THREE.UniformsLib[ "shadowmap" ]

			] ),

			vertexShader: [

				"uniform float size;",
				"uniform float scale;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "color_vertex" ],

				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				"	#ifdef USE_SIZEATTENUATION",
				"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"	#else",
				"		gl_PointSize = size;",
				"	#endif",

				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 psColor;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_particle_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( psColor, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_particle_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],

				"	outgoingLight = diffuseColor.rgb;", // simple shader

					THREE.ShaderChunk[ "shadowmap_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'dashed': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],

				{
					"scale"    : { type: "f", value: 1 },
					"dashSize" : { type: "f", value: 1 },
					"totalSize": { type: "f", value: 2 }
				}

			] ),

			vertexShader: [

				"uniform float scale;",
				"attribute float lineDistance;",

				"varying float vLineDistance;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "color_vertex" ],

				"	vLineDistance = scale * lineDistance;",

				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				"uniform float dashSize;",
				"uniform float totalSize;",

				"varying float vLineDistance;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

				"		discard;",

				"	}",

				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],

				"	outgoingLight = diffuseColor.rgb;", // simple shader

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'depth': {

			uniforms: {

				"mNear": { type: "f", value: 1.0 },
				"mFar" : { type: "f", value: 2000.0 },
				"opacity" : { type: "f", value: 1.0 }

			},

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform float mNear;",
				"uniform float mFar;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	#ifdef USE_LOGDEPTHBUF_EXT",

				"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

				"	#else",

				"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

				"	#endif",

				"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"	gl_FragColor = vec4( vec3( color ), opacity );",

				"}"

			].join( "\n" )

		},

		'normal': {

			uniforms: {

				"opacity" : { type: "f", value: 1.0 }

			},

			vertexShader: [

				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vNormal = normalize( normalMatrix * normal );",

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform float opacity;",
				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join( "\n" )

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'cube': {

			uniforms: { "tCube": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },

			vertexShader: [

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vWorldPosition = transformDirection( position, modelMatrix );",

				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform samplerCube tCube;",
				"uniform float tFlip;",

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join( "\n" )

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'equirect': {

			uniforms: { "tEquirect": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },

			vertexShader: [

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vWorldPosition = transformDirection( position, modelMatrix );",

				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform sampler2D tEquirect;",
				"uniform float tFlip;",

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

					// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
					"vec3 direction = normalize( vWorldPosition );",
					"vec2 sampleUV;",
					"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
					"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
					"gl_FragColor = texture2D( tEquirect, sampleUV );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join( "\n" )

		},

		/* Depth encoding into RGBA texture
		 *
		 * based on SpiderGL shadow map example
		 * http://spidergl.org/example.php?id=6
		 *
		 * originally from
		 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
		 *
		 * see also
		 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
		 */

		'depthRGBA': {

			uniforms: {},

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "skinbase_vertex" ],

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"vec4 pack_depth( const in float depth ) {",

				"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
				"	res -= res.xxyz * bit_mask;",
				"	return res;",

				"}",

				"void main() {",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	#ifdef USE_LOGDEPTHBUF_EXT",

				"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

				"	#else",

				"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

				"	#endif",

					//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
					//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
					//"gl_FragData[ 0 ] = pack_depth( z );",
					//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

				"}"

			].join( "\n" )

		}

	};

	// File:src/renderers/WebGLRenderer.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.WebGLRenderer = function ( parameters ) {

		console.log( 'THREE.WebGLRenderer', THREE.REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,

		_width = _canvas.width,
		_height = _canvas.height,

		pixelRatio = 1,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0;

		var lights = [];

		var opaqueObjects = [];
		var opaqueObjectsLastIndex = -1;
		var transparentObjects = [];
		var transparentObjectsLastIndex = -1;

		var opaqueImmediateObjects = [];
		var opaqueImmediateObjectsLastIndex = -1;
		var transparentImmediateObjects = [];
		var transparentImmediateObjectsLastIndex = -1;

		var morphInfluences = new Float32Array( 8 );


		var sprites = [];
		var lensFlares = [];

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// flags

		this.autoScaleCubemaps = true;

		// internal properties

		var _this = this,

		// internal state cache

		_currentProgram = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,

		_usedTextureUnits = 0,

		_viewportX = 0,
		_viewportY = 0,
		_viewportWidth = _canvas.width,
		_viewportHeight = _canvas.height,
		_currentWidth = 0,
		_currentHeight = 0,

		// frustum

		_frustum = new THREE.Frustum(),

		 // camera matrices cache

		_projScreenMatrix = new THREE.Matrix4(),

		_vector3 = new THREE.Vector3(),

		// light arrays cache

		_direction = new THREE.Vector3(),

		_lightsNeedUpdate = true,

		_lights = {

			ambient: [ 0, 0, 0 ],
			directional: { length: 0, colors: [], positions: [] },
			point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
			spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
			hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

		},

		// info

		_infoMemory = {

			geometries: 0,
			textures: 0

		},

		_infoRender = {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		};

		this.info = {

			render: _infoRender,
			memory: _infoMemory,
			programs: null

		};


		// initialize

		var _gl;

		try {

			var attributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};

			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl' ) !== null ) {

					throw 'Error creating WebGL context with your selected attributes.';

				} else {

					throw 'Error creating WebGL context.';

				}

			}

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error );

		}

		var extensions = new THREE.WebGLExtensions( _gl );

		extensions.get( 'OES_texture_float' );
		extensions.get( 'OES_texture_float_linear' );
		extensions.get( 'OES_texture_half_float' );
		extensions.get( 'OES_texture_half_float_linear' );
		extensions.get( 'OES_standard_derivatives' );
		extensions.get( 'ANGLE_instanced_arrays' );

		if ( extensions.get( 'OES_element_index_uint' ) ) {

			THREE.BufferGeometry.MaxIndex = 4294967296;

		}

		var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

		var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
		var properties = new THREE.WebGLProperties();
		var objects = new THREE.WebGLObjects( _gl, properties, this.info );
		var programCache = new THREE.WebGLPrograms( this, capabilities );

		this.info.programs = programCache.programs;

		var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
		var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

		//

		function glClearColor( r, g, b, a ) {

			if ( _premultipliedAlpha === true ) {

				r *= a; g *= a; b *= a;

			}

			_gl.clearColor( r, g, b, a );

		}

		function setDefaultGLState() {

			state.init();

			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		}

		function resetGLState() {

			_currentProgram = null;
			_currentCamera = null;

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;

			_lightsNeedUpdate = true;

			state.reset();

		}

		setDefaultGLState();

		this.context = _gl;
		this.capabilities = capabilities;
		this.extensions = extensions;
		this.state = state;

		// shadow map

		var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

		this.shadowMap = shadowMap;


		// Plugins

		var spritePlugin = new THREE.SpritePlugin( this, sprites );
		var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			extensions.get( 'WEBGL_lose_context' ).loseContext();

		};

		this.getMaxAnisotropy = ( function () {

			var value;

			return function getMaxAnisotropy() {

				if ( value !== undefined ) return value;

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( extension !== null ) {

					value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

				} else {

					value = 0;

				}

				return value;

			}

		} )();

		this.getPrecision = function () {

			return capabilities.precision;

		};

		this.getPixelRatio = function () {

			return pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value !== undefined ) pixelRatio = value;

		};

		this.getSize = function () {

			return {
				width: _width,
				height: _height
			};

		};

		this.setSize = function ( width, height, updateStyle ) {

			_width = width;
			_height = height;

			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.setViewport = function ( x, y, width, height ) {

			_viewportX = x * pixelRatio;
			_viewportY = y * pixelRatio;

			_viewportWidth = width * pixelRatio;
			_viewportHeight = height * pixelRatio;

			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		};

		this.setScissor = function ( x, y, width, height ) {

			_gl.scissor(
				x * pixelRatio,
				y * pixelRatio,
				width * pixelRatio,
				height * pixelRatio
			);

		};

		this.enableScissorTest = function ( boolean ) {

			state.setScissorTest( boolean );

		};

		// Clearing

		this.getClearColor = function () {

			return _clearColor;

		};

		this.setClearColor = function ( color, alpha ) {

			_clearColor.set( color );

			_clearAlpha = alpha !== undefined ? alpha : 1;

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		this.getClearAlpha = function () {

			return _clearAlpha;

		};

		this.setClearAlpha = function ( alpha ) {

			_clearAlpha = alpha;

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			_gl.clear( _gl.COLOR_BUFFER_BIT );

		};

		this.clearDepth = function () {

			_gl.clear( _gl.DEPTH_BUFFER_BIT );

		};

		this.clearStencil = function () {

			_gl.clear( _gl.STENCIL_BUFFER_BIT );

		};

		this.clearTarget = function ( renderTarget, color, depth, stencil ) {

			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		};

		// Reset

		this.resetGLState = resetGLState;

		this.dispose = function() {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			resetGLState();
			setDefaultGLState();

			properties.clear();

		};

		function onTextureDispose( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			_infoMemory.textures --;


		}

		function onRenderTargetDispose( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			_infoMemory.textures --;

		}

		function onMaterialDispose( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateTexture( texture ) {

			var textureProperties = properties.get( texture );

			if ( texture.image && textureProperties.__image__webglTextureCube ) {

				// cube texture

				_gl.deleteTexture( textureProperties.__image__webglTextureCube );

			} else {

				// 2D texture

				if ( textureProperties.__webglInit === undefined ) return;

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			// remove all webgl properties
			properties.delete( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			if ( ! renderTarget || renderTargetProperties.__webglTexture === undefined ) return;

			_gl.deleteTexture( renderTargetProperties.__webglTexture );

			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );

			}

			properties.delete( renderTarget );

		}

		function deallocateMaterial( material ) {

			releaseMaterialProgramReference( material );

			properties.delete( material );

		}


		function releaseMaterialProgramReference( material ) {

			var programInfo = properties.get( material ).program;

			material.program = undefined;

			if ( programInfo !== undefined ) {

				programCache.releaseProgram( programInfo );
			}

		}

		// Buffer rendering

		this.renderBufferImmediate = function ( object, program, material ) {

			state.initAttributes();

			var buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

			var attributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

				if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {

					for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

						var array = object.normalArray;

						var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
						var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
						var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

						array[ i + 0 ] = nx;
						array[ i + 1 ] = ny;
						array[ i + 2 ] = nz;

						array[ i + 3 ] = nx;
						array[ i + 4 ] = ny;
						array[ i + 5 ] = nz;

						array[ i + 6 ] = nx;
						array[ i + 7 ] = ny;
						array[ i + 8 ] = nz;

					}

				}

				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( attributes.normal );

				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasUvs && material.map ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( attributes.uv );

				_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( attributes.color );

				_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			state.disableUnusedAttributes();

			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

			object.count = 0;

		};

		this.renderBufferDirect = function ( camera, lights, fog, geometry, material, object, group ) {

			setMaterial( material );

			var program = setProgram( camera, lights, fog, material, object );

			var updateBuffers = false;
			var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

			if ( geometryProgram !== _currentGeometryProgram ) {

				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;

			}

			// morph targets

			var morphTargetInfluences = object.morphTargetInfluences;

			if ( morphTargetInfluences !== undefined ) {

				var activeInfluences = [];

				for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

					var influence = morphTargetInfluences[ i ];
					activeInfluences.push( [ influence, i ] );

				}

				activeInfluences.sort( numericalSort );

				if ( activeInfluences.length > 8 ) {

					activeInfluences.length = 8;

				}

				var morphAttributes = geometry.morphAttributes;

				for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

					var influence = activeInfluences[ i ];
					morphInfluences[ i ] = influence[ 0 ];

					if ( influence[ 0 ] !== 0 ) {

						var index = influence[ 1 ];

						if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
						if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

					} else {

						if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
						if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

					}

				}

				var uniforms = program.getUniforms();

				if ( uniforms.morphTargetInfluences !== null ) {

					_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

				}

				updateBuffers = true;

			}

			//

			var index = geometry.index;
			var position = geometry.attributes.position;

			if ( material.wireframe === true ) {

				index = objects.getWireframeAttribute( geometry );

			}

			var renderer;

			if ( index !== null ) {

				renderer = indexedBufferRenderer;
				renderer.setIndex( index );

			} else {

				renderer = bufferRenderer;

			}

			if ( updateBuffers ) {

				setupVertexAttributes( material, program, geometry );

				if ( index !== null ) {

					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

				}

			}

			if ( group === undefined ) {

				var count;

				if ( index !== null ) {

					count = index.array.length;

				} else {

					count = position.count;

				}

				var drawRange = geometry.drawRange;

				group = {
					start: drawRange.start,
					count: Math.min( drawRange.count, count )
				};

			}

			if ( object instanceof THREE.Mesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * pixelRatio );
					renderer.setMode( _gl.LINES );

				} else {

					renderer.setMode( _gl.TRIANGLES );

				}

				if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

					renderer.renderInstances( geometry );

				} else {

					renderer.render( group.start, group.count );

				}

			} else if ( object instanceof THREE.Line ) {

				var lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * pixelRatio );

				if ( object instanceof THREE.LineSegments ) {

					renderer.setMode( _gl.LINES );

				} else {

					renderer.setMode( _gl.LINE_STRIP );

				}

				renderer.render( group.start, group.count );

			} else if ( object instanceof THREE.Points ) {

				renderer.setMode( _gl.POINTS );
				renderer.render( group.start, group.count );

			}

		};

		function setupVertexAttributes( material, program, geometry, startIndex ) {

			var extension;

			if ( geometry instanceof THREE.InstancedBufferGeometry ) {

				extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			if ( startIndex === undefined ) startIndex = 0;

			state.initAttributes();

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.getAttributes();

			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( var name in programAttributes ) {

				var programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						state.enableAttribute( programAttribute );

						var size = geometryAttribute.itemSize;
						var buffer = objects.getAttributeBuffer( geometryAttribute );

						if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

							if ( data instanceof THREE.InstancedInterleavedBuffer ) {

								if ( extension === null ) {

									console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
									return;

								}

								extension.vertexAttribDivisorANGLE( programAttribute, data.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = data.meshPerAttribute * data.count;

								}

							}

						} else {

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

							if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

								if ( extension === null ) {

									console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
									return;

								}

								extension.vertexAttribDivisorANGLE( programAttribute, geometryAttribute.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							}

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						var value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									_gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		// Sorting

		function numericalSort ( a, b ) {

			return b[ 0 ] - a[ 0 ];

		}

		function painterSortStable ( a, b ) {

			if ( a.object.renderOrder !== b.object.renderOrder ) {

				return a.object.renderOrder - b.object.renderOrder;

			} else if ( a.material.id !== b.material.id ) {

				return a.material.id - b.material.id;

			} else if ( a.z !== b.z ) {

				return a.z - b.z;

			} else {

				return a.id - b.id;

			}

		}

		function reversePainterSortStable ( a, b ) {

			if ( a.object.renderOrder !== b.object.renderOrder ) {

				return a.object.renderOrder - b.object.renderOrder;

			} if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return a.id - b.id;

			}

		}

		// Rendering

		this.render = function ( scene, camera, renderTarget, forceClear ) {

			if ( camera instanceof THREE.Camera === false ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			var fog = scene.fog;

			// reset caching for this frame

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;
			_lightsNeedUpdate = true;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			camera.matrixWorldInverse.getInverse( camera.matrixWorld );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			lights.length = 0;

			opaqueObjectsLastIndex = -1;
			transparentObjectsLastIndex = -1;

			opaqueImmediateObjectsLastIndex = -1;
			transparentImmediateObjectsLastIndex = -1;

			sprites.length = 0;
			lensFlares.length = 0;

			projectObject( scene );

			opaqueObjects.length = opaqueObjectsLastIndex + 1;
			transparentObjects.length = transparentObjectsLastIndex + 1;

			opaqueImmediateObjects.length = opaqueImmediateObjectsLastIndex + 1;
			transparentImmediateObjects.length = transparentImmediateObjectsLastIndex + 1;

			if ( _this.sortObjects === true ) {

				opaqueObjects.sort( painterSortStable );
				transparentObjects.sort( reversePainterSortStable );

			}

			//

			shadowMap.render( scene, camera );

			//

			_infoRender.calls = 0;
			_infoRender.vertices = 0;
			_infoRender.faces = 0;
			_infoRender.points = 0;

			this.setRenderTarget( renderTarget );

			if ( this.autoClear || forceClear ) {

				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

			}

			//

			if ( scene.overrideMaterial ) {

				var overrideMaterial = scene.overrideMaterial;

				renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
				renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );

				renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog, overrideMaterial );
				renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog, overrideMaterial );

			} else {

				// opaque pass (front-to-back order)

				state.setBlending( THREE.NoBlending );

				renderObjects( opaqueObjects, camera, lights, fog );
				renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog );

				// transparent pass (back-to-front order)

				renderObjects( transparentObjects, camera, lights, fog );
				renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog );

			}

			// custom render plugins (post pass)

			spritePlugin.render( scene, camera );
			lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

			// Generate mipmap if we're using any kind of mipmap filtering

			if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

				updateRenderTargetMipmap( renderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.setDepthTest( true );
			state.setDepthWrite( true );
			state.setColorWrite( true );

			// _gl.finish();

		};

		function pushImmediateRenderItem( object ) {

			var array, index;

			// allocate the next position in the appropriate array

			if ( object.material.transparent ) {

				array = transparentImmediateObjects;
				index = ++ transparentImmediateObjectsLastIndex;

			} else {

				array = opaqueImmediateObjects;
				index = ++ opaqueImmediateObjectsLastIndex;

			}

			// recycle existing position or grow the array

			if ( index < array.length ) {

				array[ index ] = object;

			} else {

				// assert( index === array.length );
				array.push( object );

			}


		}

		function pushRenderItem( object, geometry, material, z, group ) {

			var array, index;

			// allocate the next position in the appropriate array

			if ( material.transparent ) {

				array = transparentObjects;
				index = ++ transparentObjectsLastIndex;

			} else {

				array = opaqueObjects;
				index = ++ opaqueObjectsLastIndex;

			}

			// recycle existing render item or grow the array

			var renderItem = array[ index ];

			if ( renderItem !== undefined ) {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.z = _vector3.z;
				renderItem.group = group;

			} else {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					z: _vector3.z,
					group: group
				};

				// assert( index === array.length );
				array.push( renderItem );

			}

		}

		function projectObject( object ) {

			if ( object.visible === false ) return;

			if ( object instanceof THREE.Light ) {

				lights.push( object );

			} else if ( object instanceof THREE.Sprite ) {

				sprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				lensFlares.push( object );

			} else if ( object instanceof THREE.ImmediateRenderObject ) {

				pushImmediateRenderItem( object );

			} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

				if ( object instanceof THREE.SkinnedMesh ) {

					object.skeleton.update();

				}

				if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

					var material = object.material;

					if ( material.visible === true ) {

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

						}

						var geometry = objects.update( object );

						if ( material instanceof THREE.MeshFaceMaterial ) {

							var groups = geometry.groups;
							var materials = material.materials;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = materials[ group.materialIndex ];

								if ( groupMaterial.visible === true ) {

									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else {

							pushRenderItem( object, geometry, material, _vector3.z );

						}

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ] );

			}

		}

		function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var renderItem = renderList[ i ];

				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

				_this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );

			}

		}

		function renderObjectsImmediate( renderList, camera, lights, fog, overrideMaterial ) {

			var material = overrideMaterial;

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var object = renderList[ i ];

				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

				if ( overrideMaterial === undefined ) material = object.material;

				setMaterial( material );

				var program = setProgram( camera, lights, fog, material, object );

				_currentGeometryProgram = '';

				object.render( function ( object ) {

					_this.renderBufferImmediate( object, program, material );

				} );

			}

		}

		function initMaterial( material, lights, fog, object ) {

			var materialProperties = properties.get( material );

			var parameters = programCache.getParameters( material, lights, fog, object );
			var code = programCache.getProgramCode( material, parameters );

			var program = materialProperties.program;
			var programChange = true;

			if ( program === undefined ) {

				// new material
				material.addEventListener( 'dispose', onMaterialDispose );

			} else if ( program.code !== code ) {

				// changed glsl or parameters
				releaseMaterialProgramReference( material );

			} else if ( parameters.shaderID !== undefined ) {

				// same glsl and uniform list
				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if ( programChange ) {

				if ( parameters.shaderID ) {

					var shader = THREE.ShaderLib[ parameters.shaderID ];

					materialProperties.__webglShader = {
						name: material.type,
						uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};

				} else {

					materialProperties.__webglShader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};

				}

				material.__webglShader = materialProperties.__webglShader;

				program = programCache.acquireProgram( material, parameters, code );

				materialProperties.program = program;
				material.program = program;

			}

			var attributes = program.getAttributes();

			if ( material.morphTargets ) {

				material.numSupportedMorphTargets = 0;

				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

					if ( attributes[ 'morphTarget' + i ] >= 0 ) {

						material.numSupportedMorphTargets ++;

					}

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

					if ( attributes[ 'morphNormal' + i ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			materialProperties.uniformsList = [];

			var uniformLocations = materialProperties.program.getUniforms();

			for ( var u in materialProperties.__webglShader.uniforms ) {

				var location = uniformLocations[ u ];

				if ( location ) {

					materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

				}

			}

		}

		function setMaterial( material ) {

			setMaterialFaces( material );

			if ( material.transparent === true ) {

				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

			} else {

				state.setBlending( THREE.NoBlending );

			}

			state.setDepthFunc( material.depthFunc );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );
			state.setColorWrite( material.colorWrite );
			state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		function setMaterialFaces( material ) {

			material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
			state.setFlipSided( material.side === THREE.BackSide );

		}

		function setProgram( camera, lights, fog, material, object ) {

			_usedTextureUnits = 0;

			var materialProperties = properties.get( material );

			if ( material.needsUpdate || ! materialProperties.program ) {

				initMaterial( material, lights, fog, object );
				material.needsUpdate = false;

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.__webglShader.uniforms;

			if ( program.id !== _currentProgram ) {

				_gl.useProgram( program.program );
				_currentProgram = program.id;

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				if ( _currentMaterialId === - 1 ) refreshLights = true;
				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || camera !== _currentCamera ) {

				_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

				if ( capabilities.logarithmicDepthBuffer ) {

					_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}


				if ( camera !== _currentCamera ) _currentCamera = camera;

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material.envMap ) {

					if ( p_uniforms.cameraPosition !== undefined ) {

						_vector3.setFromMatrixPosition( camera.matrixWorld );
						_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

					}

				}

				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {

					if ( p_uniforms.viewMatrix !== undefined ) {

						_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

					}

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if ( material.skinning ) {

				if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

					_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

				}

				if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

					_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

				}

				if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {

					if ( p_uniforms.boneTexture !== undefined ) {

						var textureUnit = getTextureUnit();

						_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
						_this.setTexture( object.skeleton.boneTexture, textureUnit );

					}

					if ( p_uniforms.boneTextureWidth !== undefined ) {

						_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

					}

					if ( p_uniforms.boneTextureHeight !== undefined ) {

						_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

					}

				} else if ( object.skeleton && object.skeleton.boneMatrices ) {

					if ( p_uniforms.boneGlobalMatrices !== undefined ) {

						_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

					}

				}

			}

			if ( refreshMaterial ) {

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material.lights ) {

					if ( _lightsNeedUpdate ) {

						refreshLights = true;
						setupLights( lights, camera );
						_lightsNeedUpdate = false;

					}

					if ( refreshLights ) {

						refreshUniformsLights( m_uniforms, _lights );
						markUniformsLightsNeedsUpdate( m_uniforms, true );

					} else {

						markUniformsLightsNeedsUpdate( m_uniforms, false );

					}

				}

				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				}

				// refresh single material specific uniforms

				if ( material instanceof THREE.LineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

				} else if ( material instanceof THREE.LineDashedMaterial ) {

					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );

				} else if ( material instanceof THREE.PointsMaterial ) {

					refreshUniformsParticle( m_uniforms, material );

				} else if ( material instanceof THREE.MeshPhongMaterial ) {

					refreshUniformsPhong( m_uniforms, material );

				} else if ( material instanceof THREE.MeshDepthMaterial ) {

					m_uniforms.mNear.value = camera.near;
					m_uniforms.mFar.value = camera.far;
					m_uniforms.opacity.value = material.opacity;

				} else if ( material instanceof THREE.MeshNormalMaterial ) {

					m_uniforms.opacity.value = material.opacity;

				}

				if ( object.receiveShadow && ! material._shadowPass ) {

					refreshUniformsShadow( m_uniforms, lights );

				}

				// load common uniforms

				loadUniformsGeneric( materialProperties.uniformsList );

			}

			loadUniformsMatrices( p_uniforms, object );

			if ( p_uniforms.modelMatrix !== undefined ) {

				_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

			}

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon ( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			uniforms.diffuse.value = material.color;

			if ( material.emissive ) {

				uniforms.emissive.value = material.emissive;

			}

			uniforms.map.value = material.map;
			uniforms.specularMap.value = material.specularMap;
			uniforms.alphaMap.value = material.alphaMap;

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			}

			if ( uvScaleMap !== undefined ) {

				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;

				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

			}

			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

		}

		function refreshUniformsLine ( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash ( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsParticle ( uniforms, material ) {

			uniforms.psColor.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size;
			uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				var offset = material.map.offset;
				var repeat = material.map.repeat;

				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

			}

		}

		function refreshUniformsFog ( uniforms, fog ) {

			uniforms.fogColor.value = fog.color;

			if ( fog instanceof THREE.Fog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog instanceof THREE.FogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsPhong ( uniforms, material ) {

			uniforms.specular.value = material.specular;
			uniforms.shininess.value = material.shininess;

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsLights ( uniforms, lights ) {

			uniforms.ambientLightColor.value = lights.ambient;

			uniforms.directionalLightColor.value = lights.directional.colors;
			uniforms.directionalLightDirection.value = lights.directional.positions;

			uniforms.pointLightColor.value = lights.point.colors;
			uniforms.pointLightPosition.value = lights.point.positions;
			uniforms.pointLightDistance.value = lights.point.distances;
			uniforms.pointLightDecay.value = lights.point.decays;

			uniforms.spotLightColor.value = lights.spot.colors;
			uniforms.spotLightPosition.value = lights.spot.positions;
			uniforms.spotLightDistance.value = lights.spot.distances;
			uniforms.spotLightDirection.value = lights.spot.directions;
			uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
			uniforms.spotLightExponent.value = lights.spot.exponents;
			uniforms.spotLightDecay.value = lights.spot.decays;

			uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
			uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
			uniforms.hemisphereLightDirection.value = lights.hemi.positions;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate ( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLightColor.needsUpdate = value;
			uniforms.directionalLightDirection.needsUpdate = value;

			uniforms.pointLightColor.needsUpdate = value;
			uniforms.pointLightPosition.needsUpdate = value;
			uniforms.pointLightDistance.needsUpdate = value;
			uniforms.pointLightDecay.needsUpdate = value;

			uniforms.spotLightColor.needsUpdate = value;
			uniforms.spotLightPosition.needsUpdate = value;
			uniforms.spotLightDistance.needsUpdate = value;
			uniforms.spotLightDirection.needsUpdate = value;
			uniforms.spotLightAngleCos.needsUpdate = value;
			uniforms.spotLightExponent.needsUpdate = value;
			uniforms.spotLightDecay.needsUpdate = value;

			uniforms.hemisphereLightSkyColor.needsUpdate = value;
			uniforms.hemisphereLightGroundColor.needsUpdate = value;
			uniforms.hemisphereLightDirection.needsUpdate = value;

		}

		function refreshUniformsShadow ( uniforms, lights ) {

			if ( uniforms.shadowMatrix ) {

				var j = 0;

				for ( var i = 0, il = lights.length; i < il; i ++ ) {

					var light = lights[ i ];

					if ( ! light.castShadow ) continue;

					if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight ) ) {

						uniforms.shadowMap.value[ j ] = light.shadowMap;
						uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

						uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

						uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
						uniforms.shadowBias.value[ j ] = light.shadowBias;

						j ++;

					}

				}

			}

		}

		// Uniforms (load to GPU)

		function loadUniformsMatrices ( uniforms, object ) {

			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

			if ( uniforms.normalMatrix ) {

				_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

			}

		}

		function getTextureUnit() {

			var textureUnit = _usedTextureUnits;

			if ( textureUnit >= capabilities.maxTextures ) {

				console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

			}

			_usedTextureUnits += 1;

			return textureUnit;

		}

		function loadUniformsGeneric ( uniforms ) {

			var texture, textureUnit;

			for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

				var uniform = uniforms[ j ][ 0 ];

				// needsUpdate property is not added to all uniforms.
				if ( uniform.needsUpdate === false ) continue;

				var type = uniform.type;
				var value = uniform.value;
				var location = uniforms[ j ][ 1 ];

				switch ( type ) {

					case '1i':
						_gl.uniform1i( location, value );
						break;

					case '1f':
						_gl.uniform1f( location, value );
						break;

					case '2f':
						_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
						break;

					case '3f':
						_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
						break;

					case '4f':
						_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
						break;

					case '1iv':
						_gl.uniform1iv( location, value );
						break;

					case '3iv':
						_gl.uniform3iv( location, value );
						break;

					case '1fv':
						_gl.uniform1fv( location, value );
						break;

					case '2fv':
						_gl.uniform2fv( location, value );
						break;

					case '3fv':
						_gl.uniform3fv( location, value );
						break;

					case '4fv':
						_gl.uniform4fv( location, value );
						break;

					case 'Matrix3fv':
						_gl.uniformMatrix3fv( location, false, value );
						break;

					case 'Matrix4fv':
						_gl.uniformMatrix4fv( location, false, value );
						break;

					//

					case 'i':

						// single integer
						_gl.uniform1i( location, value );

						break;

					case 'f':

						// single float
						_gl.uniform1f( location, value );

						break;

					case 'v2':

						// single THREE.Vector2
						_gl.uniform2f( location, value.x, value.y );

						break;

					case 'v3':

						// single THREE.Vector3
						_gl.uniform3f( location, value.x, value.y, value.z );

						break;

					case 'v4':

						// single THREE.Vector4
						_gl.uniform4f( location, value.x, value.y, value.z, value.w );

						break;

					case 'c':

						// single THREE.Color
						_gl.uniform3f( location, value.r, value.g, value.b );

						break;

					case 'iv1':

						// flat array of integers (JS or typed array)
						_gl.uniform1iv( location, value );

						break;

					case 'iv':

						// flat array of integers with 3 x N size (JS or typed array)
						_gl.uniform3iv( location, value );

						break;

					case 'fv1':

						// flat array of floats (JS or typed array)
						_gl.uniform1fv( location, value );

						break;

					case 'fv':

						// flat array of floats with 3 x N size (JS or typed array)
						_gl.uniform3fv( location, value );

						break;

					case 'v2v':

						// array of THREE.Vector2

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 2 * value.length );

						}

						for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {

							uniform._array[ i2 + 0 ] = value[ i ].x;
							uniform._array[ i2 + 1 ] = value[ i ].y;

						}

						_gl.uniform2fv( location, uniform._array );

						break;

					case 'v3v':

						// array of THREE.Vector3

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 3 * value.length );

						}

						for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {

							uniform._array[ i3 + 0 ] = value[ i ].x;
							uniform._array[ i3 + 1 ] = value[ i ].y;
							uniform._array[ i3 + 2 ] = value[ i ].z;

						}

						_gl.uniform3fv( location, uniform._array );

						break;

					case 'v4v':

						// array of THREE.Vector4

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 4 * value.length );

						}

						for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {

							uniform._array[ i4 + 0 ] = value[ i ].x;
							uniform._array[ i4 + 1 ] = value[ i ].y;
							uniform._array[ i4 + 2 ] = value[ i ].z;
							uniform._array[ i4 + 3 ] = value[ i ].w;

						}

						_gl.uniform4fv( location, uniform._array );

						break;

					case 'm3':

						// single THREE.Matrix3
						_gl.uniformMatrix3fv( location, false, value.elements );

						break;

					case 'm3v':

						// array of THREE.Matrix3

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 9 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

						}

						_gl.uniformMatrix3fv( location, false, uniform._array );

						break;

					case 'm4':

						// single THREE.Matrix4
						_gl.uniformMatrix4fv( location, false, value.elements );

						break;

					case 'm4v':

						// array of THREE.Matrix4

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 16 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

						}

						_gl.uniformMatrix4fv( location, false, uniform._array );

						break;

					case 't':

						// single THREE.Texture (2d or cube)

						texture = value;
						textureUnit = getTextureUnit();

						_gl.uniform1i( location, textureUnit );

						if ( ! texture ) continue;

						if ( texture instanceof THREE.CubeTexture ||
							 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

							// CompressedTexture can have Array in image :/

							setCubeTexture( texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

							setCubeTextureDynamic( texture, textureUnit );

						} else {

							_this.setTexture( texture, textureUnit );

						}

						break;

					case 'tv':

						// array of THREE.Texture (2d)

						if ( uniform._array === undefined ) {

							uniform._array = [];

						}

						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

							uniform._array[ i ] = getTextureUnit();

						}

						_gl.uniform1iv( location, uniform._array );

						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

							texture = uniform.value[ i ];
							textureUnit = uniform._array[ i ];

							if ( ! texture ) continue;

							_this.setTexture( texture, textureUnit );

						}

						break;

					default:

						console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

				}

			}

		}

		function setColorLinear( array, offset, color, intensity ) {

			array[ offset + 0 ] = color.r * intensity;
			array[ offset + 1 ] = color.g * intensity;
			array[ offset + 2 ] = color.b * intensity;

		}

		function setupLights ( lights, camera ) {

			var l, ll, light,
			r = 0, g = 0, b = 0,
			color, skyColor, groundColor,
			intensity,
			distance,

			zlights = _lights,

			viewMatrix = camera.matrixWorldInverse,

			dirColors = zlights.directional.colors,
			dirPositions = zlights.directional.positions,

			pointColors = zlights.point.colors,
			pointPositions = zlights.point.positions,
			pointDistances = zlights.point.distances,
			pointDecays = zlights.point.decays,

			spotColors = zlights.spot.colors,
			spotPositions = zlights.spot.positions,
			spotDistances = zlights.spot.distances,
			spotDirections = zlights.spot.directions,
			spotAnglesCos = zlights.spot.anglesCos,
			spotExponents = zlights.spot.exponents,
			spotDecays = zlights.spot.decays,

			hemiSkyColors = zlights.hemi.skyColors,
			hemiGroundColors = zlights.hemi.groundColors,
			hemiPositions = zlights.hemi.positions,

			dirLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0,

			dirCount = 0,
			pointCount = 0,
			spotCount = 0,
			hemiCount = 0,

			dirOffset = 0,
			pointOffset = 0,
			spotOffset = 0,
			hemiOffset = 0;

			for ( l = 0, ll = lights.length; l < ll; l ++ ) {

				light = lights[ l ];

				if ( light.onlyShadow ) continue;

				color = light.color;
				intensity = light.intensity;
				distance = light.distance;

				if ( light instanceof THREE.AmbientLight ) {

					if ( ! light.visible ) continue;

					r += color.r;
					g += color.g;
					b += color.b;

				} else if ( light instanceof THREE.DirectionalLight ) {

					dirCount += 1;

					if ( ! light.visible ) continue;

					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.transformDirection( viewMatrix );

					dirOffset = dirLength * 3;

					dirPositions[ dirOffset + 0 ] = _direction.x;
					dirPositions[ dirOffset + 1 ] = _direction.y;
					dirPositions[ dirOffset + 2 ] = _direction.z;

					setColorLinear( dirColors, dirOffset, color, intensity );

					dirLength += 1;

				} else if ( light instanceof THREE.PointLight ) {

					pointCount += 1;

					if ( ! light.visible ) continue;

					pointOffset = pointLength * 3;

					setColorLinear( pointColors, pointOffset, color, intensity );

					_vector3.setFromMatrixPosition( light.matrixWorld );
					_vector3.applyMatrix4( viewMatrix );

					pointPositions[ pointOffset + 0 ] = _vector3.x;
					pointPositions[ pointOffset + 1 ] = _vector3.y;
					pointPositions[ pointOffset + 2 ] = _vector3.z;

					// distance is 0 if decay is 0, because there is no attenuation at all.
					pointDistances[ pointLength ] = distance;
					pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

					pointLength += 1;

				} else if ( light instanceof THREE.SpotLight ) {

					spotCount += 1;

					if ( ! light.visible ) continue;

					spotOffset = spotLength * 3;

					setColorLinear( spotColors, spotOffset, color, intensity );

					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.copy( _direction ).applyMatrix4( viewMatrix );

					spotPositions[ spotOffset + 0 ] = _vector3.x;
					spotPositions[ spotOffset + 1 ] = _vector3.y;
					spotPositions[ spotOffset + 2 ] = _vector3.z;

					spotDistances[ spotLength ] = distance;

					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.transformDirection( viewMatrix );

					spotDirections[ spotOffset + 0 ] = _direction.x;
					spotDirections[ spotOffset + 1 ] = _direction.y;
					spotDirections[ spotOffset + 2 ] = _direction.z;

					spotAnglesCos[ spotLength ] = Math.cos( light.angle );
					spotExponents[ spotLength ] = light.exponent;
					spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

					spotLength += 1;

				} else if ( light instanceof THREE.HemisphereLight ) {

					hemiCount += 1;

					if ( ! light.visible ) continue;

					_direction.setFromMatrixPosition( light.matrixWorld );
					_direction.transformDirection( viewMatrix );

					hemiOffset = hemiLength * 3;

					hemiPositions[ hemiOffset + 0 ] = _direction.x;
					hemiPositions[ hemiOffset + 1 ] = _direction.y;
					hemiPositions[ hemiOffset + 2 ] = _direction.z;

					skyColor = light.color;
					groundColor = light.groundColor;

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

					hemiLength += 1;

				}

			}

			// null eventual remains from removed lights
			// (this is to avoid if in shader)

			for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
			for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
			for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

			zlights.directional.length = dirLength;
			zlights.point.length = pointLength;
			zlights.spot.length = spotLength;
			zlights.hemi.length = hemiLength;

			zlights.ambient[ 0 ] = r;
			zlights.ambient[ 1 ] = g;
			zlights.ambient[ 2 ] = b;

		}

		// GL state setting

		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

			if ( cullFace === THREE.CullFaceNone ) {

				state.disable( _gl.CULL_FACE );

			} else {

				if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

					_gl.frontFace( _gl.CW );

				} else {

					_gl.frontFace( _gl.CCW );

				}

				if ( cullFace === THREE.CullFaceBack ) {

					_gl.cullFace( _gl.BACK );

				} else if ( cullFace === THREE.CullFaceFront ) {

					_gl.cullFace( _gl.FRONT );

				} else {

					_gl.cullFace( _gl.FRONT_AND_BACK );

				}

				state.enable( _gl.CULL_FACE );

			}

		};

		// Textures

		function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

			var extension;

			if ( isImagePowerOfTwo ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );

				}

			}

			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension ) {

				if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				_infoMemory.textures ++;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

			var image = texture.image,
			isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture instanceof THREE.DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture instanceof THREE.CompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		this.setTexture = function ( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				var image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
					return;

				}

				if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
					return;

				}

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		};

		function clampToMaxSize ( image, maxSize ) {

			if ( image.width > maxSize || image.height > maxSize ) {

				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.

				var scale = maxSize / Math.max( image.width, image.height );

				var canvas = document.createElement( 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

				console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

				return canvas;

			}

			return image;

		}

		function setCubeTexture ( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.image.length === 6 ) {

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					if ( ! textureProperties.__image__webglTextureCube ) {

						texture.addEventListener( 'dispose', onTextureDispose );

						textureProperties.__image__webglTextureCube = _gl.createTexture();

						_infoMemory.textures ++;

					}

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

					var isCompressed = texture instanceof THREE.CompressedTexture;
					var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
					isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed ) {

							if ( isDataTexture ) {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

								mipmap = mipmaps[ j ];

								if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

									}

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

					if ( texture.generateMipmaps && isImagePowerOfTwo ) {

						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

					}

					textureProperties.__version = texture.version;

					if ( texture.onUpdate ) texture.onUpdate( texture );

				} else {

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				}

			}

		}

		function setCubeTextureDynamic ( texture, slot ) {

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

		}

		// Render targets

		function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget ).__webglTexture, 0 );

		}

		function setupRenderBuffer ( renderbuffer, renderTarget ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			/* For some reason this is not working. Defaulting to RGBA4.
			} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
			*/

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

			}

		}

		this.setRenderTarget = function ( renderTarget ) {

			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				var renderTargetProperties = properties.get( renderTarget );

				if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
				if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

				renderTargetProperties.__webglTexture = _gl.createTexture();

				_infoMemory.textures ++;

				// Setup texture, create render and frame buffers

				var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
					glFormat = paramThreeToGL( renderTarget.format ),
					glType = paramThreeToGL( renderTarget.type );

				if ( isCube ) {

					renderTargetProperties.__webglFramebuffer = [];
					renderTargetProperties.__webglRenderbuffer = [];

					state.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTargetProperties.__webglTexture );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
						renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

						state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

						setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
						setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );

					}

					if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				} else {

					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

					if ( renderTarget.shareDepthFrom ) {

						renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

					} else {

						renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();

					}

					state.bindTexture( _gl.TEXTURE_2D, renderTargetProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

					if ( renderTarget.shareDepthFrom ) {

						if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

						} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

						}

					} else {

						setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );

					}

					if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

				}

				// Release everything

				if ( isCube ) {

					state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

				} else {

					state.bindTexture( _gl.TEXTURE_2D, null );

				}

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

			var framebuffer, width, height, vx, vy;

			if ( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );

				if ( isCube ) {

					framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

				} else {

					framebuffer = renderTargetProperties.__webglFramebuffer;

				}

				width = renderTarget.width;
				height = renderTarget.height;

				vx = 0;
				vy = 0;

			} else {

				framebuffer = null;

				width = _viewportWidth;
				height = _viewportHeight;

				vx = _viewportX;
				vy = _viewportY;

			}

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.viewport( vx, vy, width, height );

				_currentFramebuffer = framebuffer;

			}

			_currentWidth = width;
			_currentHeight = height;

		};

		this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {

			if ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			if ( properties.get( renderTarget ).__webglFramebuffer ) {

				if ( renderTarget.format !== THREE.RGBAFormat ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );
					return;

				}

				var restore = false;

				if ( properties.get( renderTarget ).__webglFramebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, properties.get( renderTarget ).__webglFramebuffer );

					restore = true;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					_gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		};

		function updateRenderTargetMipmap ( renderTarget ) {

			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( renderTarget ).__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				state.bindTexture( _gl.TEXTURE_2D, properties.get( renderTarget ).__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_2D );
				state.bindTexture( _gl.TEXTURE_2D, null );

			}

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback ( f ) {

			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		// Map three.js constants to WebGL constants

		function paramThreeToGL ( p ) {

			var extension;

			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

			}

			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			}

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			}

			extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				if ( p === THREE.MinEquation ) return extension.MIN_EXT;
				if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

			}

			return 0;

		}

		// DEPRECATED

		this.supportsFloatTextures = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return extensions.get( 'OES_texture_float' );

		};

		this.supportsHalfFloatTextures = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return extensions.get( 'OES_texture_half_float' );

		};

		this.supportsStandardDerivatives = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return extensions.get( 'OES_standard_derivatives' );

		};

		this.supportsCompressedTextureS3TC = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return extensions.get( 'WEBGL_compressed_texture_s3tc' );

		};

		this.supportsCompressedTexturePVRTC = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		};

		this.supportsBlendMinMax = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return extensions.get( 'EXT_blend_minmax' );

		};

		this.supportsVertexTextures = function () {

			return capabilities.vertexTextures;

		};

		this.supportsInstancedArrays = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return extensions.get( 'ANGLE_instanced_arrays' );

		};

		//

		this.initMaterial = function () {

			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		};

		this.addPrePlugin = function () {

			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		};

		this.addPostPlugin = function () {

			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		};

		this.updateShadowMap = function () {

			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		};

		Object.defineProperties( this, {
			shadowMapEnabled: {
				get: function () {

					return shadowMap.enabled;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
					shadowMap.enabled = value;

				}
			},
			shadowMapType: {
				get: function () {

					return shadowMap.type;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
					shadowMap.type = value;

				}
			},
			shadowMapCullFace: {
				get: function () {

					return shadowMap.cullFace;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
					shadowMap.cullFace = value;

				}
			},
			shadowMapDebug: {
				get: function () {

					return shadowMap.debug;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
					shadowMap.debug = value;

				}
			}
		} );

	};

	// File:src/renderers/WebGLRenderTarget.js

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.WebGLRenderTarget = function ( width, height, options ) {

		this.uuid = THREE.Math.generateUUID();

		this.width = width;
		this.height = height;

		options = options || {};

		this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

		this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
		this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

		this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );

		this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
		this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

		this.generateMipmaps = true;

		this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

	};

	THREE.WebGLRenderTarget.prototype = {

		constructor: THREE.WebGLRenderTarget,

		setSize: function ( width, height ) {

			if ( this.width !== width || this.height !== height ) {

				this.width = width;
				this.height = height;

				this.dispose();

			}

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.width = source.width;
			this.height = source.height;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );

			this.format = source.format;
			this.type = source.type;

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;

			this.generateMipmaps = source.generateMipmaps;

			this.shareDepthFrom = source.shareDepthFrom;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

	// File:src/renderers/WebGLRenderTargetCube.js

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	THREE.WebGLRenderTargetCube = function ( width, height, options ) {

		THREE.WebGLRenderTarget.call( this, width, height, options );

		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

	};

	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
	THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

	// File:src/renderers/webgl/WebGLBufferRenderer.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			_gl.drawArrays( mode, start, count );

			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

		}

		function renderInstances( geometry ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			var position = geometry.attributes.position;

			if ( position instanceof THREE.InterleavedBufferAttribute ) {

				extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

			} else {

				extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

			}

		}

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	};

	// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		var type, size;

		function setIndex( index ) {

			if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

				type = _gl.UNSIGNED_INT;
				size = 4;

			} else {

				type = _gl.UNSIGNED_SHORT;
				size = 2;

			}

		}

		function render( start, count ) {

			_gl.drawElements( mode, count, type, start * size );

			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

		}

		function renderInstances( geometry ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			var index = geometry.index;

			extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );

		}

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	};

	// File:src/renderers/webgl/WebGLExtensions.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLExtensions = function ( gl ) {

		var extensions = {};

		this.get = function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[ name ] = extension;

			return extension;

		};

	};

	// File:src/renderers/webgl/WebGLCapabilities.js

	THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		this.getMaxPrecision = getMaxPrecision;

		this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
		this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

		this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

		this.vertexTextures = this.maxVertexTextures > 0;
		this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
		this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

		var _maxPrecision = getMaxPrecision( this.precision );

		if ( _maxPrecision !== this.precision ) {

			console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
			this.precision = _maxPrecision;

		}

		if ( this.logarithmicDepthBuffer ) {

			this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );

		}

	};

	// File:src/renderers/webgl/WebGLGeometries.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLGeometries = function ( gl, properties, info ) {

		var geometries = {};

		function get( object ) {

			var geometry = object.geometry;

			if ( geometries[ geometry.id ] !== undefined ) {

				return geometries[ geometry.id ];

			}

			geometry.addEventListener( 'dispose', onGeometryDispose );

			var buffergeometry;

			if ( geometry instanceof THREE.BufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry instanceof THREE.Geometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries[ geometry.id ] = buffergeometry;

			info.memory.geometries ++;

			return buffergeometry;

		}

		function onGeometryDispose( event ) {

			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];

			deleteAttributes( buffergeometry.attributes );

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			var property = properties.get( geometry );
			if ( property.wireframe ) deleteAttribute( property.wireframe );

			info.memory.geometries --;

		}

		function getAttributeBuffer( attribute ) {

			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

				return properties.get( attribute.data ).__webglBuffer;

			}

			return properties.get( attribute ).__webglBuffer;

		}

		function deleteAttribute( attribute ) {

			var buffer = getAttributeBuffer( attribute );

			if ( buffer !== undefined ) {

				gl.deleteBuffer( buffer );
				removeAttributeBuffer( attribute );

			}

		}

		function deleteAttributes( attributes ) {

			for ( var name in attributes ) {

				deleteAttribute( attributes[ name ] );

			}

		}

		function removeAttributeBuffer( attribute ) {

			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

				properties.delete( attribute.data );

			} else {

				properties.delete( attribute );

			}

		}

		this.get = get;

	};

	// File:src/renderers/webgl/WebGLObjects.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLObjects = function ( gl, properties, info ) {

		var geometries = new THREE.WebGLGeometries( gl, properties, info );

		//

		function update( object ) {

			// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

			var geometry = geometries.get( object );

			if ( object.geometry instanceof THREE.Geometry ) {

				geometry.updateFromObject( object );

			}

			var index = geometry.index;
			var attributes = geometry.attributes;

			if ( index !== null ) {

				updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

			}

			for ( var name in attributes ) {

				updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

			}

			// morph targets

			var morphAttributes = geometry.morphAttributes;

			for ( var name in morphAttributes ) {

				var array = morphAttributes[ name ];

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					updateAttribute( array[ i ], gl.ARRAY_BUFFER );

				}

			}

			return geometry;

		}

		function updateAttribute( attribute, bufferType ) {

			var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

			var attributeProperties = properties.get( data );

			if ( attributeProperties.__webglBuffer === undefined ) {

				createBuffer( attributeProperties, data, bufferType );

			} else if ( attributeProperties.version !== data.version ) {

				updateBuffer( attributeProperties, data, bufferType );

			}

		}

		function createBuffer( attributeProperties, data, bufferType ) {

			attributeProperties.__webglBuffer = gl.createBuffer();
			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

			var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

			gl.bufferData( bufferType, data.array, usage );

			attributeProperties.version = data.version;

		}

		function updateBuffer( attributeProperties, data, bufferType ) {

			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

			if ( data.dynamic === false || data.updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, data.array );

			} else if ( data.updateRange.count === 0 ) {

				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

			} else {

				gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
								  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

				data.updateRange.count = 0; // reset range

			}

			attributeProperties.version = data.version;

		}

		function getAttributeBuffer( attribute ) {

			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

				return properties.get( attribute.data ).__webglBuffer;

			}

			return properties.get( attribute ).__webglBuffer;

		}

		function getWireframeAttribute( geometry ) {

			var property = properties.get( geometry );

			if ( property.wireframe !== undefined ) {

				return property.wireframe;

			}

			var indices = [];

			var index = geometry.index;
			var attributes = geometry.attributes;
			var position = attributes.position;

			// console.time( 'wireframe' );

			if ( index !== null ) {

				var edges = {};
				var array = index.array;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];

					if ( checkEdge( edges, a, b ) ) indices.push( a, b );
					if ( checkEdge( edges, b, c ) ) indices.push( b, c );
					if ( checkEdge( edges, c, a ) ) indices.push( c, a );

				}

			} else {

				var array = attributes.position.array;

				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					var a = i + 0;
					var b = i + 1;
					var c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			// console.timeEnd( 'wireframe' );

			var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
			var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

			updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

			property.wireframe = attribute;

			return attribute;

		}

		function checkEdge( edges, a, b ) {

			if ( a > b ) {

				var tmp = a;
				a = b;
				b = tmp;

			}

			var list = edges[ a ];

			if ( list === undefined ) {

				edges[ a ] = [ b ];
				return true;

			} else if ( list.indexOf( b ) === -1 ) {

				list.push( b );
				return true;

			}

			return false;

		}

		this.getAttributeBuffer = getAttributeBuffer;
		this.getWireframeAttribute = getWireframeAttribute;

		this.update = update;

	};

	// File:src/renderers/webgl/WebGLProgram.js

	THREE.WebGLProgram = ( function () {

		var programIdCount = 0;

		function generateDefines( defines ) {

			var chunks = [];

			for ( var name in defines ) {

				var value = defines[ name ];

				if ( value === false ) continue;

				chunks.push( '#define ' + name + ' ' + value );

			}

			return chunks.join( '\n' );

		}

		function fetchUniformLocations( gl, program, identifiers ) {

			var uniforms = {};

			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

			for ( var i = 0; i < n; i ++ ) {

				var info = gl.getActiveUniform( program, i );
				var name = info.name;
				var location = gl.getUniformLocation( program, name );

				// console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

				var suffixPos = name.lastIndexOf( '[0]' );
				if ( suffixPos !== - 1 && suffixPos === name.length - 3 ) {

					uniforms[ name.substr( 0, suffixPos ) ] = location;

				}

				uniforms[ name ] = location;

			}

			return uniforms;

		}

		function fetchAttributeLocations( gl, program, identifiers ) {

			var attributes = {};

			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

			for ( var i = 0; i < n; i ++ ) {

				var info = gl.getActiveAttrib( program, i );
				var name = info.name;

				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

				attributes[ name ] = gl.getAttribLocation( program, name );

			}

			return attributes;

		}

		function filterEmptyLine( string ) {

			return string !== '';

		}

		return function WebGLProgram( renderer, code, material, parameters ) {

			var gl = renderer.context;

			var defines = material.defines;

			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;

			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

			}

			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

			if ( parameters.envMap ) {

				switch ( material.envMap.mapping ) {

					case THREE.CubeReflectionMapping:
					case THREE.CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;

					case THREE.EquirectangularReflectionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;

					case THREE.SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;

				}

				switch ( material.envMap.mapping ) {

					case THREE.CubeRefractionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;

				}

				switch ( material.combine ) {

					case THREE.MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;

					case THREE.MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;

					case THREE.AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;

				}

			}

			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

			// console.log( 'building new program ' );

			//

			var customDefines = generateDefines( defines );

			//

			var program = gl.createProgram();

			var prefixVertex, prefixFragment;

			if ( material instanceof THREE.RawShaderMaterial ) {

				prefixVertex = '';
				prefixFragment = '';

			} else {

				prefixVertex = [

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

					renderer.gammaInput ? '#define GAMMA_INPUT' : '',
					renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

					'#define MAX_SHADOWS ' + parameters.maxShadows,

					'#define MAX_BONES ' + parameters.maxBones,

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',

					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',

					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',

					'#ifdef USE_COLOR',

					'	attribute vec3 color;',

					'#endif',

					'#ifdef USE_MORPHTARGETS',

					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',

					'	#ifdef USE_MORPHNORMALS',

					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',

					'	#else',

					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',

					'	#endif',

					'#endif',

					'#ifdef USE_SKINNING',

					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',

					'#endif',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

				prefixFragment = [

					parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

					'#define MAX_SHADOWS ' + parameters.maxShadows,

					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

					renderer.gammaInput ? '#define GAMMA_INPUT' : '',
					renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.metal ? '#define METAL' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

			}

			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;

			var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );

			// Force a particular attribute to index 0.

			if ( material.index0AttributeName !== undefined ) {

				gl.bindAttribLocation( program, 0, material.index0AttributeName );

			} else if ( parameters.morphTargets === true ) {

				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );

			}

			gl.linkProgram( program );

			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

			var runnable = true;
			var haveDiagnostics = true;

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,
					material: material,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

			// clean up

			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );

			// set up caching for uniform locations

			var cachedUniforms;

			this.getUniforms = function() {

				if ( cachedUniforms === undefined ) {

					cachedUniforms = fetchUniformLocations( gl, program );

				}

				return cachedUniforms;

			};

			// set up caching for attribute locations

			var cachedAttributes;

			this.getAttributes = function() {

				if ( cachedAttributes === undefined ) {

					cachedAttributes = fetchAttributeLocations( gl, program );

				}

				return cachedAttributes;

			};

			// free resource

			this.destroy = function() {

				gl.deleteProgram( program );
				this.program = undefined;

			};

			// DEPRECATED

			Object.defineProperties( this, {

				uniforms: {
					get: function() {

						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();

					}
				},

				attributes: {
					get: function() {

						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();

					}
				}

			} );


			//

			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;

			return this;

		};

	} )();

	// File:src/renderers/webgl/WebGLPrograms.js

	THREE.WebGLPrograms = function ( renderer, capabilities ) {

		var programs = [];

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points'
		};

		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
			"lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "specularMap",
			"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights",
			"maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled",
			"shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided",
			"flipSided"
		];


		function allocateBones ( object ) {

			if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = nVertexMatrices;

				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

					maxBones = Math.min( object.skeleton.bones.length, maxBones );

					if ( maxBones < object.skeleton.bones.length ) {

						console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

					}

				}

				return maxBones;

			}

		}

		function allocateLights( lights ) {

			var dirLights = 0;
			var pointLights = 0;
			var spotLights = 0;
			var hemiLights = 0;

			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

				var light = lights[ l ];

				if ( light.onlyShadow || light.visible === false ) continue;

				if ( light instanceof THREE.DirectionalLight ) dirLights ++;
				if ( light instanceof THREE.PointLight ) pointLights ++;
				if ( light instanceof THREE.SpotLight ) spotLights ++;
				if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

			}

			return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

		}

		function allocateShadows( lights ) {

			var maxShadows = 0;

			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

				var light = lights[ l ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight ) maxShadows ++;
				if ( light instanceof THREE.DirectionalLight ) maxShadows ++;

			}

			return maxShadows;

		}

		this.getParameters = function ( material, lights, fog, object ) {

			var shaderID = shaderIDs[ material.type ];
			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxLightCount = allocateLights( lights );
			var maxShadows = allocateShadows( lights );
			var maxBones = allocateBones( object );
			var precision = renderer.getPrecision();

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			var parameters = {

				shaderID: shaderID,

				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,

				map: !! material.map,
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				displacementMap: !! material.displacementMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				combine: material.combine,

				vertexColors: material.vertexColors,

				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,

				flatShading: material.shading === THREE.FlatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				maxDirLights: maxLightCount.directional,
				maxPointLights: maxLightCount.point,
				maxSpotLights: maxLightCount.spot,
				maxHemiLights: maxLightCount.hemi,

				maxShadows: maxShadows,
				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && maxShadows > 0,
				shadowMapType: renderer.shadowMap.type,
				shadowMapDebug: renderer.shadowMap.debug,

				alphaTest: material.alphaTest,
				metal: material.metal,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide

			};

			return parameters;

		};

		this.getProgramCode = function ( material, parameters ) {

			var chunks = [];

			if ( parameters.shaderID ) {

				chunks.push( parameters.shaderID );

			} else {

				chunks.push( material.fragmentShader );
				chunks.push( material.vertexShader );

			}

			if ( material.defines !== undefined ) {

				for ( var name in material.defines ) {

					chunks.push( name );
					chunks.push( material.defines[ name ] );

				}

			}

			for ( var i = 0; i < parameterNames.length; i ++ ) {

				var parameterName = parameterNames[ i ];
				chunks.push( parameterName );
				chunks.push( parameters[ parameterName ] );

			}

			return chunks.join();

		};

		this.acquireProgram = function ( material, parameters, code ) {

			var program;

			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

				var programInfo = programs[ p ];

				if ( programInfo.code === code ) {

					program = programInfo;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new THREE.WebGLProgram( renderer, code, material, parameters );
				programs.push( program );

			}

			return program;

		};

		this.releaseProgram = function( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		};

		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;

	};

	// File:src/renderers/webgl/WebGLProperties.js

	/**
	* @author fordacious / fordacious.github.io
	*/

	THREE.WebGLProperties = function () {

		var properties = {};

		this.get = function ( object ) {

			var uuid = object.uuid;
			var map = properties[ uuid ];

			if ( map === undefined ) {

				map = {};
				properties[ uuid ] = map;

			}

			return map;

		};

		this.delete = function ( object ) {

			delete properties[ object.uuid ];

		};

		this.clear = function () {

			properties = {};

		};

	};

	// File:src/renderers/webgl/WebGLShader.js

	THREE.WebGLShader = ( function () {

		var addLineNumbers = function ( string ) {

			var lines = string.split( '\n' );

			for ( var i = 0; i < lines.length; i ++ ) {

				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

			}

			return lines.join( '\n' );

		};

		return function WebGLShader( gl, type, string ) {

			var shader = gl.createShader( type );

			gl.shaderSource( shader, string );
			gl.compileShader( shader );

			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

			}

			if ( gl.getShaderInfoLog( shader ) !== '' ) {

				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

			}

			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			return shader;

		};

	} )();

	// File:src/renderers/webgl/WebGLShadowMap.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

		var _gl = _renderer.context,
		_state = _renderer.state,
		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),

		_min = new THREE.Vector3(),
		_max = new THREE.Vector3(),

		_matrixPosition = new THREE.Vector3(),

		_renderList = [];

		// init

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		var _depthMaterial = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader
		 } );

		var _depthMaterialMorph = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: true
		} );

		var _depthMaterialSkin = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			skinning: true
		} );

		var _depthMaterialMorphSkin = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: true,
			skinning: true
		} );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

		//

		var scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = THREE.PCFShadowMap;
		this.cullFace = THREE.CullFaceFront;

		this.render = function ( scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			// set GL state for depth map

			_gl.clearColor( 1, 1, 1, 1 );
			_state.disable( _gl.BLEND );

			_state.enable( _gl.CULL_FACE );
			_gl.frontFace( _gl.CCW );

			if ( scope.cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.BACK );

			}

			_state.setDepthTest( true );

			// render depth map

			for ( var i = 0, il = _lights.length; i < il; i ++ ) {

				var light = _lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( ! light.shadowMap ) {

					var shadowFilter = THREE.LinearFilter;

					if ( scope.type === THREE.PCFSoftShadowMap ) {

						shadowFilter = THREE.NearestFilter;

					}

					var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

					light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
					light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

					light.shadowMatrix = new THREE.Matrix4();

				}

				if ( ! light.shadowCamera ) {

					if ( light instanceof THREE.SpotLight ) {

						light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

					} else if ( light instanceof THREE.DirectionalLight ) {

						light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

					} else {

						console.error( "THREE.ShadowMapPlugin: Unsupported light type for shadow", light );
						continue;

					}

					scene.add( light.shadowCamera );

					if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

				}

				if ( light.shadowCameraVisible && ! light.cameraHelper ) {

					light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
					scene.add( light.cameraHelper );

				}

				var shadowMap = light.shadowMap;
				var shadowMatrix = light.shadowMatrix;
				var shadowCamera = light.shadowCamera;

				//

				shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
				_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
				shadowCamera.lookAt( _matrixPosition );
				shadowCamera.updateMatrixWorld();

				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

				//

				if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
				if ( light.shadowCameraVisible ) light.cameraHelper.update();

				// compute shadow matrix

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				// update camera matrices and frustum

				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				// render shadow map

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// set object matrices & frustum culling

				_renderList.length = 0;

				projectObject( scene, shadowCamera );


				// render regular objects

				for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

					var object = _renderList[ j ];
					var geometry = _objects.update( object );
					var material = object.material;

					if ( material instanceof THREE.MeshFaceMaterial ) {

						var groups = geometry.groups;
						var materials = material.materials;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = materials[ group.materialIndex ];

							if ( groupMaterial.visible === true ) {

								_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, groupMaterial ), object, group );

							}

						}

					} else {

						_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, material ), object );

					}

				}

			}

			// restore GL state

			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();

			_renderer.setClearColor( clearColor, clearAlpha );
			_state.enable( _gl.BLEND );

			if ( scope.cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.BACK );

			}

			_renderer.resetGLState();

			scope.needsUpdate = false;

		};

		function getDepthMaterial( object, material ) {

			var geometry = object.geometry;

			var useMorphing = geometry.morphTargets !== undefined && geometry.morphTargets.length > 0 && material.morphTargets;
			var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

			var depthMaterial;

			if ( object.customDepthMaterial ) {

				depthMaterial = object.customDepthMaterial;

			} else if ( useSkinning ) {

				depthMaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

			} else if ( useMorphing ) {

				depthMaterial = _depthMaterialMorph;

			} else {

				depthMaterial = _depthMaterial;

			}

			depthMaterial.visible = material.visible;
			depthMaterial.wireframe = material.wireframe;
			depthMaterial.wireframeLinewidth = material.wireframeLinewidth;

			return depthMaterial;

		}

		function projectObject( object, camera ) {

			if ( object.visible === false ) return;

			if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

				if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

					var material = object.material;

					if ( material.visible === true ) {

						object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
						_renderList.push( object );

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera );

			}

		}

	};

	// File:src/renderers/webgl/WebGLState.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {

		var _this = this;

		var newAttributes = new Uint8Array( 16 );
		var enabledAttributes = new Uint8Array( 16 );

		var capabilities = {};

		var compressedTextureFormats = null;

		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;

		var currentDepthFunc = null;
		var currentDepthWrite = null;

		var currentColorWrite = null;

		var currentFlipSided = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

		var currentTextureSlot = undefined;
		var currentBoundTextures = {};

		this.init = function () {

			gl.clearColor( 0, 0, 0, 1 );
			gl.clearDepth( 1 );
			gl.clearStencil( 0 );

			this.enable( gl.DEPTH_TEST );
			gl.depthFunc( gl.LEQUAL );

			gl.frontFace( gl.CCW );
			gl.cullFace( gl.BACK );
			this.enable( gl.CULL_FACE );

			this.enable( gl.BLEND );
			gl.blendEquation( gl.FUNC_ADD );
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

		};

		this.initAttributes = function () {

			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

				newAttributes[ i ] = 0;

			}

		};

		this.enableAttribute = function ( attribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

		};

		this.disableUnusedAttributes = function () {

			for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		};

		this.enable = function ( id ) {

			if ( capabilities[ id ] !== true ) {

				gl.enable( id );
				capabilities[ id ] = true;

			}

		};

		this.disable = function ( id ) {

			if ( capabilities[ id ] !== false ) {

				gl.disable( id );
				capabilities[ id ] = false;

			}

		};

		this.getCompressedTextureFormats = function () {

			if ( compressedTextureFormats === null ) {

				compressedTextureFormats = [];

				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

					var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

					for ( var i = 0; i < formats.length; i ++ ) {

						compressedTextureFormats.push( formats[ i ] );

					}

				}

			}

			return compressedTextureFormats;

		};

		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

			if ( blending !== currentBlending ) {

				if ( blending === THREE.NoBlending ) {

					this.disable( gl.BLEND );

				} else if ( blending === THREE.AdditiveBlending ) {

					this.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

				} else if ( blending === THREE.SubtractiveBlending ) {

					// TODO: Find blendFuncSeparate() combination

					this.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

				} else if ( blending === THREE.MultiplyBlending ) {

					// TODO: Find blendFuncSeparate() combination

					this.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

				} else if ( blending === THREE.CustomBlending ) {

					this.enable( gl.BLEND );

				} else {

					this.enable( gl.BLEND );
					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				}

				currentBlending = blending;

			}

			if ( blending === THREE.CustomBlending ) {

				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;

				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

					gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;

				}

				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

					gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;

				}

			} else {

				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

			}

		};

		this.setDepthFunc = function ( depthFunc ) {

			if ( currentDepthFunc !== depthFunc ) {

				if ( depthFunc ) {

					switch ( depthFunc ) {

						case THREE.NeverDepth:

							gl.depthFunc( gl.NEVER );
							break;

						case THREE.AlwaysDepth:

							gl.depthFunc( gl.ALWAYS );
							break;

						case THREE.LessDepth:

							gl.depthFunc( gl.LESS );
							break;

						case THREE.LessEqualDepth:

							gl.depthFunc( gl.LEQUAL );
							break;

						case THREE.EqualDepth:

							gl.depthFunc( gl.EQUAL );
							break;

						case THREE.GreaterEqualDepth:

							gl.depthFunc( gl.GEQUAL );
							break;

						case THREE.GreaterDepth:

							gl.depthFunc( gl.GREATER );
							break;

						case THREE.NotEqualDepth:

							gl.depthFunc( gl.NOTEQUAL );
							break;

						default:

							gl.depthFunc( gl.LEQUAL );

					}

				} else {

					gl.depthFunc( gl.LEQUAL );

				}

				currentDepthFunc = depthFunc;

			}

		};

		this.setDepthTest = function ( depthTest ) {

			if ( depthTest ) {

				this.enable( gl.DEPTH_TEST );

			} else {

				this.disable( gl.DEPTH_TEST );

			}

		};

		this.setDepthWrite = function ( depthWrite ) {

			if ( currentDepthWrite !== depthWrite ) {

				gl.depthMask( depthWrite );
				currentDepthWrite = depthWrite;

			}

		};

		this.setColorWrite = function ( colorWrite ) {

			if ( currentColorWrite !== colorWrite ) {

				gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
				currentColorWrite = colorWrite;

			}

		};

		this.setFlipSided = function ( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		};

		this.setLineWidth = function ( width ) {

			if ( width !== currentLineWidth ) {

				gl.lineWidth( width );

				currentLineWidth = width;

			}

		};

		this.setPolygonOffset = function ( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				this.enable( gl.POLYGON_OFFSET_FILL );

			} else {

				this.disable( gl.POLYGON_OFFSET_FILL );

			}

			if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		};

		this.setScissorTest = function ( scissorTest ) {

			if ( scissorTest ) {

				this.enable( gl.SCISSOR_TEST );

			} else {

				this.disable( gl.SCISSOR_TEST );

			}

		};

		// texture

		this.activeTexture = function ( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		this.bindTexture = function ( webglType, webglTexture ) {

			if ( currentTextureSlot === undefined ) {

				_this.activeTexture();

			}

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		};

		this.compressedTexImage2D = function () {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( error );

			}

		};

		this.texImage2D = function () {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( error );

			}

		};

		//

		this.reset = function () {

			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

				if ( enabledAttributes[ i ] === 1 ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

			capabilities = {};

			compressedTextureFormats = null;

			currentBlending = null;

			currentDepthWrite = null;
			currentColorWrite = null;

			currentFlipSided = null;

		};

	};

	// File:src/renderers/webgl/plugins/LensFlarePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlarePlugin = function ( renderer, flares ) {

		var gl = renderer.context;
		var state = renderer.state;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
		var hasVertexTexture;

		var tempTexture, occlusionTexture;

		var init = function () {

			var vertices = new Float32Array( [
				- 1, - 1,  0, 0,
				 1, - 1,  1, 0,
				 1,  1,  1, 1,
				- 1,  1,  0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			// buffers

			vertexBuffer     = gl.createBuffer();
			elementBuffer    = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			// textures

			tempTexture      = gl.createTexture();
			occlusionTexture = gl.createTexture();

			state.bindTexture( gl.TEXTURE_2D, tempTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

			var shader;

			if ( hasVertexTexture ) {

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"uniform sampler2D occlusionMap;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if( renderType == 2 ) {",

								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							// pink square

							"if( renderType == 0 ) {",

								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

							// restore

							"} else if( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

			} else {

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if( renderType == 2 ) {",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"precision mediump float;",

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform sampler2D occlusionMap;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",

						"void main() {",

							// pink square

							"if( renderType == 0 ) {",

								"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

							// restore

							"} else if( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
								"visibility = ( 1.0 - visibility / 4.0 );",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * visibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

			}

			program = createProgram( shader );

			attributes = {
				vertex: gl.getAttribLocation ( program, "position" ),
				uv:     gl.getAttribLocation ( program, "uv" )
			};

			uniforms = {
				renderType:     gl.getUniformLocation( program, "renderType" ),
				map:            gl.getUniformLocation( program, "map" ),
				occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
				opacity:        gl.getUniformLocation( program, "opacity" ),
				color:          gl.getUniformLocation( program, "color" ),
				scale:          gl.getUniformLocation( program, "scale" ),
				rotation:       gl.getUniformLocation( program, "rotation" ),
				screenPosition: gl.getUniformLocation( program, "screenPosition" )
			};

		};

		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */

		this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

			if ( flares.length === 0 ) return;

			var tempPosition = new THREE.Vector3();

			var invAspect = viewportHeight / viewportWidth,
				halfViewportWidth = viewportWidth * 0.5,
				halfViewportHeight = viewportHeight * 0.5;

			var size = 16 / viewportHeight,
				scale = new THREE.Vector2( size * invAspect, size );

			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );

			if ( program === undefined ) {

				init();

			}

			gl.useProgram( program );

			state.initAttributes();
			state.enableAttribute( attributes.vertex );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();

			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/uniforms

			gl.uniform1i( uniforms.occlusionMap, 0 );
			gl.uniform1i( uniforms.map, 1 );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			state.disable( gl.CULL_FACE );
			gl.depthMask( false );

			for ( var i = 0, l = flares.length; i < l; i ++ ) {

				size = 16 / viewportHeight;
				scale.set( size * invAspect, size );

				// calc object screen position

				var flare = flares[ i ];

				tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );

				// setup arrays for gl programs

				screenPosition.copy( tempPosition );

				screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
				screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

				// screen cull

				if ( hasVertexTexture || (
					screenPositionPixels.x > 0 &&
					screenPositionPixels.x < viewportWidth &&
					screenPositionPixels.y > 0 &&
					screenPositionPixels.y < viewportHeight ) ) {

					// save current RGB to temp texture

					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, null );
					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


					// render pink quad

					gl.uniform1i( uniforms.renderType, 0 );
					gl.uniform2f( uniforms.scale, scale.x, scale.y );
					gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

					state.disable( gl.BLEND );
					state.enable( gl.DEPTH_TEST );

					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// copy result to occlusionMap

					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


					// restore graphics

					gl.uniform1i( uniforms.renderType, 1 );
					state.disable( gl.DEPTH_TEST );

					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// update object positions

					flare.positionScreen.copy( screenPosition );

					if ( flare.customUpdateCallback ) {

						flare.customUpdateCallback( flare );

					} else {

						flare.updateLensFlares();

					}

					// render flares

					gl.uniform1i( uniforms.renderType, 2 );
					state.enable( gl.BLEND );

					for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

						var sprite = flare.lensFlares[ j ];

						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;

							size = sprite.size * sprite.scale / viewportHeight;

							scale.x = size * invAspect;
							scale.y = size;

							gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							gl.uniform2f( uniforms.scale, scale.x, scale.y );
							gl.uniform1f( uniforms.rotation, sprite.rotation );

							gl.uniform1f( uniforms.opacity, sprite.opacity );
							gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

							state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							renderer.setTexture( sprite.texture, 1 );

							gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

						}

					}

				}

			}

			// restore gl

			state.enable( gl.CULL_FACE );
			state.enable( gl.DEPTH_TEST );
			gl.depthMask( true );

			renderer.resetGLState();

		};

		function createProgram ( shader ) {

			var program = gl.createProgram();

			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );

			var prefix = "precision " + renderer.getPrecision() + " float;\n";

			gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			gl.shaderSource( vertexShader, prefix + shader.vertexShader );

			gl.compileShader( fragmentShader );
			gl.compileShader( vertexShader );

			gl.attachShader( program, fragmentShader );
			gl.attachShader( program, vertexShader );

			gl.linkProgram( program );

			return program;

		}

	};

	// File:src/renderers/webgl/plugins/SpritePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpritePlugin = function ( renderer, sprites ) {

		var gl = renderer.context;
		var state = renderer.state;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;

		var texture;

		// decompose matrixWorld

		var spritePosition = new THREE.Vector3();
		var spriteRotation = new THREE.Quaternion();
		var spriteScale = new THREE.Vector3();

		var init = function () {

			var vertices = new Float32Array( [
				- 0.5, - 0.5,  0, 0,
				  0.5, - 0.5,  1, 0,
				  0.5,   0.5,  1, 1,
				- 0.5,   0.5,  0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			vertexBuffer  = gl.createBuffer();
			elementBuffer = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			program = createProgram();

			attributes = {
				position:			gl.getAttribLocation ( program, 'position' ),
				uv:					gl.getAttribLocation ( program, 'uv' )
			};

			uniforms = {
				uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
				uvScale:			gl.getUniformLocation( program, 'uvScale' ),

				rotation:			gl.getUniformLocation( program, 'rotation' ),
				scale:				gl.getUniformLocation( program, 'scale' ),

				color:				gl.getUniformLocation( program, 'color' ),
				map:				gl.getUniformLocation( program, 'map' ),
				opacity:			gl.getUniformLocation( program, 'opacity' ),

				modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

				fogType:			gl.getUniformLocation( program, 'fogType' ),
				fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
				fogNear:			gl.getUniformLocation( program, 'fogNear' ),
				fogFar:				gl.getUniformLocation( program, 'fogFar' ),
				fogColor:			gl.getUniformLocation( program, 'fogColor' ),

				alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
			};

			var canvas = document.createElement( 'canvas' );
			canvas.width = 8;
			canvas.height = 8;

			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );

			texture = new THREE.Texture( canvas );
			texture.needsUpdate = true;

		};

		this.render = function ( scene, camera ) {

			if ( sprites.length === 0 ) return;

			// setup gl

			if ( program === undefined ) {

				init();

			}

			gl.useProgram( program );

			state.initAttributes();
			state.enableAttribute( attributes.position );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();

			state.disable( gl.CULL_FACE );
			state.enable( gl.BLEND );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			state.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );

			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;

			if ( fog ) {

				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

				if ( fog instanceof THREE.Fog ) {

					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );

					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;

				} else if ( fog instanceof THREE.FogExp2 ) {

					gl.uniform1f( uniforms.fogDensity, fog.density );

					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;

				}

			} else {

				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;

			}


			// update positions and sort

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];

				sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

			}

			sprites.sort( painterSortStable );

			// render all sprites

			var scale = [];

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];
				var material = sprite.material;

				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;

				var fogType = 0;

				if ( scene.fog && material.fog ) {

					fogType = sceneFogType;

				}

				if ( oldFogType !== fogType ) {

					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;

				}

				if ( material.map !== null ) {

					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

				} else {

					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );

				}

				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.scale, scale );

				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );

				if ( material.map && material.map.image && material.map.image.width ) {

					renderer.setTexture( material.map, 0 );

				} else {

					renderer.setTexture( texture, 0 );

				}

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

			}

			// restore gl

			state.enable( gl.CULL_FACE );

			renderer.resetGLState();

		};

		function createProgram () {

			var program = gl.createProgram();

			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

			gl.shaderSource( vertexShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',

				'attribute vec2 position;',
				'attribute vec2 uv;',

				'varying vec2 vUV;',

				'void main() {',

					'vUV = uvOffset + uv * uvScale;',

					'vec2 alignedPosition = position * scale;',

					'vec2 rotatedPosition;',
					'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
					'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

					'vec4 finalPosition;',

					'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
					'finalPosition.xy += rotatedPosition;',
					'finalPosition = projectionMatrix * finalPosition;',

					'gl_Position = finalPosition;',

				'}'

			].join( '\n' ) );

			gl.shaderSource( fragmentShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',

				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',

				'varying vec2 vUV;',

				'void main() {',

					'vec4 texture = texture2D( map, vUV );',

					'if ( texture.a < alphaTest ) discard;',

					'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

					'if ( fogType > 0 ) {',

						'float depth = gl_FragCoord.z / gl_FragCoord.w;',
						'float fogFactor = 0.0;',

						'if ( fogType == 1 ) {',

							'fogFactor = smoothstep( fogNear, fogFar, depth );',

						'} else {',

							'const float LOG2 = 1.442695;',
							'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
							'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

						'}',

						'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

					'}',

				'}'

			].join( '\n' ) );

			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );

			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );

			gl.linkProgram( program );

			return program;

		}

		function painterSortStable ( a, b ) {

			if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return b.id - a.id;

			}

		}

	};

	// File:src/extras/GeometryUtils.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

			var matrix;

			if ( geometry2 instanceof THREE.Mesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	// File:src/extras/ImageUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Daosheng Mu / https://github.com/DaoshengMu/
	 */

	THREE.ImageUtils = {

		crossOrigin: undefined,

		loadTexture: function ( url, mapping, onLoad, onError ) {

			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;

			var texture = new THREE.Texture( undefined, mapping );

			loader.load( url, function ( image ) {

				texture.image = image;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, undefined, function ( event ) {

				if ( onError ) onError( event );

			} );

			texture.sourceFile = url;

			return texture;

		},

		loadTextureCube: function ( array, mapping, onLoad, onError ) {

			var images = [];

			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;

			var texture = new THREE.CubeTexture( images, mapping );

			var loaded = 0;

			var loadTexture = function ( i ) {

				loader.load( array[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded += 1;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			};

			for ( var i = 0, il = array.length; i < il; ++ i ) {

				loadTexture( i );

			}

			return texture;

		},

		loadCompressedTexture: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

		},

		loadCompressedTextureCube: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

		},

		getNormalMap: function ( image, depth ) {

			// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

			var cross = function ( a, b ) {

				return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

			};

			var subtract = function ( a, b ) {

				return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

			};

			var normalize = function ( a ) {

				var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
				return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

			};

			depth = depth | 1;

			var width = image.width;
			var height = image.height;

			var canvas = document.createElement( 'canvas' );
			canvas.width = width;
			canvas.height = height;

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0 );

			var data = context.getImageData( 0, 0, width, height ).data;
			var imageData = context.createImageData( width, height );
			var output = imageData.data;

			for ( var x = 0; x < width; x ++ ) {

				for ( var y = 0; y < height; y ++ ) {

					var ly = y - 1 < 0 ? 0 : y - 1;
					var uy = y + 1 > height - 1 ? height - 1 : y + 1;
					var lx = x - 1 < 0 ? 0 : x - 1;
					var ux = x + 1 > width - 1 ? width - 1 : x + 1;

					var points = [];
					var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
					points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

					var normals = [];
					var num_points = points.length;

					for ( var i = 0; i < num_points; i ++ ) {

						var v1 = points[ i ];
						var v2 = points[ ( i + 1 ) % num_points ];
						v1 = subtract( v1, origin );
						v2 = subtract( v2, origin );
						normals.push( normalize( cross( v1, v2 ) ) );

					}

					var normal = [ 0, 0, 0 ];

					for ( var i = 0; i < normals.length; i ++ ) {

						normal[ 0 ] += normals[ i ][ 0 ];
						normal[ 1 ] += normals[ i ][ 1 ];
						normal[ 2 ] += normals[ i ][ 2 ];

					}

					normal[ 0 ] /= normals.length;
					normal[ 1 ] /= normals.length;
					normal[ 2 ] /= normals.length;

					var idx = ( y * width + x ) * 4;

					output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
					output[ idx + 3 ] = 255;

				}

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		},

		generateDataTexture: function ( width, height, color ) {

			var size = width * height;
			var data = new Uint8Array( 3 * size );

			var r = Math.floor( color.r * 255 );
			var g = Math.floor( color.g * 255 );
			var b = Math.floor( color.b * 255 );

			for ( var i = 0; i < size; i ++ ) {

				data[ i * 3 ] 	   = r;
				data[ i * 3 + 1 ] = g;
				data[ i * 3 + 2 ] = b;

			}

			var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
			texture.needsUpdate = true;

			return texture;

		}

	};

	// File:src/extras/SceneUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SceneUtils = {

		createMultiMaterialObject: function ( geometry, materials ) {

			var group = new THREE.Group();

			for ( var i = 0, l = materials.length; i < l; i ++ ) {

				group.add( new THREE.Mesh( geometry, materials[ i ] ) );

			}

			return group;

		},

		detach: function ( child, parent, scene ) {

			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );

		},

		attach: function ( child, scene, parent ) {

			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );

			scene.remove( child );
			parent.add( child );

		}

	};

	// File:src/extras/FontUtils.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For Text operations in three.js (See TextGeometry)
	 *
	 * It uses techniques used in:
	 *
	 *	Triangulation ported from AS3
	 *		Simple Polygon Triangulation
	 *		http://actionsnippet.com/?p=1462
	 *
	 * 	A Method to triangulate shapes with holes
	 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
	 *
	 */

	THREE.FontUtils = {

		faces: {},

		// Just for now. face[weight][style]

		face: 'helvetiker',
		weight: 'normal',
		style: 'normal',
		size: 150,
		divisions: 10,

		getFace: function () {

			try {

				return this.faces[ this.face.toLowerCase() ][ this.weight ][ this.style ];

			} catch ( e ) {

				throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

			}

		},

		loadFace: function ( data ) {

			var family = data.familyName.toLowerCase();

			var ThreeFont = this;

			ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

			ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

			return data;

		},

		drawText: function ( text ) {

			// RenderText

			var i,
				face = this.getFace(),
				scale = this.size / face.resolution,
				offset = 0,
				chars = String( text ).split( '' ),
				length = chars.length;

			var fontPaths = [];

			for ( i = 0; i < length; i ++ ) {

				var path = new THREE.Path();

				var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
				offset += ret.offset;

				fontPaths.push( ret.path );

			}

			// get the width

			var width = offset / 2;
			//
			// for ( p = 0; p < allPts.length; p++ ) {
			//
			// 	allPts[ p ].x -= width;
			//
			// }

			//var extract = this.extractPoints( allPts, characterPts );
			//extract.contour = allPts;

			//extract.paths = fontPaths;
			//extract.offset = width;

			return { paths: fontPaths, offset: width };

		},




		extractGlyphPoints: function ( c, face, scale, offset, path ) {

			var pts = [];

			var i, i2, divisions,
				outline, action, length,
				scaleX, scaleY,
				x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
				laste,
				glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

			if ( ! glyph ) return;

			if ( glyph.o ) {

				outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
				length = outline.length;

				scaleX = scale;
				scaleY = scale;

				for ( i = 0; i < length; ) {

					action = outline[ i ++ ];

					//console.log( action );

					switch ( action ) {

					case 'm':

						// Move To

						x = outline[ i ++ ] * scaleX + offset;
						y = outline[ i ++ ] * scaleY;

						path.moveTo( x, y );
						break;

					case 'l':

						// Line To

						x = outline[ i ++ ] * scaleX + offset;
						y = outline[ i ++ ] * scaleY;
						path.lineTo( x, y );
						break;

					case 'q':

						// QuadraticCurveTo

						cpx  = outline[ i ++ ] * scaleX + offset;
						cpy  = outline[ i ++ ] * scaleY;
						cpx1 = outline[ i ++ ] * scaleX + offset;
						cpy1 = outline[ i ++ ] * scaleY;

						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

						laste = pts[ pts.length - 1 ];

						if ( laste ) {

							cpx0 = laste.x;
							cpy0 = laste.y;

							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

								var t = i2 / divisions;
								THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
								THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

							}

						}

						break;

					case 'b':

						// Cubic Bezier Curve

						cpx  = outline[ i ++ ] *  scaleX + offset;
						cpy  = outline[ i ++ ] *  scaleY;
						cpx1 = outline[ i ++ ] *  scaleX + offset;
						cpy1 = outline[ i ++ ] *  scaleY;
						cpx2 = outline[ i ++ ] *  scaleX + offset;
						cpy2 = outline[ i ++ ] *  scaleY;

						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

						laste = pts[ pts.length - 1 ];

						if ( laste ) {

							cpx0 = laste.x;
							cpy0 = laste.y;

							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

								var t = i2 / divisions;
								THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
								THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

							}

						}

						break;

					}

				}

			}



			return { offset: glyph.ha * scale, path: path };

		}

	};


	THREE.FontUtils.generateShapes = function ( text, parameters ) {

		// Parameters

		parameters = parameters || {};

		var size = parameters.size !== undefined ? parameters.size : 100;
		var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

		var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
		var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
		var style = parameters.style !== undefined ? parameters.style : 'normal';

		THREE.FontUtils.size = size;
		THREE.FontUtils.divisions = curveSegments;

		THREE.FontUtils.face = font;
		THREE.FontUtils.weight = weight;
		THREE.FontUtils.style = style;

		// Get a Font data json object

		var data = THREE.FontUtils.drawText( text );

		var paths = data.paths;
		var shapes = [];

		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	};


	/**
	 * This code is a quick port of code written in C++ which was submitted to
	 * flipcode.com by John W. Ratcliff  // July 22, 2000
	 * See original code and more information here:
	 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
	 *
	 * ported to actionscript by Zevan Rosser
	 * www.actionsnippet.com
	 *
	 * ported to javascript by Joshua Koo
	 * http://www.lab4games.net/zz85/blog
	 *
	 */


	( function ( namespace ) {

		var EPSILON = 0.0000000001;

		// takes in an contour array and returns

		var process = function ( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* three consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		};

		// calculate area of the contour polygon

		var area = function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		};

		var snip = function ( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x;
				py = contour[ verts[ p ] ].y;

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

			}

			return true;

		};


		namespace.Triangulate = process;
		namespace.Triangulate.area = area;

		return namespace;

	} )( THREE.FontUtils );

	// To use the typeface.js face files, hook up the API

	THREE.typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
	if ( typeof self !== 'undefined' ) self._typeface_js = THREE.typeface_js;

	// File:src/extras/audio/Audio.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Audio = function ( listener ) {

		THREE.Object3D.call( this );

		this.type = 'Audio';

		this.context = listener.context;
		this.source = this.context.createBufferSource();
		this.source.onended = this.onEnded.bind( this );

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );

		this.autoplay = false;

		this.startTime = 0;
		this.playbackRate = 1;
		this.isPlaying = false;

	};

	THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Audio.prototype.constructor = THREE.Audio;

	THREE.Audio.prototype.load = function ( file ) {

		var scope = this;

		var request = new XMLHttpRequest();
		request.open( 'GET', file, true );
		request.responseType = 'arraybuffer';
		request.onload = function ( e ) {

			scope.context.decodeAudioData( this.response, function ( buffer ) {

				scope.source.buffer = buffer;

				if ( scope.autoplay ) scope.play();

			} );

		};
		request.send();

		return this;

	};

	THREE.Audio.prototype.play = function () {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		var source = this.context.createBufferSource();

		source.buffer = this.source.buffer;
		source.loop = this.source.loop;
		source.onended = this.source.onended;
		source.start( 0, this.startTime );
		source.playbackRate.value = this.playbackRate;

		this.isPlaying = true;

		this.source = source;

		this.connect();

	};

	THREE.Audio.prototype.pause = function () {

		this.source.stop();
		this.startTime = this.context.currentTime;

	};

	THREE.Audio.prototype.stop = function () {

		this.source.stop();
		this.startTime = 0;

	};

	THREE.Audio.prototype.connect = function () {

		if ( this.filter !== undefined ) {

			this.source.connect( this.filter );
			this.filter.connect( this.panner );

		} else {

			this.source.connect( this.panner );

		}

	};

	THREE.Audio.prototype.disconnect = function () {

		if ( this.filter !== undefined ) {

			this.source.disconnect( this.filter );
			this.filter.disconnect( this.panner );

		} else {

			this.source.disconnect( this.panner );

		}

	};

	THREE.Audio.prototype.setFilter = function ( value ) {

		if ( this.isPlaying === true ) {

			this.disconnect();
			this.filter = value;
			this.connect();

		} else {

			this.filter = value;

		}

	};

	THREE.Audio.prototype.getFilter = function () {

		return this.filter;

	};

	THREE.Audio.prototype.setPlaybackRate = function ( value ) {

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.value = this.playbackRate;

		}

	};

	THREE.Audio.prototype.getPlaybackRate = function () {

		return this.playbackRate;

	};

	THREE.Audio.prototype.onEnded = function() {

		this.isPlaying = false;

	};

	THREE.Audio.prototype.setLoop = function ( value ) {

		this.source.loop = value;

	};

	THREE.Audio.prototype.getLoop = function () {

		return this.source.loop;

	};

	THREE.Audio.prototype.setRefDistance = function ( value ) {

		this.panner.refDistance = value;

	};

	THREE.Audio.prototype.getRefDistance = function () {

		return this.panner.refDistance;

	};

	THREE.Audio.prototype.setRolloffFactor = function ( value ) {

		this.panner.rolloffFactor = value;

	};

	THREE.Audio.prototype.getRolloffFactor = function () {

		return this.panner.rolloffFactor;

	};

	THREE.Audio.prototype.setVolume = function ( value ) {

		this.gain.gain.value = value;

	};

	THREE.Audio.prototype.getVolume = function () {

		return this.gain.gain.value;

	};

	THREE.Audio.prototype.updateMatrixWorld = ( function () {

		var position = new THREE.Vector3();

		return function updateMatrixWorld( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			position.setFromMatrixPosition( this.matrixWorld );

			this.panner.setPosition( position.x, position.y, position.z );

		};

	} )();

	// File:src/extras/audio/AudioListener.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AudioListener = function () {

		THREE.Object3D.call( this );

		this.type = 'AudioListener';

		this.context = new ( window.AudioContext || window.webkitAudioContext )();

	};

	THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
	THREE.AudioListener.prototype.constructor = THREE.AudioListener;

	THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3();

		var orientation = new THREE.Vector3();

		return function updateMatrixWorld( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			var listener = this.context.listener;
			var up = this.up;

			this.matrixWorld.decompose( position, quaternion, scale );

			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			listener.setPosition( position.x, position.y, position.z );
			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

		};

	} )();

	// File:src/extras/core/Curve.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 * THREE.ClosedSplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	THREE.Curve = function () {

	};

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	THREE.Curve.prototype.getPoint = function ( t ) {

		console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
		return null;

	};

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	THREE.Curve.prototype.getPointAt = function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	};

	// Get sequence of points using getPoint( t )

	THREE.Curve.prototype.getPoints = function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPoint( d / divisions ) );

		}

		return pts;

	};

	// Get sequence of points using getPointAt( u )

	THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPointAt( d / divisions ) );

		}

		return pts;

	};

	// Get total curve arc length

	THREE.Curve.prototype.getLength = function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	};

	// Get list of cumulative segment lengths

	THREE.Curve.prototype.getLengths = function ( divisions ) {

		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length === divisions + 1 )
			&& ! this.needsUpdate ) {

			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

	};


	THREE.Curve.prototype.updateArcLengths = function() {

		this.needsUpdate = true;
		this.getLengths();

	};

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		//var time = Date.now();

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		//console.log('b' , i, low, high, Date.now()- time);

		if ( arcLengths[ i ] === targetArcLength ) {

			var t = i / ( il - 1 );
			return t;

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	};

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	THREE.Curve.prototype.getTangent = function( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub( pt1 );
		return vec.normalize();

	};


	THREE.Curve.prototype.getTangentAt = function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	};





	/**************************************************************
	 *	Utils
	 **************************************************************/

	THREE.Curve.Utils = {

		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

		},

		// Puay Bing, thanks for helping with this derivative!

		tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

			return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
				3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
				6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
				3 * t * t * p3;

		},

		tangentSpline: function ( t, p0, p1, p2, p3 ) {

			// To check if my formulas are correct

			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
			var h01 = - 6 * t * t + 6 * t; 	//  2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3  t2

			return h00 + h10 + h01 + h11;

		},

		// Catmull-Rom

		interpolate: function( p0, p1, p2, p3, t ) {

			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	};


	// TODO: Transformation for Curves?

	/**************************************************************
	 *	3D Curves
	 **************************************************************/

	// A Factory method for creating new curve subclasses

	THREE.Curve.create = function ( constructor, getPointFunc ) {

		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.constructor = constructor;
		constructor.prototype.getPoint = getPointFunc;

		return constructor;

	};

	// File:src/extras/core/CurvePath.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	THREE.CurvePath = function () {

		this.curves = [];
		this.bends = [];

		this.autoClose = false; // Automatically closes the path

	};

	THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
	THREE.CurvePath.prototype.constructor = THREE.CurvePath;

	THREE.CurvePath.prototype.add = function ( curve ) {

		this.curves.push( curve );

	};

	THREE.CurvePath.prototype.checkConnection = function() {
		// TODO
		// If the ending of curve is not connected to the starting
		// or the next curve, then, this is not a real path
	};

	THREE.CurvePath.prototype.closePath = function() {

		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

		}

	};

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	THREE.CurvePath.prototype.getPoint = function( t ) {

		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0, diff, curve;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				diff = curveLengths[ i ] - d;
				curve = this.curves[ i ];

				var u = 1 - diff / curve.getLength();

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	};

	/*
	THREE.CurvePath.prototype.getTangent = function( t ) {
	};*/


	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	THREE.CurvePath.prototype.getLength = function() {

		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	};

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	THREE.CurvePath.prototype.getCurveLengths = function() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		var lengths = [], sums = 0;
		var i, il = this.curves.length;

		for ( i = 0; i < il; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	};



	// Returns min and max coordinates

	THREE.CurvePath.prototype.getBoundingBox = function () {

		var points = this.getPoints();

		var maxX, maxY, maxZ;
		var minX, minY, minZ;

		maxX = maxY = Number.NEGATIVE_INFINITY;
		minX = minY = Number.POSITIVE_INFINITY;

		var p, i, il, sum;

		var v3 = points[ 0 ] instanceof THREE.Vector3;

		sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

		for ( i = 0, il = points.length; i < il; i ++ ) {

			p = points[ i ];

			if ( p.x > maxX ) maxX = p.x;
			else if ( p.x < minX ) minX = p.x;

			if ( p.y > maxY ) maxY = p.y;
			else if ( p.y < minY ) minY = p.y;

			if ( v3 ) {

				if ( p.z > maxZ ) maxZ = p.z;
				else if ( p.z < minZ ) minZ = p.z;

			}

			sum.add( p );

		}

		var ret = {

			minX: minX,
			minY: minY,
			maxX: maxX,
			maxY: maxY

		};

		if ( v3 ) {

			ret.maxZ = maxZ;
			ret.minZ = minZ;

		}

		return ret;

	};

	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/

	/// Generate geometry from path points (for Line or Points objects)

	THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

		var pts = this.getPoints( divisions, true );
		return this.createGeometry( pts );

	};

	// Generate geometry from equidistant sampling along the path

	THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

		var pts = this.getSpacedPoints( divisions, true );
		return this.createGeometry( pts );

	};

	THREE.CurvePath.prototype.createGeometry = function( points ) {

		var geometry = new THREE.Geometry();

		for ( var i = 0; i < points.length; i ++ ) {

			geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0 ) );

		}

		return geometry;

	};


	/**************************************************************
	 *	Bend / Wrap Helper Methods
	 **************************************************************/

	// Wrap path / Bend modifiers?

	THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

		this.bends.push( bendpath );

	};

	THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

		var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
		var i, il;

		if ( ! bends ) {

			bends = this.bends;

		}

		for ( i = 0, il = bends.length; i < il; i ++ ) {

			oldPts = this.getWrapPoints( oldPts, bends[ i ] );

		}

		return oldPts;

	};

	THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

		var oldPts = this.getSpacedPoints( segments );

		var i, il;

		if ( ! bends ) {

			bends = this.bends;

		}

		for ( i = 0, il = bends.length; i < il; i ++ ) {

			oldPts = this.getWrapPoints( oldPts, bends[ i ] );

		}

		return oldPts;

	};

	// This returns getPoints() bend/wrapped around the contour of a path.
	// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

	THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

		var bounds = this.getBoundingBox();

		var i, il, p, oldX, oldY, xNorm;

		for ( i = 0, il = oldPts.length; i < il; i ++ ) {

			p = oldPts[ i ];

			oldX = p.x;
			oldY = p.y;

			xNorm = oldX / bounds.maxX;

			// If using actual distance, for length > path, requires line extrusions
			//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

			xNorm = path.getUtoTmapping( xNorm, oldX );

			// check for out of bounds?

			var pathPt = path.getPoint( xNorm );
			var normal = path.getTangent( xNorm );
			normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

			p.x = pathPt.x + normal.x;
			p.y = pathPt.y + normal.y;

		}

		return oldPts;

	};

	// File:src/extras/core/Path.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/

	THREE.Path = function ( points ) {

		THREE.CurvePath.call( this );

		this.actions = [];

		if ( points ) {

			this.fromPoints( points );

		}

	};

	THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
	THREE.Path.prototype.constructor = THREE.Path;

	THREE.PathActions = {

		MOVE_TO: 'moveTo',
		LINE_TO: 'lineTo',
		QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
		BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
		CSPLINE_THRU: 'splineThru',				// Catmull-Rom spline
		ARC: 'arc',								// Circle
		ELLIPSE: 'ellipse'
	};

	// TODO Clean up PATH API

	// Create path using straight lines to connect all points
	// - vectors: array of Vector2

	THREE.Path.prototype.fromPoints = function ( vectors ) {

		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

		for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

			this.lineTo( vectors[ v ].x, vectors[ v ].y );

		}

	};

	// startPath() endPath()?

	THREE.Path.prototype.moveTo = function ( x, y ) {

		var args = Array.prototype.slice.call( arguments );
		this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

	};

	THREE.Path.prototype.lineTo = function ( x, y ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

	};

	THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
													new THREE.Vector2( aCPx, aCPy ),
													new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

	};

	THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
												   aCP2x, aCP2y,
												   aX, aY ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCP1x, aCP1y ),
												new THREE.Vector2( aCP2x, aCP2y ),
												new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

	};

	THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

		var args = Array.prototype.slice.call( arguments );
		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
		//---
		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );

		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

	};

	// FUTURE: Change the API or follow canvas API?

	THREE.Path.prototype.arc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

	 };

	 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	 };

	THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius,
			aStartAngle, aEndAngle, aClockwise, aRotation );

	 };


	THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var args = [
			aX, aY,
			xRadius, yRadius,
			aStartAngle, aEndAngle,
			aClockwise,
			aRotation || 0 // aRotation is optional.
		];
		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
										aStartAngle, aEndAngle, aClockwise, aRotation );
		this.curves.push( curve );

		var lastPoint = curve.getPoint( 1 );
		args.push( lastPoint.x );
		args.push( lastPoint.y );

		this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

	 };

	THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

		if ( ! divisions ) divisions = 40;

		var points = [];

		for ( var i = 0; i < divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

			//if( !this.getPoint( i / divisions ) ) throw "DIE";

		}

		// if ( closedPath ) {
		//
		// 	points.push( points[ 0 ] );
		//
		// }

		return points;

	};

	/* Return an array of vectors based on contour of the path */

	THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

		if ( this.useSpacedPoints ) {

			return this.getSpacedPoints( divisions, closedPath );

		}

		divisions = divisions || 12;

		var points = [];

		var i, il, item, action, args;
		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, j,
			t, tx, ty;

		for ( i = 0, il = this.actions.length; i < il; i ++ ) {

			item = this.actions[ i ];

			action = item.action;
			args = item.args;

			switch ( action ) {

			case THREE.PathActions.MOVE_TO:

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case THREE.PathActions.LINE_TO:

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case THREE.PathActions.QUADRATIC_CURVE_TO:

				cpx  = args[ 2 ];
				cpy  = args[ 3 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}

				for ( j = 1; j <= divisions; j ++ ) {

					t = j / divisions;

					tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
					ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case THREE.PathActions.BEZIER_CURVE_TO:

				cpx  = args[ 4 ];
				cpy  = args[ 5 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}


				for ( j = 1; j <= divisions; j ++ ) {

					t = j / divisions;

					tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
					ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case THREE.PathActions.CSPLINE_THRU:

				laste = this.actions[ i - 1 ].args;

				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];

				var n = divisions * args[ 0 ].length;

				spts = spts.concat( args[ 0 ] );

				var spline = new THREE.SplineCurve( spts );

				for ( j = 1; j <= n; j ++ ) {

					points.push( spline.getPointAt( j / n ) );

				}

				break;

			case THREE.PathActions.ARC:

				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !! args[ 5 ];

				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				for ( j = 1; j <= tdivisions; j ++ ) {

					t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

				break;

			case THREE.PathActions.ELLIPSE:

				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !! args[ 6 ],
					aRotation = args[ 7 ];


				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				var cos, sin;
				if ( aRotation !== 0 ) {
			
					cos = Math.cos( aRotation );
					sin = Math.sin( aRotation );

				}

				for ( j = 1; j <= tdivisions; j ++ ) {

					t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );

					if ( aRotation !== 0 ) {

						var x = tx, y = ty;

						// Rotate the point about the center of the ellipse.
						tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
						ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

					}

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

				break;

			} // end switch

		}



		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1 ];
		var EPSILON = 0.0000000001;
		if ( Math.abs( lastPoint.x - points[ 0 ].x ) < EPSILON &&
				 Math.abs( lastPoint.y - points[ 0 ].y ) < EPSILON )
			points.splice( points.length - 1, 1 );
		if ( closedPath ) {

			points.push( points[ 0 ] );

		}

		return points;

	};

	//
	// Breaks path into shapes
	//
	//	Assumptions (if parameter isCCW==true the opposite holds):
	//	- solid shapes are defined clockwise (CW)
	//	- holes are defined counterclockwise (CCW)
	//
	//	If parameter noHoles==true:
	//  - all subPaths are regarded as solid shapes
	//  - definition order CW/CCW has no relevance
	//

	THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

		function extractSubpaths( inActions ) {

			var i, il, item, action, args;

			var subPaths = [], lastPath = new THREE.Path();

			for ( i = 0, il = inActions.length; i < il; i ++ ) {

				item = inActions[ i ];

				args = item.args;
				action = item.action;

				if ( action === THREE.PathActions.MOVE_TO ) {

					if ( lastPath.actions.length !== 0 ) {

						subPaths.push( lastPath );
						lastPath = new THREE.Path();

					}

				}

				lastPath[ action ].apply( lastPath, args );

			}

			if ( lastPath.actions.length !== 0 ) {

				subPaths.push( lastPath );

			}

			// console.log(subPaths);

			return	subPaths;

		}

		function toShapesNoHoles( inSubpaths ) {

			var shapes = [];

			for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

				var tmpPath = inSubpaths[ i ];

				var tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			//console.log("shape", shapes);

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			var EPSILON = 0.0000000001;

			var polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];

				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}


		var subPaths = extractSubpaths( this.actions );
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		var solid, tmpPath, tmpShape, shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		var i, il;

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = THREE.Shape.Utils.isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.actions = tmpPath.actions;
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			var ambiguous = false;
			var toChange = [];

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}
			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				var sho = newShapeHoles[ sIdx ];
				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					var ho = sho[ hIdx ];
					var hole_unassigned = true;
					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}
					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);
			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		var tmpHoles, j, jl;
		for ( i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];
			for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	};

	// File:src/extras/core/Shape.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	THREE.Shape = function () {

		THREE.Path.apply( this, arguments );
		this.holes = [];

	};

	THREE.Shape.prototype = Object.create( THREE.Path.prototype );
	THREE.Shape.prototype.constructor = THREE.Shape;

	// Convenience method to return ExtrudeGeometry

	THREE.Shape.prototype.extrude = function ( options ) {

		var extruded = new THREE.ExtrudeGeometry( this, options );
		return extruded;

	};

	// Convenience method to return ShapeGeometry

	THREE.Shape.prototype.makeGeometry = function ( options ) {

		var geometry = new THREE.ShapeGeometry( this, options );
		return geometry;

	};

	// Get points of holes

	THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

		var i, il = this.holes.length, holesPts = [];

		for ( i = 0; i < il; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

		}

		return holesPts;

	};

	// Get points of holes (spaced by regular distance)

	THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

		var i, il = this.holes.length, holesPts = [];

		for ( i = 0; i < il; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

		}

		return holesPts;

	};


	// Get points of shape and holes (keypoints based on segments parameter)

	THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

		return {

			shape: this.getTransformedPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	};

	THREE.Shape.prototype.extractPoints = function ( divisions ) {

		if ( this.useSpacedPoints ) {

			return this.extractAllSpacedPoints( divisions );

		}

		return this.extractAllPoints( divisions );

	};

	//
	// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
	//
	// 	return {
	//
	// 		shape: this.transform( bend, divisions ),
	// 		holes: this.getPointsHoles( divisions, bend )
	//
	// 	};
	//
	// };

	// Get points of shape and holes (spaced by regular distance)

	THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

		return {

			shape: this.getTransformedSpacedPoints( divisions ),
			holes: this.getSpacedPointsHoles( divisions )

		};

	};

	/**************************************************************
	 *	Utils
	 **************************************************************/

	THREE.Shape.Utils = {

		triangulateShape: function ( contour, holes ) {

			function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

				// inOtherPt needs to be collinear to the inSegment
				if ( inSegPt1.x !== inSegPt2.x ) {

					if ( inSegPt1.x < inSegPt2.x ) {

						return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

					} else {

						return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

					}

				} else {

					if ( inSegPt1.y < inSegPt2.y ) {

						return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

					} else {

						return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

					}

				}

			}

			function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

				var EPSILON = 0.0000000001;

				var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
				var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

				var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
				var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

				var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
				var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

				if ( Math.abs( limit ) > EPSILON ) {

					// not parallel

					var perpSeg2;
					if ( limit > 0 ) {

						if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

					} else {

						if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

					}

					// i.e. to reduce rounding errors
					// intersection at endpoint of segment#1?
					if ( perpSeg2 === 0 ) {

						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt1 ];

					}
					if ( perpSeg2 === limit ) {

						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt2 ];

					}
					// intersection at endpoint of segment#2?
					if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
					if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

					// return real intersection point
					var factorSeg1 = perpSeg2 / limit;
					return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
								y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

				} else {

					// parallel or collinear
					if ( ( perpSeg1 !== 0 ) ||
						 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

					// they are collinear or degenerate
					var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
					var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
					// both segments are points
					if ( seg1Pt && seg2Pt ) {

						if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
							 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
						return [ inSeg1Pt1 ];                 						// they are the same point

					}
					// segment#1  is a single point
					if ( seg1Pt ) {

						if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
						return [ inSeg1Pt1 ];

					}
					// segment#2  is a single point
					if ( seg2Pt ) {

						if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
						return [ inSeg2Pt1 ];

					}

					// they are collinear segments, which might overlap
					var seg1min, seg1max, seg1minVal, seg1maxVal;
					var seg2min, seg2max, seg2minVal, seg2maxVal;
					if ( seg1dx !== 0 ) {

						// the segments are NOT on a vertical line
						if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

						} else {

							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

						}
						if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

						} else {

							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

						}

					} else {

						// the segments are on a vertical line
						if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

						} else {

							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

						}
						if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

						} else {

							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

						}

					}
					if ( seg1minVal <= seg2minVal ) {

						if ( seg1maxVal <  seg2minVal )	return [];
						if ( seg1maxVal === seg2minVal )	{

							if ( inExcludeAdjacentSegs )		return [];
							return [ seg2min ];

						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
						return	[ seg2min, seg2max ];

					} else {

						if ( seg1minVal >  seg2maxVal )	return [];
						if ( seg1minVal === seg2maxVal )	{

							if ( inExcludeAdjacentSegs )		return [];
							return [ seg1min ];

						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
						return	[ seg1min, seg2max ];

					}

				}

			}

			function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

				// The order of legs is important

				var EPSILON = 0.0000000001;

				// translation of all points, so that Vertex is at (0,0)
				var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
				var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
				var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

				// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
				var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
				var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

				if ( Math.abs( from2toAngle ) > EPSILON ) {

					// angle != 180 deg.

					var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
					// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

					if ( from2toAngle > 0 ) {

						// main angle < 180 deg.
						return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

					} else {

						// main angle > 180 deg.
						return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

					}

				} else {

					// angle == 180 deg.
					// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
					return	( from2otherAngle > 0 );

				}

			}


			function removeHoles( contour, holes ) {

				var shape = contour.concat(); // work on this shape
				var hole;

				function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

					// Check if hole point lies within angle around shape point
					var lastShapeIdx = shape.length - 1;

					var prevShapeIdx = inShapeIdx - 1;
					if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

					var nextShapeIdx = inShapeIdx + 1;
					if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

					var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
					if ( ! insideAngle ) {

						// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
						return	false;

					}

					// Check if shape point lies within angle around hole point
					var lastHoleIdx = hole.length - 1;

					var prevHoleIdx = inHoleIdx - 1;
					if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

					var nextHoleIdx = inHoleIdx + 1;
					if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

					insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
					if ( ! insideAngle ) {

						// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
						return	false;

					}

					return	true;

				}

				function intersectsShapeEdge( inShapePt, inHolePt ) {

					// checks for intersections with shape edges
					var sIdx, nextIdx, intersection;
					for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

						nextIdx = sIdx + 1; nextIdx %= shape.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;

					}

					return	false;

				}

				var indepHoles = [];

				function intersectsHoleEdge( inShapePt, inHolePt ) {

					// checks for intersections with hole edges
					var ihIdx, chkHole,
						hIdx, nextIdx, intersection;
					for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

						chkHole = holes[ indepHoles[ ihIdx ]];
						for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

							nextIdx = hIdx + 1; nextIdx %= chkHole.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;

						}

					}
					return	false;

				}

				var holeIndex, shapeIndex,
					shapePt, holePt,
					holeIdx, cutKey, failedCuts = [],
					tmpShape1, tmpShape2,
					tmpHole1, tmpHole2;

				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

					indepHoles.push( h );

				}

				var minShapeIndex = 0;
				var counter = indepHoles.length * 2;
				while ( indepHoles.length > 0 ) {

					counter --;
					if ( counter < 0 ) {

						console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
						break;

					}

					// search for shape-vertex and hole-vertex,
					// which can be connected without intersections
					for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

						shapePt = shape[ shapeIndex ];
						holeIndex	= - 1;

						// search for hole which can be reached without intersections
						for ( var h = 0; h < indepHoles.length; h ++ ) {

							holeIdx = indepHoles[ h ];

							// prevent multiple checks
							cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
							if ( failedCuts[ cutKey ] !== undefined )			continue;

							hole = holes[ holeIdx ];
							for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

								holePt = hole[ h2 ];
								if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
								if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
								if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

								holeIndex = h2;
								indepHoles.splice( h, 1 );

								tmpShape1 = shape.slice( 0, shapeIndex + 1 );
								tmpShape2 = shape.slice( shapeIndex );
								tmpHole1 = hole.slice( holeIndex );
								tmpHole2 = hole.slice( 0, holeIndex + 1 );

								shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

								minShapeIndex = shapeIndex;

								// Debug only, to show the selected cuts
								// glob_CutLines.push( [ shapePt, holePt ] );

								break;

							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found

							failedCuts[ cutKey ] = true;			// remember failure

						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

					}

				}

				return shape; 			/* shape with no holes */

			}


			var i, il, f, face,
				key, index,
				allPointsMap = {};

			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

			var allpoints = contour.concat();

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				Array.prototype.push.apply( allpoints, holes[ h ] );

			}

			//console.log( "allpoints",allpoints, allpoints.length );

			// prepare all points map

			for ( i = 0, il = allpoints.length; i < il; i ++ ) {

				key = allpoints[ i ].x + ":" + allpoints[ i ].y;

				if ( allPointsMap[ key ] !== undefined ) {

					console.warn( "THREE.Shape: Duplicate point", key );

				}

				allPointsMap[ key ] = i;

			}

			// remove holes by cutting paths to holes and adding them to the shape
			var shapeWithoutHoles = removeHoles( contour, holes );

			var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
			//console.log( "triangles",triangles, triangles.length );

			// check all face vertices against all points map

			for ( i = 0, il = triangles.length; i < il; i ++ ) {

				face = triangles[ i ];

				for ( f = 0; f < 3; f ++ ) {

					key = face[ f ].x + ":" + face[ f ].y;

					index = allPointsMap[ key ];

					if ( index !== undefined ) {

						face[ f ] = index;

					}

				}

			}

			return triangles.concat();

		},

		isClockWise: function ( pts ) {

			return THREE.FontUtils.Triangulate.area( pts ) < 0;

		},

		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

		// Quad Bezier Functions

		b2p0: function ( t, p ) {

			var k = 1 - t;
			return k * k * p;

		},

		b2p1: function ( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		},

		b2p2: function ( t, p ) {

			return t * t * p;

		},

		b2: function ( t, p0, p1, p2 ) {

			return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

		},

		// Cubic Bezier Functions

		b3p0: function ( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		},

		b3p1: function ( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		},

		b3p2: function ( t, p ) {

			var k = 1 - t;
			return 3 * k * t * t * p;

		},

		b3p3: function ( t, p ) {

			return t * t * t * p;

		},

		b3: function ( t, p0, p1, p2, p3 ) {

			return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

		}

	};

	// File:src/extras/curves/LineCurve.js

	/**************************************************************
	 *	Line
	 **************************************************************/

	THREE.LineCurve = function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.LineCurve.prototype.constructor = THREE.LineCurve;

	THREE.LineCurve.prototype.getPoint = function ( t ) {

		var point = this.v2.clone().sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	THREE.LineCurve.prototype.getPointAt = function ( u ) {

		return this.getPoint( u );

	};

	THREE.LineCurve.prototype.getTangent = function( t ) {

		var tangent = this.v2.clone().sub( this.v1 );

		return tangent.normalize();

	};

	// File:src/extras/curves/QuadraticBezierCurve.js

	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/


	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

		var vector = new THREE.Vector2();

		vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

		return vector;

	};


	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

		var vector = new THREE.Vector2();

		vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

		// returns unit vector

		return vector.normalize();

	};

	// File:src/extras/curves/CubicBezierCurve.js

	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/

	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	};

	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

		var tx, ty;

		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

		return new THREE.Vector2( tx, ty );

	};

	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

		var tx, ty;

		tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

		var tangent = new THREE.Vector2( tx, ty );
		tangent.normalize();

		return tangent;

	};

	// File:src/extras/curves/SplineCurve.js

	/**************************************************************
	 *	Spline curve
	 **************************************************************/

	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

		this.points = ( points == undefined ) ? [] : points;

	};

	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

	THREE.SplineCurve.prototype.getPoint = function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var vector = new THREE.Vector2();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

		return vector;

	};

	// File:src/extras/curves/EllipseCurve.js

	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/

	THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;
		
		this.aRotation = aRotation || 0;

	};

	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

	THREE.EllipseCurve.prototype.getPoint = function ( t ) {

		var deltaAngle = this.aEndAngle - this.aStartAngle;

		if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
		if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

		var angle;

		if ( this.aClockwise === true ) {

			angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

		} else {

			angle = this.aStartAngle + t * deltaAngle;

		}
		
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );

			var tx = x, ty = y;

			// Rotate the point about the center of the ellipse.
			x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
			y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

		}

		return new THREE.Vector2( x, y );

	};

	// File:src/extras/curves/ArcCurve.js

	/**************************************************************
	 *	Arc curve
	 **************************************************************/

	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	};

	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
	THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

	// File:src/extras/curves/LineCurve3.js

	/**************************************************************
	 *	Line3D
	 **************************************************************/

	THREE.LineCurve3 = THREE.Curve.create(

		function ( v1, v2 ) {

			this.v1 = v1;
			this.v2 = v2;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );

			return vector;

		}

	);

	// File:src/extras/curves/QuadraticBezierCurve3.js

	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/

	THREE.QuadraticBezierCurve3 = THREE.Curve.create(

		function ( v0, v1, v2 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
			vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
			vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

			return vector;

		}

	);

	// File:src/extras/curves/CubicBezierCurve3.js

	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/

	THREE.CubicBezierCurve3 = THREE.Curve.create(

		function ( v0, v1, v2, v3 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
			vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
			vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

			return vector;

		}

	);

	// File:src/extras/curves/SplineCurve3.js

	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/


	THREE.SplineCurve3 = THREE.Curve.create(

		function ( points /* array of Vector3 */ ) {

			console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
			this.points = ( points == undefined ) ? [] : points;

		},

		function ( t ) {

			var points = this.points;
			var point = ( points.length - 1 ) * t;

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			var vector = new THREE.Vector3();

			vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
			vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
			vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

			return vector;

		}

	);

	// File:src/extras/curves/CatmullRomCurve3.js

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */

	THREE.CatmullRomCurve3 = ( function() {

		var
			tmp = new THREE.Vector3(),
			px = new CubicPoly(),
			py = new CubicPoly(),
			pz = new CubicPoly();

		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM

		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/

		function CubicPoly() {

		}

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

			this.c0 = x0;
			this.c1 = t0;
			this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

		};

		CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			// initCubicPoly
			this.init( x1, x2, t1, t2 );

		};

		// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
		CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

			this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		};

		CubicPoly.prototype.calc = function( t ) {

			var t2 = t * t;
			var t3 = t2 * t;
			return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

		};

		// Subclass Three.js curve
		return THREE.Curve.create(

			function ( p /* array of Vector3 */ ) {

				this.points = p || [];

			},

			function ( t ) {

				var points = this.points,
					point, intPoint, weight, l;

				l = points.length;

				if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

				point = ( l - 1 ) * t;
				intPoint = Math.floor( point );
				weight = point - intPoint;

				if ( weight === 0 && intPoint === l - 1 ) {

					intPoint = l - 2;
					weight = 1;

				}

				var p0, p1, p2, p3;

				if ( intPoint === 0 ) {

					// extrapolate first point
					tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
					p0 = tmp;

				} else {

					p0 = points[ intPoint - 1 ];

				}

				p1 = points[ intPoint ];
				p2 = points[ intPoint + 1 ];

				if ( intPoint + 2 < l ) {

					p3 = points[ intPoint + 2 ]

				} else {

					// extrapolate last point
					tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
					p3 = tmp;

				}

				if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

					// init Centripetal / Chordal Catmull-Rom
					var pow = this.type === 'chordal' ? 0.5 : 0.25;
					var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
					var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
					var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

					// safety check for repeated points
					if ( dt1 < 1e-4 ) dt1 = 1.0;
					if ( dt0 < 1e-4 ) dt0 = dt1;
					if ( dt2 < 1e-4 ) dt2 = dt1;

					px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
					py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
					pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

				} else if ( this.type === 'catmullrom' ) {

					var tension = this.tension !== undefined ? this.tension : 0.5;
					px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
					py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
					pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

				}

				var v = new THREE.Vector3(
					px.calc( weight ),
					py.calc( weight ),
					pz.calc( weight )
				);

				return v;

			}

		);

	} )();

	// File:src/extras/curves/ClosedSplineCurve3.js

	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/


	THREE.ClosedSplineCurve3 = THREE.Curve.create(

		function ( points /* array of Vector3 */ ) {

			this.points = ( points == undefined ) ? [] : points;

		},

		function ( t ) {

			var points = this.points;
			var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

			var point0 = points[ ( intPoint - 1 ) % points.length ];
			var point1 = points[ ( intPoint     ) % points.length ];
			var point2 = points[ ( intPoint + 1 ) % points.length ];
			var point3 = points[ ( intPoint + 2 ) % points.length ];

			var vector = new THREE.Vector3();

			vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
			vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
			vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

			return vector;

		}

	);

	// File:src/extras/animation/AnimationHandler.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 */

	THREE.AnimationHandler = {

		LINEAR: 0,
		CATMULLROM: 1,
		CATMULLROM_FORWARD: 2,

		//

		add: function () {

			console.warn( 'THREE.AnimationHandler.add() has been deprecated.' );

		},
		get: function () {

			console.warn( 'THREE.AnimationHandler.get() has been deprecated.' );

		},
		remove: function () {

			console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' );

		},

		//

		animations: [],

		init: function ( data ) {

			if ( data.initialized === true ) return data;

			// loop through all keys

			for ( var h = 0; h < data.hierarchy.length; h ++ ) {

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					// remove minus times

					if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

						 data.hierarchy[ h ].keys[ k ].time = 0;

					}

					// create quaternions

					if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
					  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

						var quat = data.hierarchy[ h ].keys[ k ].rot;
						data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

					}

				}

				// prepare morph target keys

				if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

					// get all used

					var usedMorphTargets = {};

					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
							usedMorphTargets[ morphTargetName ] = - 1;

						}

					}

					data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


					// set all used on all frames

					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

						var influences = {};

						for ( var morphTargetName in usedMorphTargets ) {

							for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

								if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

									influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
									break;

								}

							}

							if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

								influences[ morphTargetName ] = 0;

							}

						}

						data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

					}

				}


				// remove all keys that are on the same time

				for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

					if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

						data.hierarchy[ h ].keys.splice( k, 1 );
						k --;

					}

				}


				// set index

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					data.hierarchy[ h ].keys[ k ].index = k;

				}

			}

			data.initialized = true;

			return data;

		},

		parse: function ( root ) {

			var parseRecurseHierarchy = function ( root, hierarchy ) {

				hierarchy.push( root );

				for ( var c = 0; c < root.children.length; c ++ )
					parseRecurseHierarchy( root.children[ c ], hierarchy );

			};

			// setup hierarchy

			var hierarchy = [];

			if ( root instanceof THREE.SkinnedMesh ) {

				for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

					hierarchy.push( root.skeleton.bones[ b ] );

				}

			} else {

				parseRecurseHierarchy( root, hierarchy );

			}

			return hierarchy;

		},

		play: function ( animation ) {

			if ( this.animations.indexOf( animation ) === - 1 ) {

				this.animations.push( animation );

			}

		},

		stop: function ( animation ) {

			var index = this.animations.indexOf( animation );

			if ( index !== - 1 ) {

				this.animations.splice( index, 1 );

			}

		},

		update: function ( deltaTimeMS ) {

			for ( var i = 0; i < this.animations.length; i ++ ) {

				this.animations[ i ].resetBlendWeights();

			}

			for ( var i = 0; i < this.animations.length; i ++ ) {

				this.animations[ i ].update( deltaTimeMS );

			}

		}

	};

	// File:src/extras/animation/Animation.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Animation = function ( root, data ) {

		this.root = root;
		this.data = THREE.AnimationHandler.init( data );
		this.hierarchy = THREE.AnimationHandler.parse( root );

		this.currentTime = 0;
		this.timeScale = 1;

		this.isPlaying = false;
		this.loop = true;
		this.weight = 0;

		this.interpolationType = THREE.AnimationHandler.LINEAR;

	};

	THREE.Animation.prototype = {

		constructor: THREE.Animation,

		keyTypes:  [ "pos", "rot", "scl" ],

		play: function ( startTime, weight ) {

			this.currentTime = startTime !== undefined ? startTime : 0;
			this.weight = weight !== undefined ? weight : 1;

			this.isPlaying = true;

			this.reset();

			THREE.AnimationHandler.play( this );

		},

		stop: function() {

			this.isPlaying = false;

			THREE.AnimationHandler.stop( this );

		},

		reset: function () {

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];

				if ( object.animationCache === undefined ) {

					object.animationCache = {
						animations: {},
						blending: {
							positionWeight: 0.0,
							quaternionWeight: 0.0,
							scaleWeight: 0.0
						}
					};

				}

				var name = this.data.name;
				var animations = object.animationCache.animations;
				var animationCache = animations[ name ];

				if ( animationCache === undefined ) {

					animationCache = {
						prevKey: { pos: 0, rot: 0, scl: 0 },
						nextKey: { pos: 0, rot: 0, scl: 0 },
						originalMatrix: object.matrix
					};

					animations[ name ] = animationCache;

				}

				// Get keys to match our current time

				for ( var t = 0; t < 3; t ++ ) {

					var type = this.keyTypes[ t ];

					var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
					var nextKey = this.getNextKeyWith( type, h, 1 );

					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

					}

					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;

				}

			}

		},

		resetBlendWeights: function () {

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];
				var animationCache = object.animationCache;

				if ( animationCache !== undefined ) {

					var blending = animationCache.blending;

					blending.positionWeight = 0.0;
					blending.quaternionWeight = 0.0;
					blending.scaleWeight = 0.0;

				}

			}

		},

		update: ( function() {

			var points = [];
			var target = new THREE.Vector3();
			var newVector = new THREE.Vector3();
			var newQuat = new THREE.Quaternion();

			// Catmull-Rom spline

			var interpolateCatmullRom = function ( points, scale ) {

				var c = [], v3 = [],
				point, intPoint, weight, w2, w3,
				pa, pb, pc, pd;

				point = ( points.length - 1 ) * scale;
				intPoint = Math.floor( point );
				weight = point - intPoint;

				c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
				c[ 1 ] = intPoint;
				c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
				c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

				pa = points[ c[ 0 ] ];
				pb = points[ c[ 1 ] ];
				pc = points[ c[ 2 ] ];
				pd = points[ c[ 3 ] ];

				w2 = weight * weight;
				w3 = weight * w2;

				v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
				v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
				v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

				return v3;

			};

			var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

				var v0 = ( p2 - p0 ) * 0.5,
					v1 = ( p3 - p1 ) * 0.5;

				return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

			};

			return function ( delta ) {

				if ( this.isPlaying === false ) return;

				this.currentTime += delta * this.timeScale;

				if ( this.weight === 0 )
					return;

				//

				var duration = this.data.length;

				if ( this.currentTime > duration || this.currentTime < 0 ) {

					if ( this.loop ) {

						this.currentTime %= duration;

						if ( this.currentTime < 0 )
							this.currentTime += duration;

						this.reset();

					} else {

						this.stop();

					}

				}

				for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

					var object = this.hierarchy[ h ];
					var animationCache = object.animationCache.animations[ this.data.name ];
					var blending = object.animationCache.blending;

					// loop through pos/rot/scl

					for ( var t = 0; t < 3; t ++ ) {

						// get keys

						var type    = this.keyTypes[ t ];
						var prevKey = animationCache.prevKey[ type ];
						var nextKey = animationCache.nextKey[ type ];

						if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
							( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

							prevKey = this.data.hierarchy[ h ].keys[ 0 ];
							nextKey = this.getNextKeyWith( type, h, 1 );

							while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

								prevKey = nextKey;
								nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

							}

							animationCache.prevKey[ type ] = prevKey;
							animationCache.nextKey[ type ] = nextKey;

						}

						var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

						var prevXYZ = prevKey[ type ];
						var nextXYZ = nextKey[ type ];

						if ( scale < 0 ) scale = 0;
						if ( scale > 1 ) scale = 1;

						// interpolate

						if ( type === "pos" ) {

							if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

								newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
								newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
								newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

								// blend
								var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
								object.position.lerp( newVector, proportionalWeight );
								blending.positionWeight += this.weight;

							} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
										this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

								points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
								points[ 1 ] = prevXYZ;
								points[ 2 ] = nextXYZ;
								points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

								scale = scale * 0.33 + 0.33;

								var currentPoint = interpolateCatmullRom( points, scale );
								var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
								blending.positionWeight += this.weight;

								// blend

								var vector = object.position;

								vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
								vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
								vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

								if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

									var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

									target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
									target.sub( vector );
									target.y = 0;
									target.normalize();

									var angle = Math.atan2( target.x, target.z );
									object.rotation.set( 0, angle, 0 );

								}

							}

						} else if ( type === "rot" ) {

							THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

							// Avoid paying the cost of an additional slerp if we don't have to
							if ( blending.quaternionWeight === 0 ) {

								object.quaternion.copy( newQuat );
								blending.quaternionWeight = this.weight;

							} else {

								var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
								THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
								blending.quaternionWeight += this.weight;

							}

						} else if ( type === "scl" ) {

							newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
							newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
							newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

							var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
							object.scale.lerp( newVector, proportionalWeight );
							blending.scaleWeight += this.weight;

						}

					}

				}

				return true;

			};

		} )(),

		getNextKeyWith: function ( type, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;

			if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
				 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

				key = key < keys.length - 1 ? key : keys.length - 1;

			} else {

				key = key % keys.length;

			}

			for ( ; key < keys.length; key ++ ) {

				if ( keys[ key ][ type ] !== undefined ) {

					return keys[ key ];

				}

			}

			return this.data.hierarchy[ h ].keys[ 0 ];

		},

		getPrevKeyWith: function ( type, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;

			if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
				this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

				key = key > 0 ? key : 0;

			} else {

				key = key >= 0 ? key : key + keys.length;

			}


			for ( ; key >= 0; key -- ) {

				if ( keys[ key ][ type ] !== undefined ) {

					return keys[ key ];

				}

			}

			return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

		}

	};

	// File:src/extras/animation/KeyFrameAnimation.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author khang duong
	 * @author erik kitson
	 */

	THREE.KeyFrameAnimation = function ( data ) {

		this.root = data.node;
		this.data = THREE.AnimationHandler.init( data );
		this.hierarchy = THREE.AnimationHandler.parse( this.root );
		this.currentTime = 0;
		this.timeScale = 0.001;
		this.isPlaying = false;
		this.isPaused = true;
		this.loop = true;

		// initialize to first keyframes

		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

			var keys = this.data.hierarchy[ h ].keys,
				sids = this.data.hierarchy[ h ].sids,
				obj = this.hierarchy[ h ];

			if ( keys.length && sids ) {

				for ( var s = 0; s < sids.length; s ++ ) {

					var sid = sids[ s ],
						next = this.getNextKeyWith( sid, h, 0 );

					if ( next ) {

						next.apply( sid );

					}

				}

				obj.matrixAutoUpdate = false;
				this.data.hierarchy[ h ].node.updateMatrix();
				obj.matrixWorldNeedsUpdate = true;

			}

		}

	};

	THREE.KeyFrameAnimation.prototype = {

		constructor: THREE.KeyFrameAnimation,

		play: function ( startTime ) {

			this.currentTime = startTime !== undefined ? startTime : 0;

			if ( this.isPlaying === false ) {

				this.isPlaying = true;

				// reset key cache

				var h, hl = this.hierarchy.length,
					object,
					node;

				for ( h = 0; h < hl; h ++ ) {

					object = this.hierarchy[ h ];
					node = this.data.hierarchy[ h ];

					if ( node.animationCache === undefined ) {

						node.animationCache = {};
						node.animationCache.prevKey = null;
						node.animationCache.nextKey = null;
						node.animationCache.originalMatrix = object.matrix;

					}

					var keys = this.data.hierarchy[ h ].keys;

					if ( keys.length ) {

						node.animationCache.prevKey = keys[ 0 ];
						node.animationCache.nextKey = keys[ 1 ];

						this.startTime = Math.min( keys[ 0 ].time, this.startTime );
						this.endTime = Math.max( keys[ keys.length - 1 ].time, this.endTime );

					}

				}

				this.update( 0 );

			}

			this.isPaused = false;

			THREE.AnimationHandler.play( this );

		},

		stop: function () {

			this.isPlaying = false;
			this.isPaused  = false;

			THREE.AnimationHandler.stop( this );

			// reset JIT matrix and remove cache

			for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {

				var obj = this.hierarchy[ h ];
				var node = this.data.hierarchy[ h ];

				if ( node.animationCache !== undefined ) {

					var original = node.animationCache.originalMatrix;

					original.copy( obj.matrix );
					obj.matrix = original;

					delete node.animationCache;

				}

			}

		},

		update: function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta * this.timeScale;

			//

			var duration = this.data.length;

			if ( this.loop === true && this.currentTime > duration ) {

				this.currentTime %= duration;

			}

			this.currentTime = Math.min( this.currentTime, duration );

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];
				var node = this.data.hierarchy[ h ];

				var keys = node.keys,
					animationCache = node.animationCache;


				if ( keys.length ) {

					var prevKey = animationCache.prevKey;
					var nextKey = animationCache.nextKey;

					if ( nextKey.time <= this.currentTime ) {

						while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

							prevKey = nextKey;
							nextKey = keys[ prevKey.index + 1 ];

						}

						animationCache.prevKey = prevKey;
						animationCache.nextKey = nextKey;

					}

					if ( nextKey.time >= this.currentTime ) {

						prevKey.interpolate( nextKey, this.currentTime );

					} else {

						prevKey.interpolate( nextKey, nextKey.time );

					}

					this.data.hierarchy[ h ].node.updateMatrix();
					object.matrixWorldNeedsUpdate = true;

				}

			}

		},

		getNextKeyWith: function ( sid, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;
			key = key % keys.length;

			for ( ; key < keys.length; key ++ ) {

				if ( keys[ key ].hasTarget( sid ) ) {

					return keys[ key ];

				}

			}

			return keys[ 0 ];

		},

		getPrevKeyWith: function ( sid, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;
			key = key >= 0 ? key : key + keys.length;

			for ( ; key >= 0; key -- ) {

				if ( keys[ key ].hasTarget( sid ) ) {

					return keys[ key ];

				}

			}

			return keys[ keys.length - 1 ];

		}

	};

	// File:src/extras/animation/MorphAnimation.js

	/**
	 * @author mrdoob / http://mrdoob.com
	 * @author willy-vvu / http://willy-vvu.github.io
	 */

	THREE.MorphAnimation = function ( mesh ) {

		this.mesh = mesh;
		this.frames = mesh.morphTargetInfluences.length;
		this.currentTime = 0;
		this.duration = 1000;
		this.loop = true;
		this.lastFrame = 0;
		this.currentFrame = 0;

		this.isPlaying = false;

	};

	THREE.MorphAnimation.prototype = {

		constructor: THREE.MorphAnimation,

		play: function () {

			this.isPlaying = true;

		},

		pause: function () {

			this.isPlaying = false;

		},

		update: function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta;

			if ( this.loop === true && this.currentTime > this.duration ) {

				this.currentTime %= this.duration;

			}

			this.currentTime = Math.min( this.currentTime, this.duration );

			var frameTime = this.duration / this.frames;
			var frame = Math.floor( this.currentTime / frameTime );

			var influences = this.mesh.morphTargetInfluences;

			if ( frame !== this.currentFrame ) {

				influences[ this.lastFrame ] = 0;
				influences[ this.currentFrame ] = 1;
				influences[ frame ] = 0;

				this.lastFrame = this.currentFrame;
				this.currentFrame = frame;

			}

			var mix = ( this.currentTime % frameTime ) / frameTime;

			influences[ frame ] = mix;
			influences[ this.lastFrame ] = 1 - mix;

		}

	};

	// File:src/extras/geometries/BoxGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */

	THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		THREE.Geometry.call( this );

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
		this.depthSegments = depthSegments || 1;

		var scope = this;

		var width_half = width / 2;
		var height_half = height / 2;
		var depth_half = depth / 2;

		buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
		buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
		buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
		buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
		buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
		buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

		function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

			var w, ix, iy,
			gridX = scope.widthSegments,
			gridY = scope.heightSegments,
			width_half = width / 2,
			height_half = height / 2,
			offset = scope.vertices.length;

			if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

				w = 'z';

			} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

				w = 'y';
				gridY = scope.depthSegments;

			} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

				w = 'x';
				gridX = scope.depthSegments;

			}

			var gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			normal = new THREE.Vector3();

			normal[ w ] = depth > 0 ? 1 : - 1;

			for ( iy = 0; iy < gridY1; iy ++ ) {

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var vector = new THREE.Vector3();
					vector[ u ] = ( ix * segment_width - width_half ) * udir;
					vector[ v ] = ( iy * segment_height - height_half ) * vdir;
					vector[ w ] = depth;

					scope.vertices.push( vector );

				}

			}

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;

					var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
					var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
					var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
					var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

					var face = new THREE.Face3( a + offset, b + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;

					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

					face = new THREE.Face3( b + offset, c + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;

					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

				}

			}

		}

		this.mergeVertices();

	};

	THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

	THREE.BoxGeometry.prototype.clone = function () {

		var geometry = new THREE.BoxGeometry(
			this.parameters.width,
			this.parameters.height,
			this.parameters.depth,
			this.parameters.widthSegments,
			this.parameters.heightSegments,
			this.parameters.depthSegments
		);

		return geometry;

	};

	THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

	// File:src/extras/geometries/CircleGeometry.js

	/**
	 * @author hughes
	 */

	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		var i, uvs = [],
		center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

		this.vertices.push( center );
		uvs.push( centerUV );

		for ( i = 0; i <= segments; i ++ ) {

			var vertex = new THREE.Vector3();
			var segment = thetaStart + i / segments * thetaLength;

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

		}

		var n = new THREE.Vector3( 0, 0, 1 );

		for ( i = 1; i <= segments; i ++ ) {

			this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

	THREE.CircleGeometry.prototype.clone = function () {

		var geometry = new THREE.CircleGeometry(
			this.parameters.radius,
			this.parameters.segments,
			this.parameters.thetaStart,
			this.parameters.thetaLength
		);

		return geometry;

	};

	// File:src/extras/geometries/CircleBufferGeometry.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

		THREE.BufferGeometry.call( this );

		this.type = 'CircleBufferGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		var vertices = segments + 2;

		var positions = new Float32Array( vertices * 3 );
		var normals = new Float32Array( vertices * 3 );
		var uvs = new Float32Array( vertices * 2 );

		// center data is already zero, but need to set a few extras
		normals[ 3 ] = 1.0;
		uvs[ 0 ] = 0.5;
		uvs[ 1 ] = 0.5;

		for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

			var segment = thetaStart + s / segments * thetaLength;

			positions[ i ] = radius * Math.cos( segment );
			positions[ i + 1 ] = radius * Math.sin( segment );

			normals[ i + 2 ] = 1; // normal z

			uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
			uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

		}

		var indices = [];

		for ( var i = 1; i <= segments; i ++ ) {

			indices.push( i );
			indices.push( i + 1 );
			indices.push( 0 );

		}

		this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

	THREE.CircleBufferGeometry.prototype.clone = function () {

		var geometry = new THREE.CircleBufferGeometry(
			this.parameters.radius,
			this.parameters.segments,
			this.parameters.thetaStart,
			this.parameters.thetaLength
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/CylinderGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;

		radialSegments = radialSegments || 8;
		heightSegments = heightSegments || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

		var heightHalf = height / 2;

		var x, y, vertices = [], uvs = [];

		for ( y = 0; y <= heightSegments; y ++ ) {

			var verticesRow = [];
			var uvsRow = [];

			var v = y / heightSegments;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				var vertex = new THREE.Vector3();
				vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
				vertex.y = - v * height + heightHalf;
				vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

				this.vertices.push( vertex );

				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );

			}

			vertices.push( verticesRow );
			uvs.push( uvsRow );

		}

		var tanTheta = ( radiusBottom - radiusTop ) / height;
		var na, nb;

		for ( x = 0; x < radialSegments; x ++ ) {

			if ( radiusTop !== 0 ) {

				na = this.vertices[ vertices[ 0 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

			} else {

				na = this.vertices[ vertices[ 1 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

			}

			na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
			nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

			for ( y = 0; y < heightSegments; y ++ ) {

				var v1 = vertices[ y ][ x ];
				var v2 = vertices[ y + 1 ][ x ];
				var v3 = vertices[ y + 1 ][ x + 1 ];
				var v4 = vertices[ y ][ x + 1 ];

				var n1 = na.clone();
				var n2 = na.clone();
				var n3 = nb.clone();
				var n4 = nb.clone();

				var uv1 = uvs[ y ][ x ].clone();
				var uv2 = uvs[ y + 1 ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
				var uv4 = uvs[ y ][ x + 1 ].clone();

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

		// top cap

		if ( openEnded === false && radiusTop > 0 ) {

			this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

			for ( x = 0; x < radialSegments; x ++ ) {

				var v1 = vertices[ 0 ][ x ];
				var v2 = vertices[ 0 ][ x + 1 ];
				var v3 = this.vertices.length - 1;

				var n1 = new THREE.Vector3( 0, 1, 0 );
				var n2 = new THREE.Vector3( 0, 1, 0 );
				var n3 = new THREE.Vector3( 0, 1, 0 );

				var uv1 = uvs[ 0 ][ x ].clone();
				var uv2 = uvs[ 0 ][ x + 1 ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 0 );

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			}

		}

		// bottom cap

		if ( openEnded === false && radiusBottom > 0 ) {

			this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

			for ( x = 0; x < radialSegments; x ++ ) {

				var v1 = vertices[ heightSegments ][ x + 1 ];
				var v2 = vertices[ heightSegments ][ x ];
				var v3 = this.vertices.length - 1;

				var n1 = new THREE.Vector3( 0, - 1, 0 );
				var n2 = new THREE.Vector3( 0, - 1, 0 );
				var n3 = new THREE.Vector3( 0, - 1, 0 );

				var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
				var uv2 = uvs[ heightSegments ][ x ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 1 );

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			}

		}

		this.computeFaceNormals();

	};

	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

	THREE.CylinderGeometry.prototype.clone = function () {

		var geometry = new THREE.CylinderGeometry(
			this.parameters.radiusTop,
			this.parameters.radiusBottom,
			this.parameters.height,
			this.parameters.radialSegments,
			this.parameters.heightSegments,
			this.parameters.openEnded,
			this.parameters.thetaStart,
			this.parameters.thetaLength
		);

		return geometry;

	};

	// File:src/extras/geometries/EdgesGeometry.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

		THREE.BufferGeometry.call( this );

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) {

			return a - b;

		};

		var keys = [ 'a', 'b', 'c' ];

		var geometry2;

		if ( geometry instanceof THREE.BufferGeometry ) {

			geometry2 = new THREE.Geometry();
			geometry2.fromBufferGeometry( geometry );

		} else {

			geometry2 = geometry.clone();

		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var vertices = geometry2.vertices;
		var faces = geometry2.faces;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

				} else {

					hash[ key ].face2 = i;

				}

			}

		}

		var coords = [];

		for ( var key in hash ) {

			var h = hash[ key ];

			if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

				var vertex = vertices[ h.vert1 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );

				vertex = vertices[ h.vert2 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );

			}

		}

		this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

	};

	THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

	// File:src/extras/geometries/ExtrudeGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ExtrudeGeometry = function ( shapes, options ) {

		if ( typeof( shapes ) === "undefined" ) {

			shapes = [];
			return;

		}

		THREE.Geometry.call( this );

		this.type = 'ExtrudeGeometry';

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		this.addShapeList( shapes, options );

		this.computeFaceNormals();

		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides

		//this.computeVertexNormals();

		//console.log( "took", ( Date.now() - startTime ) );

	};

	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

		var sl = shapes.length;

		for ( var s = 0; s < sl; s ++ ) {

			var shape = shapes[ s ];
			this.addShape( shape, options );

		}

	};

	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

		var amount = options.amount !== undefined ? options.amount : 100;

		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var steps = options.steps !== undefined ? options.steps : 1;

		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;

		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {

			extrudePts = extrudePath.getSpacedPoints( steps );

			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion

			// SETUP TNB variables

			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?

			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();

		}

		// Safeguards if bevels are not enabled

		if ( ! bevelEnabled ) {

			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;

		}

		// Variables initialization

		var ahole, h, hl; // looping of holes
		var scope = this;

		var shapesOffset = this.vertices.length;

		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe ...

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

					holes[ h ] = ahole.reverse();

				}

			}

			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

		}


		var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

		/* Vertices */

		var contour = vertices; // vertices has all points but contour has only points of circumference

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			vertices = vertices.concat( ahole );

		}


		function scalePt2 ( pt, vec, size ) {

			if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

			return vec.clone().multiplyScalar( size ).add( pt );

		}

		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;


		// Find directions for point movement


		function getBevelVec( inPt, inPrev, inNext ) {

			var EPSILON = 0.0000000001;

			// computes for inPt the corresponding point inPt' on a new contour
			//   shifted by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.

			var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html

			var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

			// check for collinear edges
			var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			if ( Math.abs( collinear0 ) > EPSILON ) {

				// not collinear

				// length of vectors for normalizing

				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

				// shift adjacent points by unit vectors to the left

				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

				// scaling factor for v_prev to intersection point

				var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
						  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				// vector from inPt to intersection point

				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
				if ( v_trans_lensq <= 2 ) {

					return	new THREE.Vector2( v_trans_x, v_trans_y );

				} else {

					shrink_by = Math.sqrt( v_trans_lensq / 2 );

				}

			} else {

				// handle special case of collinear edges

				var direction_eq = false;		// assumes: opposite
				if ( v_prev_x > EPSILON ) {

					if ( v_next_x > EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( v_prev_x < - EPSILON ) {

						if ( v_next_x < - EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

							direction_eq = true;

						}

					}

				}

				if ( direction_eq ) {

					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y =  v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );

				} else {

					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );

				}

			}

			return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

		}


		var contourMovements = [];

		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)

			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

		}

		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			oneHoleMovements = [];

			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

			}

			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );

		}


		// Loop bevelSegments, 1 for the front, 1 for the back

		for ( b = 0; b < bevelSegments; b ++ ) {

			//for ( b = bevelSegments; b > 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );

			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
			//bs = bevelSize * t; // linear

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					v( vert.x, vert.y,  - z );

				}

			}

		}

		bs = bevelSize;

		// Back facing vertices

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, 0 );

			} else {

				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

				normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

		// Add stepped vertices...
		// Including front facing vertices

		var s;

		for ( s = 1; s <= steps; s ++ ) {

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, amount / steps * s );

				} else {

					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

					normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

		}


		// Add bevel segments planes

		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI / 2 );

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y,  amount + z );

					} else {

						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

					}

				}

			}

		}

		/* Faces */

		// Top and bottom faces

		buildLidFaces();

		// Sides faces

		buildSideFaces();


		/////  Internal functions

		function buildLidFaces() {

			if ( bevelEnabled ) {

				var layer = 0; // steps + 1
				var offset = vlen * layer;

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

				}

				layer = steps + bevelSegments * 2;
				offset = vlen * layer;

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

				}

			} else {

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );

				}

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

				}

			}

		}

		// Create faces for the z-sides of the shape

		function buildSideFaces() {

			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );

				//, true
				layeroffset += ahole.length;

			}

		}

		function sidewalls( contour, layeroffset ) {

			var j, k;
			i = contour.length;

			while ( -- i >= 0 ) {

				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;

				//console.log('b', i,j, i-1, k,vertices.length);

				var s = 0, sl = steps  + bevelSegments * 2;

				for ( s = 0; s < sl; s ++ ) {

					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );

					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;

					f4( a, b, c, d, contour, s, sl, j, k );

				}

			}

		}


		function v( x, y, z ) {

			scope.vertices.push( new THREE.Vector3( x, y, z ) );

		}

		function f3( a, b, c ) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;

			scope.faces.push( new THREE.Face3( a, b, c ) );

			var uvs = uvgen.generateTopUV( scope, a, b, c );

			scope.faceVertexUvs[ 0 ].push( uvs );

		}

		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;

			scope.faces.push( new THREE.Face3( a, b, d ) );
			scope.faces.push( new THREE.Face3( b, c, d ) );

			var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

			scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

		}

	};

	THREE.ExtrudeGeometry.WorldUVGenerator = {

		generateTopUV: function ( geometry, indexA, indexB, indexC ) {

			var vertices = geometry.vertices;

			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];

			return [
				new THREE.Vector2( a.x, a.y ),
				new THREE.Vector2( b.x, b.y ),
				new THREE.Vector2( c.x, c.y )
			];

		},

		generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

			var vertices = geometry.vertices;

			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
			var d = vertices[ indexD ];

			if ( Math.abs( a.y - b.y ) < 0.01 ) {

				return [
					new THREE.Vector2( a.x, 1 - a.z ),
					new THREE.Vector2( b.x, 1 - b.z ),
					new THREE.Vector2( c.x, 1 - c.z ),
					new THREE.Vector2( d.x, 1 - d.z )
				];

			} else {

				return [
					new THREE.Vector2( a.y, 1 - a.z ),
					new THREE.Vector2( b.y, 1 - b.z ),
					new THREE.Vector2( c.y, 1 - c.z ),
					new THREE.Vector2( d.y, 1 - d.z )
				];

			}

		}
	};

	// File:src/extras/geometries/ShapeGeometry.js

	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ShapeGeometry = function ( shapes, options ) {

		THREE.Geometry.call( this );

		this.type = 'ShapeGeometry';

		if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

		this.addShapeList( shapes, options );

		this.computeFaceNormals();

	};

	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			this.addShape( shapes[ i ], options );

		}

		return this;

	};

	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

		//

		var i, l, hole;

		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe...

			for ( i = 0, l = holes.length; i < l; i ++ ) {

				hole = holes[ i ];

				if ( THREE.Shape.Utils.isClockWise( hole ) ) {

					holes[ i ] = hole.reverse();

				}

			}

			reverse = false;

		}

		var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

		// Vertices

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];
			vertices = vertices.concat( hole );

		}

		//

		var vert, vlen = vertices.length;
		var face, flen = faces.length;

		for ( i = 0; i < vlen; i ++ ) {

			vert = vertices[ i ];

			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

		}

		for ( i = 0; i < flen; i ++ ) {

			face = faces[ i ];

			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;

			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

		}

	};

	// File:src/extras/geometries/LatheGeometry.js

	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 */

	// points - to create a closed torus, one must use a set of points 
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2*PI) range of the lathed section
	//    2*pi is a closed lathe, less than 2PI is a portion.

	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

		THREE.Geometry.call( this );

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = segments || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || 2 * Math.PI;

		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;

		for ( var i = 0, il = segments; i <= il; i ++ ) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var c = Math.cos( phi ),
				s = Math.sin( phi );

			for ( var j = 0, jl = points.length; j < jl; j ++ ) {

				var pt = points[ j ];

				var vertex = new THREE.Vector3();

				vertex.x = c * pt.x - s * pt.y;
				vertex.y = s * pt.x + c * pt.y;
				vertex.z = pt.z;

				this.vertices.push( vertex );

			}

		}

		var np = points.length;

		for ( var i = 0, il = segments; i < il; i ++ ) {

			for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

				var base = j + np * i;
				var a = base;
				var b = base + np;
				var c = base + 1 + np;
				var d = base + 1;

				var u0 = i * inverseSegments;
				var v0 = j * inversePointLength;
				var u1 = u0 + inverseSegments;
				var v1 = v0 + inversePointLength;

				this.faces.push( new THREE.Face3( a, b, d ) );

				this.faceVertexUvs[ 0 ].push( [

					new THREE.Vector2( u0, v0 ),
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u0, v1 )

				] );

				this.faces.push( new THREE.Face3( b, c, d ) );

				this.faceVertexUvs[ 0 ].push( [

					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u1, v1 ),
					new THREE.Vector2( u0, v1 )

				] );


			}

		}

		this.mergeVertices();
		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

	// File:src/extras/geometries/PlaneGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

		THREE.Geometry.call( this );

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

	};

	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

	THREE.PlaneGeometry.prototype.clone = function () {

		var geometry = new THREE.PlaneGeometry(
			this.parameters.width,
			this.parameters.height,
			this.parameters.widthSegments,
			this.parameters.heightSegments
		);

		return geometry;

	};

	// File:src/extras/geometries/PlaneBufferGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

		THREE.BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var vertices = new Float32Array( gridX1 * gridY1 * 3 );
		var normals = new Float32Array( gridX1 * gridY1 * 3 );
		var uvs = new Float32Array( gridX1 * gridY1 * 2 );

		var offset = 0;
		var offset2 = 0;

		for ( var iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( var ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices[ offset ] = x;
				vertices[ offset + 1 ] = - y;

				normals[ offset + 2 ] = 1;

				uvs[ offset2 ] = ix / gridX;
				uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

				offset += 3;
				offset2 += 2;

			}

		}

		offset = 0;

		var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

		for ( var iy = 0; iy < gridY; iy ++ ) {

			for ( var ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				indices[ offset ] = a;
				indices[ offset + 1 ] = b;
				indices[ offset + 2 ] = d;

				indices[ offset + 3 ] = b;
				indices[ offset + 4 ] = c;
				indices[ offset + 5 ] = d;

				offset += 6;

			}

		}

		this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	};

	THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

	THREE.PlaneBufferGeometry.prototype.clone = function () {

		var geometry = new THREE.PlaneBufferGeometry(
			this.parameters.width,
			this.parameters.height,
			this.parameters.widthSegments,
			this.parameters.heightSegments
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/RingGeometry.js

	/**
	 * @author Kaleb Murphy
	 */

	THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 0;
		outerRadius = outerRadius || 50;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

		var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

		for ( i = 0; i < phiSegments + 1; i ++ ) {

			// concentric circles inside ring

			for ( o = 0; o < thetaSegments + 1; o ++ ) {

				// number of segments per circle

				var vertex = new THREE.Vector3();
				var segment = thetaStart + o / thetaSegments * thetaLength;
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				this.vertices.push( vertex );
				uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

			}

			radius += radiusStep;

		}

		var n = new THREE.Vector3( 0, 0, 1 );

		for ( i = 0; i < phiSegments; i ++ ) {

			// concentric circles inside ring

			var thetaSegment = i * ( thetaSegments + 1 );

			for ( o = 0; o < thetaSegments ; o ++ ) {

				// number of segments per circle

				var segment = o + thetaSegment;

				var v1 = segment;
				var v2 = segment + thetaSegments + 1;
				var v3 = segment + thetaSegments + 2;

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

				v1 = segment;
				v2 = segment + thetaSegments + 2;
				v3 = segment + 1;

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

			}

		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

	THREE.RingGeometry.prototype.clone = function () {

		var geometry = new THREE.RingGeometry(
			this.parameters.innerRadius,
			this.parameters.outerRadius,
			this.parameters.thetaSegments,
			this.parameters.phiSegments,
			this.parameters.thetaStart,
			this.parameters.thetaLength
		);

		return geometry;

	};

	// File:src/extras/geometries/SphereGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

	};

	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

	THREE.SphereGeometry.prototype.clone = function () {

		var geometry = new THREE.SphereGeometry(
			this.parameters.radius,
			this.parameters.widthSegments,
			this.parameters.heightSegments,
			this.parameters.phiStart,
			this.parameters.phiLength,
			this.parameters.thetaStart,
			this.parameters.thetaLength
		);

		return geometry;

	};

	// File:src/extras/geometries/SphereBufferGeometry.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * based on THREE.SphereGeometry
	 */

	THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		THREE.BufferGeometry.call( this );

		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var thetaEnd = thetaStart + thetaLength;

		var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

		var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

		var index = 0, vertices = [], normal = new THREE.Vector3();

		for ( var y = 0; y <= heightSegments; y ++ ) {

			var verticesRow = [];

			var v = y / heightSegments;

			for ( var x = 0; x <= widthSegments; x ++ ) {

				var u = x / widthSegments;

				var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				var py = radius * Math.cos( thetaStart + v * thetaLength );
				var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				normal.set( px, py, pz ).normalize();

				positions.setXYZ( index, px, py, pz );
				normals.setXYZ( index, normal.x, normal.y, normal.z );
				uvs.setXY( index, u, 1 - v );

				verticesRow.push( index );

				index ++;

			}

			vertices.push( verticesRow );

		}

		var indices = [];

		for ( var y = 0; y < heightSegments; y ++ ) {

			for ( var x = 0; x < widthSegments; x ++ ) {

				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];

				if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
				if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

			}

		}

		this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
		this.addAttribute( 'position', positions );
		this.addAttribute( 'normal', normals );
		this.addAttribute( 'uv', uvs );

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

	THREE.SphereBufferGeometry.prototype.clone = function () {

		var geometry = new THREE.SphereBufferGeometry(
			this.parameters.radius,
			this.parameters.widthSegments,
			this.parameters.heightSegments,
			this.parameters.phiStart,
			this.parameters.phiLength,
			this.parameters.thetaStart,
			this.parameters.thetaLength
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/TextGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For creating 3D text geometry in three.js
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  size: 			<float>, 	// size of the text
	 *  height: 		<float>, 	// thickness to extrude text
	 *  curveSegments: 	<int>,		// number of points on the curves
	 *
	 *  font: 			<string>,		// font name
	 *  weight: 		<string>,		// font weight (normal, bold)
	 *  style: 			<string>,		// font style  (normal, italics)
	 *
	 *  bevelEnabled:	<bool>,			// turn on bevel
	 *  bevelThickness: <float>, 		// how deep into text bevel goes
	 *  bevelSize:		<float>, 		// how far from text outline is bevel
	 *  }
	 *
	 */

	/*	Usage Examples

		// TextGeometry wrapper

		var text3d = new TextGeometry( text, options );

		// Complete manner

		var textShapes = THREE.FontUtils.generateShapes( text, options );
		var text3d = new ExtrudeGeometry( textShapes, options );

	*/


	THREE.TextGeometry = function ( text, parameters ) {

		parameters = parameters || {};

		var textShapes = THREE.FontUtils.generateShapes( text, parameters );

		// translate parameters to ExtrudeGeometry API

		parameters.amount = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		THREE.ExtrudeGeometry.call( this, textShapes, parameters );

		this.type = 'TextGeometry';

	};

	THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
	THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

	// File:src/extras/geometries/TorusGeometry.js

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */

	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

		THREE.Geometry.call( this );

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 8;
		tubularSegments = tubularSegments || 6;
		arc = arc || Math.PI * 2;

		var center = new THREE.Vector3(), uvs = [], normals = [];

		for ( var j = 0; j <= radialSegments; j ++ ) {

			for ( var i = 0; i <= tubularSegments; i ++ ) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );

				var vertex = new THREE.Vector3();
				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				this.vertices.push( vertex );

				uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
				normals.push( vertex.clone().sub( center ).normalize() );

			}

		}

		for ( var j = 1; j <= radialSegments; j ++ ) {

			for ( var i = 1; i <= tubularSegments; i ++ ) {

				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;

				var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

				face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

			}

		}

		this.computeFaceNormals();

	};

	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

	THREE.TorusGeometry.prototype.clone = function () {

		var geometry = new THREE.TorusGeometry(
			this.parameters.radius,
			this.parameters.tube,
			this.parameters.radialSegments,
			this.parameters.tubularSegments,
			this.parameters.arc
		);

		return geometry;

	};

	// File:src/extras/geometries/TorusKnotGeometry.js

	/**
	 * @author oosmoxiecode
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
	 */

	THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

		THREE.Geometry.call( this );

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			p: p,
			q: q,
			heightScale: heightScale
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 64;
		tubularSegments = tubularSegments || 8;
		p = p || 2;
		q = q || 3;
		heightScale = heightScale || 1;

		var grid = new Array( radialSegments );
		var tang = new THREE.Vector3();
		var n = new THREE.Vector3();
		var bitan = new THREE.Vector3();

		for ( var i = 0; i < radialSegments; ++ i ) {

			grid[ i ] = new Array( tubularSegments );
			var u = i / radialSegments * 2 * p * Math.PI;
			var p1 = getPos( u, q, p, radius, heightScale );
			var p2 = getPos( u + 0.01, q, p, radius, heightScale );
			tang.subVectors( p2, p1 );
			n.addVectors( p2, p1 );

			bitan.crossVectors( tang, n );
			n.crossVectors( bitan, tang );
			bitan.normalize();
			n.normalize();

			for ( var j = 0; j < tubularSegments; ++ j ) {

				var v = j / tubularSegments * 2 * Math.PI;
				var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				var cy = tube * Math.sin( v );

				var pos = new THREE.Vector3();
				pos.x = p1.x + cx * n.x + cy * bitan.x;
				pos.y = p1.y + cx * n.y + cy * bitan.y;
				pos.z = p1.z + cx * n.z + cy * bitan.z;

				grid[ i ][ j ] = this.vertices.push( pos ) - 1;

			}

		}

		for ( var i = 0; i < radialSegments; ++ i ) {

			for ( var j = 0; j < tubularSegments; ++ j ) {

				var ip = ( i + 1 ) % radialSegments;
				var jp = ( j + 1 ) % tubularSegments;

				var a = grid[ i ][ j ];
				var b = grid[ ip ][ j ];
				var c = grid[ ip ][ jp ];
				var d = grid[ i ][ jp ];

				var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
				var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
				var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
				var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

		this.computeFaceNormals();
		this.computeVertexNormals();

		function getPos( u, in_q, in_p, radius, heightScale ) {

			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = in_q / in_p * u;
			var cs = Math.cos( quOverP );

			var tx = radius * ( 2 + cs ) * 0.5 * cu;
			var ty = radius * ( 2 + cs ) * su * 0.5;
			var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

			return new THREE.Vector3( tx, ty, tz );

		}

	};

	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

	THREE.TorusKnotGeometry.prototype.clone = function () {

		var geometry = new THREE.TorusKnotGeometry(
			this.parameters.radius,
			this.parameters.tube,
			this.parameters.radialSegments,
			this.parameters.tubularSegments,
			this.parameters.p,
			this.parameters.q,
			this.parameters.heightScale
		);

		return geometry;

	};

	// File:src/extras/geometries/TubeGeometry.js

	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */

	THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

		THREE.Geometry.call( this );

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			segments: segments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		segments = segments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
		taper = taper || THREE.TubeGeometry.NoTaper;

		var grid = [];

		var scope = this,

			tangent,
			normal,
			binormal,

			numpoints = segments + 1,

			u, v, r,

			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;

		var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;

		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		function vert( x, y, z ) {

			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

		}

		// construct the grid

		for ( i = 0; i < numpoints; i ++ ) {

			grid[ i ] = [];

			u = i / ( numpoints - 1 );

			pos = path.getPointAt( u );

			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];

			r = radius * taper( u );

			for ( j = 0; j < radialSegments; j ++ ) {

				v = j / radialSegments * 2 * Math.PI;

				cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = r * Math.sin( v );

				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;

				grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

			}

		}


		// construct the mesh

		for ( i = 0; i < segments; i ++ ) {

			for ( j = 0; j < radialSegments; j ++ ) {

				ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
				jp = ( j + 1 ) % radialSegments;

				a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = grid[ ip ][ j ];
				c = grid[ ip ][ jp ];
				d = grid[ i ][ jp ];

				uva = new THREE.Vector2( i / segments, j / radialSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
				uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

	THREE.TubeGeometry.NoTaper = function ( u ) {

		return 1;

	};

	THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

		return Math.sin( Math.PI * u );

	};

	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

		var	normal = new THREE.Vector3(),

			tangents = [],
			normals = [],
			binormals = [],

			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),

			numpoints = segments + 1,
			theta,
			epsilon = 0.0001,
			smallest,

			tx, ty, tz,
			i, u;


		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		// compute the tangent vectors for each segment on the path

		for ( i = 0; i < numpoints; i ++ ) {

			u = i / ( numpoints - 1 );

			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();

		}

		initialNormal3();

		/*
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}

		function initialNormal2() {

			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );

			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

		}
		*/

		function initialNormal3() {

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component

			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= smallest ) {

				smallest = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= smallest ) {

				smallest = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= smallest ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

		}


		// compute the slowly-varying normal and binormal vectors for each segment on the path

		for ( i = 1; i < numpoints; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > epsilon ) {

				vec.normalize();

				theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}


		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed ) {

			theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
			theta /= ( numpoints - 1 );

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( i = 1; i < numpoints; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

	};

	// File:src/extras/geometries/PolyhedronGeometry.js

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

		THREE.Geometry.call( this );

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		var that = this;

		for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

			prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

		}

		var p = this.vertices;

		var faces = [];

		for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

			var v1 = p[ indices[ i ] ];
			var v2 = p[ indices[ i + 1 ] ];
			var v3 = p[ indices[ i + 2 ] ];

			faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

		}

		var centroid = new THREE.Vector3();

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			subdivide( faces[ i ], detail );

		}


		// Handle case when face straddles the seam

		for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

			var uvs = this.faceVertexUvs[ 0 ][ i ];

			var x0 = uvs[ 0 ].x;
			var x1 = uvs[ 1 ].x;
			var x2 = uvs[ 2 ].x;

			var max = Math.max( x0, Math.max( x1, x2 ) );
			var min = Math.min( x0, Math.min( x1, x2 ) );

			if ( max > 0.9 && min < 0.1 ) {

				// 0.9 is somewhat arbitrary

				if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
				if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
				if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

			}

		}


		// Apply radius

		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

			this.vertices[ i ].multiplyScalar( radius );

		}


		// Merge vertices

		this.mergeVertices();

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


		// Project vector onto sphere's surface

		function prepare( vector ) {

			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;

			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );

			return vertex;

		}


		// Approximate a curved face with recursively sub-divided triangles.

		function make( v1, v2, v3, materialIndex ) {

			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
			that.faces.push( face );

			centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

			var azi = azimuth( centroid );

			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );

		}


		// Analytically subdivide a face to the required detail level.

		function subdivide( face, detail ) {

			var cols = Math.pow( 2, detail );
			var a = prepare( that.vertices[ face.a ] );
			var b = prepare( that.vertices[ face.b ] );
			var c = prepare( that.vertices[ face.c ] );
			var v = [];

			var materialIndex = face.materialIndex;

			// Construct all of the vertices for this subdivision.

			for ( var i = 0 ; i <= cols; i ++ ) {

				v[ i ] = [];

				var aj = prepare( a.clone().lerp( c, i / cols ) );
				var bj = prepare( b.clone().lerp( c, i / cols ) );
				var rows = cols - i;

				for ( var j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

					}

				}

			}

			// Construct all of the faces.

			for ( var i = 0; i < cols ; i ++ ) {

				for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					var k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k ],
							v[ i ][ k ],
							materialIndex
						);

					} else {

						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k + 1 ],
							v[ i + 1 ][ k ],
							materialIndex
						);

					}

				}

			}

		}


		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}


		// Texture fixing helper. Spheres have some odd behaviours.

		function correctUV( uv, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv.clone();

		}


	};

	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

	THREE.PolyhedronGeometry.prototype.clone = function () {

		var geometry = new THREE.PolyhedronGeometry(
			this.parameters.vertices,
			this.parameters.indices,
			this.parameters.radius,
			this.parameters.detail
		);

		return geometry.copy( this );

	};

	THREE.PolyhedronGeometry.prototype.copy = function ( source ) {

		THREE.Geometry.prototype.copy.call( this, source );
		return this;

	};

	// File:src/extras/geometries/DodecahedronGeometry.js

	/**
	 * @author Abe Pazos / https://hamoid.com
	 */

	THREE.DodecahedronGeometry = function ( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;

		var vertices = [

			// (1, 1, 1)
			- 1, - 1, - 1,    - 1, - 1,  1,
			- 1,  1, - 1,    - 1,  1,  1,
			 1, - 1, - 1,     1, - 1,  1,
			 1,  1, - 1,     1,  1,  1,

			// (0, 1/, )
			 0, - r, - t,     0, - r,  t,
			 0,  r, - t,     0,  r,  t,

			// (1/, , 0)
			- r, - t,  0,    - r,  t,  0,
			 r, - t,  0,     r,  t,  0,

			// (, 0, 1/)
			- t,  0, - r,     t,  0, - r,
			- t,  0,  r,     t,  0,  r
		];

		var indices = [
			 3, 11,  7,      3,  7, 15,      3, 15, 13,
			 7, 19, 17,      7, 17,  6,      7,  6, 15,
			17,  4,  8,     17,  8, 10,     17, 10,  6,
			 8,  0, 16,      8, 16,  2,      8,  2, 10,
			 0, 12,  1,      0,  1, 18,      0, 18, 16,
			 6, 10,  2,      6,  2, 13,      6, 13, 15,
			 2, 16, 18,      2, 18,  3,      2,  3, 13,
			18,  1,  9,     18,  9, 11,     18, 11,  3,
			 4, 14, 12,      4, 12,  0,      4,  0,  8,
			11,  9,  5,     11,  5, 19,     11, 19,  7,
			19,  5, 14,     19, 14,  4,     19,  4, 17,
			 1, 12, 14,      1, 14,  5,      1,  5,  9
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

	THREE.DodecahedronGeometry.prototype.clone = function () {

		var geometry = new THREE.DodecahedronGeometry(
			this.parameters.radius,
			this.parameters.detail
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/IcosahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.IcosahedronGeometry = function ( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

		var vertices = [
			- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
			 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
			 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
		];

		var indices = [
			 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
			 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
			 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
			 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

	THREE.IcosahedronGeometry.prototype.clone = function () {

		var geometry = new THREE.IcosahedronGeometry(
			this.parameters.radius,
			this.parameters.detail
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/OctahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.OctahedronGeometry = function ( radius, detail ) {

		var vertices = [
			1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
		];

		var indices = [
			0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

	THREE.OctahedronGeometry.prototype.clone = function () {

		var geometry = new THREE.OctahedronGeometry(
			this.parameters.radius,
			this.parameters.detail
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/TetrahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.TetrahedronGeometry = function ( radius, detail ) {

		var vertices = [
			 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
		];

		var indices = [
			 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

	THREE.TetrahedronGeometry.prototype.clone = function () {

		var geometry = new THREE.TetrahedronGeometry(
			this.parameters.radius,
			this.parameters.detail
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/ParametricGeometry.js

	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */

	THREE.ParametricGeometry = function ( func, slices, stacks ) {

		THREE.Geometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];

		var i, j, p;
		var u, v;

		var sliceCount = slices + 1;

		for ( i = 0; i <= stacks; i ++ ) {

			v = i / stacks;

			for ( j = 0; j <= slices; j ++ ) {

				u = j / slices;

				p = func( u, v );
				verts.push( p );

			}

		}

		var a, b, c, d;
		var uva, uvb, uvc, uvd;

		for ( i = 0; i < stacks; i ++ ) {

			for ( j = 0; j < slices; j ++ ) {

				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = ( i + 1 ) * sliceCount + j + 1;
				d = ( i + 1 ) * sliceCount + j;

				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

				faces.push( new THREE.Face3( a, b, d ) );
				uvs.push( [ uva, uvb, uvd ] );

				faces.push( new THREE.Face3( b, c, d ) );
				uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

		// console.log(this);

		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

	// File:src/extras/geometries/WireframeGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WireframeGeometry = function ( geometry ) {

		THREE.BufferGeometry.call( this );

		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) {

			return a - b;

		};

		var keys = [ 'a', 'b', 'c' ];

		if ( geometry instanceof THREE.Geometry ) {

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var numEdges = 0;

			// allocate maximal size
			var edges = new Uint32Array( 6 * faces.length );

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0; j < 3; j ++ ) {

					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );

					var key = edge.toString();

					if ( hash[ key ] === undefined ) {

						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var vertex = vertices[ edges [ 2 * i + j ] ];

					var index = 6 * i + 3 * j;
					coords[ index + 0 ] = vertex.x;
					coords[ index + 1 ] = vertex.y;
					coords[ index + 2 ] = vertex.z;

				}

			}

			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else if ( geometry instanceof THREE.BufferGeometry ) {

			if ( geometry.index !== null ) {

				// Indexed BufferGeometry

				var indices = geometry.index.array;
				var vertices = geometry.attributes.position;
				var drawcalls = geometry.drawcalls;
				var numEdges = 0;

				if ( drawcalls.length === 0 ) {

					geometry.addDrawCall( 0, indices.length );

				}

				// allocate maximal size
				var edges = new Uint32Array( 2 * indices.length );

				for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

					var drawcall = drawcalls[ o ];

					var start = drawcall.start;
					var count = drawcall.count;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						for ( var j = 0; j < 3; j ++ ) {

							edge[ 0 ] = indices[ i + j ];
							edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
							edge.sort( sortFunction );

							var key = edge.toString();

							if ( hash[ key ] === undefined ) {

								edges[ 2 * numEdges ] = edge[ 0 ];
								edges[ 2 * numEdges + 1 ] = edge[ 1 ];
								hash[ key ] = true;
								numEdges ++;

							}

						}

					}

				}

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numEdges; i < l; i ++ ) {

					for ( var j = 0; j < 2; j ++ ) {

						var index = 6 * i + 3 * j;
						var index2 = edges[ 2 * i + j ];

						coords[ index + 0 ] = vertices.getX( index2 );
						coords[ index + 1 ] = vertices.getY( index2 );
						coords[ index + 2 ] = vertices.getZ( index2 );

					}

				}

				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

			} else {

				// non-indexed BufferGeometry

				var vertices = geometry.attributes.position.array;
				var numEdges = vertices.length / 3;
				var numTris = numEdges / 3;

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numTris; i < l; i ++ ) {

					for ( var j = 0; j < 3; j ++ ) {

						var index = 18 * i + 6 * j;

						var index1 = 9 * i + 3 * j;
						coords[ index + 0 ] = vertices[ index1 ];
						coords[ index + 1 ] = vertices[ index1 + 1 ];
						coords[ index + 2 ] = vertices[ index1 + 2 ];

						var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
						coords[ index + 3 ] = vertices[ index2 ];
						coords[ index + 4 ] = vertices[ index2 + 1 ];
						coords[ index + 5 ] = vertices[ index2 + 2 ];

					}

				}

				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

			}

		}

	};

	THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

	// File:src/extras/helpers/AxisHelper.js

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AxisHelper = function ( size ) {

		size = size || 1;

		var vertices = new Float32Array( [
			0, 0, 0,  size, 0, 0,
			0, 0, 0,  0, size, 0,
			0, 0, 0,  0, 0, size
		] );

		var colors = new Float32Array( [
			1, 0, 0,  1, 0.6, 0,
			0, 1, 0,  0.6, 1, 0,
			0, 0, 1,  0, 0.6, 1
		] );

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

		THREE.LineSegments.call( this, geometry, material );

	};

	THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

	// File:src/extras/helpers/ArrowHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	THREE.ArrowHelper = ( function () {

		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

		var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );

		return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

			// dir is assumed to be normalized

			THREE.Object3D.call( this );

			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;

			this.position.copy( origin );
			
			if ( headLength < length ) {
				this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
				this.line.matrixAutoUpdate = false;
				this.add( this.line );
			}

			this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );

			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );

		}

	}() );

	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

	THREE.ArrowHelper.prototype.setDirection = ( function () {

		var axis = new THREE.Vector3();
		var radians;

		return function setDirection( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				axis.set( dir.z, 0, - dir.x ).normalize();

				radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( axis, radians );

			}

		};

	}() );

	THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		if ( headLength < length ){
			this.line.scale.set( 1, length - headLength, 1 );
			this.line.updateMatrix();
		}

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	THREE.ArrowHelper.prototype.setColor = function ( color ) {

		if ( this.line !== undefined ) this.line.material.color.set( color );
		this.cone.material.color.set( color );

	};

	// File:src/extras/helpers/BoxHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BoxHelper = function ( object ) {

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );

		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );

		if ( object !== undefined ) {

			this.update( object );

		}

	};

	THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

	THREE.BoxHelper.prototype.update = ( function () {

		var box = new THREE.Box3();

		return function ( object ) {

			box.setFromObject( object );

			if ( box.empty() ) return;

			var min = box.min;
			var max = box.max;

			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;

			array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
			array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
			array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
			array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();

		}

	} )();

	// File:src/extras/helpers/BoundingBoxHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	// a helper to show the world-axis-aligned bounding box for an object

	THREE.BoundingBoxHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0x888888;

		this.object = object;

		this.box = new THREE.Box3();

		THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

	};

	THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

	THREE.BoundingBoxHelper.prototype.update = function () {

		this.box.setFromObject( this.object );

		this.box.size( this.scale );

		this.box.center( this.position );

	};

	// File:src/extras/helpers/CameraHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	THREE.CameraHelper = function ( camera ) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

		var pointMap = {};

		// colors

		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;

		// near

		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );

		// far

		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );

		// sides

		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );

		// cone

		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );

		// up

		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );

		// target

		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );

		// cross

		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );

		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );

		function addLine( a, b, hex ) {

			addPoint( a, hex );
			addPoint( b, hex );

		}

		function addPoint( id, hex ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( hex ) );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( geometry.vertices.length - 1 );

		}

		THREE.LineSegments.call( this, geometry, material );

		this.camera = camera;
		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	};

	THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

	THREE.CameraHelper.prototype.update = function () {

		var geometry, pointMap;

		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();

		var setPoint = function ( point, x, y, z ) {

			vector.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					geometry.vertices[ points[ i ] ].copy( vector );

				}

			}

		};

		return function () {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix
			// world matrix must be identity

			camera.projectionMatrix.copy( this.camera.projectionMatrix );

			// center / target

			setPoint( "c", 0, 0, - 1 );
			setPoint( "t", 0, 0,  1 );

			// near

			setPoint( "n1", - w, - h, - 1 );
			setPoint( "n2",   w, - h, - 1 );
			setPoint( "n3", - w,   h, - 1 );
			setPoint( "n4",   w,   h, - 1 );

			// far

			setPoint( "f1", - w, - h, 1 );
			setPoint( "f2",   w, - h, 1 );
			setPoint( "f3", - w,   h, 1 );
			setPoint( "f4",   w,   h, 1 );

			// up

			setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
			setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
			setPoint( "u3",         0, h * 2,   - 1 );

			// cross

			setPoint( "cf1", - w,   0, 1 );
			setPoint( "cf2",   w,   0, 1 );
			setPoint( "cf3",   0, - h, 1 );
			setPoint( "cf4",   0,   h, 1 );

			setPoint( "cn1", - w,   0, - 1 );
			setPoint( "cn2",   w,   0, - 1 );
			setPoint( "cn3",   0, - h, - 1 );
			setPoint( "cn4",   0,   h, - 1 );

			geometry.verticesNeedUpdate = true;

		};

	}();

	// File:src/extras/helpers/DirectionalLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.DirectionalLightHelper = function ( light, size ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		size = size || 1;

		var geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3( - size,   size, 0 ),
			new THREE.Vector3(   size,   size, 0 ),
			new THREE.Vector3(   size, - size, 0 ),
			new THREE.Vector3( - size, - size, 0 ),
			new THREE.Vector3( - size,   size, 0 )
		);

		var material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.lightPlane = new THREE.Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3(),
			new THREE.Vector3()
		);

		material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine = new THREE.Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	};

	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

	THREE.DirectionalLightHelper.prototype.dispose = function () {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	};

	THREE.DirectionalLightHelper.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();

		return function () {

			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );

			this.lightPlane.lookAt( v3 );
			this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			this.targetLine.geometry.vertices[ 1 ].copy( v3 );
			this.targetLine.geometry.verticesNeedUpdate = true;
			this.targetLine.material.color.copy( this.lightPlane.material.color );

		};

	}();

	// File:src/extras/helpers/EdgesHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @param object THREE.Mesh whose geometry will be used
	 * @param hex line color
	 * @param thresholdAngle the minimum angle (in degrees),
	 * between the face normals of adjacent faces,
	 * that is required to render an edge. A value of 10 means
	 * an edge is only rendered if the angle is at least 10 degrees.
	 */

	THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

		var color = ( hex !== undefined ) ? hex : 0xffffff;

		THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

	// File:src/extras/helpers/FaceNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

		// FaceNormalsHelper only supports THREE.Geometry

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry instanceof THREE.Geometry ) {

			nNormals = objGeometry.faces.length;

		} else {

			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

		}

		//

		var geometry = new THREE.BufferGeometry();

		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;
		this.update();

	};

	THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

	THREE.FaceNormalsHelper.prototype.update = ( function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();

		return function update() {

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var normal = face.normal;

				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );

				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

			position.needsUpdate = true;

			return this;

		}

	}() );

	// File:src/extras/helpers/GridHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GridHelper = function ( size, step ) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

		this.color1 = new THREE.Color( 0x444444 );
		this.color2 = new THREE.Color( 0x888888 );

		for ( var i = - size; i <= size; i += step ) {

			geometry.vertices.push(
				new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
				new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
			);

			var color = i === 0 ? this.color1 : this.color2;

			geometry.colors.push( color, color, color, color );

		}

		THREE.LineSegments.call( this, geometry, material );

	};

	THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.GridHelper.prototype.constructor = THREE.GridHelper;

	THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

		this.color1.set( colorCenterLine );
		this.color2.set( colorGrid );

		this.geometry.colorsNeedUpdate = true;

	};

	// File:src/extras/helpers/HemisphereLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.HemisphereLightHelper = function ( light, sphereSize ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.colors = [ new THREE.Color(), new THREE.Color() ];

		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		geometry.rotateX( - Math.PI / 2 );

		for ( var i = 0, il = 8; i < il; i ++ ) {

			geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

		}

		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

		this.lightSphere = new THREE.Mesh( geometry, material );
		this.add( this.lightSphere );

		this.update();

	};

	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

	THREE.HemisphereLightHelper.prototype.dispose = function () {

		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();

	};

	THREE.HemisphereLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();

		return function () {

			this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
			this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

			this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
			this.lightSphere.geometry.colorsNeedUpdate = true;

		}

	}();

	// File:src/extras/helpers/PointLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PointLightHelper = function ( light, sphereSize ) {

		this.light = light;
		this.light.updateMatrixWorld();

		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		THREE.Mesh.call( this, geometry, material );

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

	};

	THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

	THREE.PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();

	};

	THREE.PointLightHelper.prototype.update = function () {

		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	};

	// File:src/extras/helpers/SkeletonHelper.js

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkeletonHelper = function ( object ) {

		this.bones = this.getBoneList( object );

		var geometry = new THREE.Geometry();

		for ( var i = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent instanceof THREE.Bone ) {

				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
				geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
				geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

			}

		}

		geometry.dynamic = true;

		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

		THREE.LineSegments.call( this, geometry, material );

		this.root = object;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();

	};


	THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

	THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

		var boneList = [];

		if ( object instanceof THREE.Bone ) {

			boneList.push( object );

		}

		for ( var i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

		}

		return boneList;

	};

	THREE.SkeletonHelper.prototype.update = function () {

		var geometry = this.geometry;

		var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

		var boneMatrix = new THREE.Matrix4();

		var j = 0;

		for ( var i = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent instanceof THREE.Bone ) {

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

				j += 2;

			}

		}

		geometry.verticesNeedUpdate = true;

		geometry.computeBoundingSphere();

	};

	// File:src/extras/helpers/SpotLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.SpotLightHelper = function ( light ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

		geometry.translate( 0, - 0.5, 0 );
		geometry.rotateX( - Math.PI / 2 );

		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

		this.cone = new THREE.Mesh( geometry, material );
		this.add( this.cone );

		this.update();

	};

	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

	THREE.SpotLightHelper.prototype.dispose = function () {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	};

	THREE.SpotLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();

		return function () {

			var coneLength = this.light.distance ? this.light.distance : 10000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( vector2.sub( vector ) );

			this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		};

	}();

	// File:src/extras/helpers/VertexNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xff0000;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry instanceof THREE.Geometry ) {

			nNormals = objGeometry.faces.length * 3;

		} else if ( objGeometry instanceof THREE.BufferGeometry ) {

			nNormals = objGeometry.attributes.normal.count

		}

		//

		var geometry = new THREE.BufferGeometry();

		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;

		this.update();

	};

	THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

	THREE.VertexNormalsHelper.prototype.update = ( function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();

		return function update() {

			var keys = [ 'a', 'b', 'c' ];

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			if ( objGeometry instanceof THREE.Geometry ) {

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						var vertex = vertices[ face[ keys[ j ] ] ];

						var normal = face.vertexNormals[ j ];

						v1.copy( vertex ).applyMatrix4( matrixWorld );

						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

						position.setXYZ( idx, v1.x, v1.y, v1.z );

						idx = idx + 1;

						position.setXYZ( idx, v2.x, v2.y, v2.z );

						idx = idx + 1;

					}

				}

			} else if ( objGeometry instanceof THREE.BufferGeometry ) {

				var objPos = objGeometry.attributes.position;

				var objNorm = objGeometry.attributes.normal;

				var idx = 0;

				// for simplicity, ignore index and drawcalls, and render every normal

				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

			position.needsUpdate = true;

			return this;

		}

	}() );

	// File:src/extras/helpers/WireframeHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WireframeHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0xffffff;

		THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

	// File:src/extras/objects/ImmediateRenderObject.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ImmediateRenderObject = function () {

		THREE.Object3D.call( this );

		this.render = function ( renderCallback ) {};

	};

	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

	// File:src/extras/objects/MorphBlendMesh.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MorphBlendMesh = function( geometry, material ) {

		THREE.Mesh.call( this, geometry, material );

		this.animationsMap = {};
		this.animationsList = [];

		// prepare default animation
		// (all frames played together in 1 second)

		var numFrames = this.geometry.morphTargets.length;

		var name = "__default";

		var startFrame = 0;
		var endFrame = numFrames - 1;

		var fps = numFrames / 1;

		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );

	};

	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

		var animation = {

			start: start,
			end: end,

			length: end - start + 1,

			fps: fps,
			duration: ( end - start ) / fps,

			lastFrame: 0,
			currentFrame: 0,

			active: false,

			time: 0,
			direction: 1,
			weight: 1,

			directionBackwards: false,
			mirroredLoop: false

		};

		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );

	};

	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

		var pattern = /([a-z]+)_?(\d+)/;

		var firstAnimation, frameRanges = {};

		var geometry = this.geometry;

		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );

			if ( chunks && chunks.length > 1 ) {

				var name = chunks[ 1 ];

				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

				var range = frameRanges[ name ];

				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;

				if ( ! firstAnimation ) firstAnimation = name;

			}

		}

		for ( var name in frameRanges ) {

			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );

		}

		this.firstAnimation = firstAnimation;

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.direction = 1;
			animation.directionBackwards = false;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.direction = - 1;
			animation.directionBackwards = true;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.weight = weight;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.time = time;

		}

	};

	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

		var time = 0;

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			time = animation.time;

		}

		return time;

	};

	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

		var duration = - 1;

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			duration = animation.duration;

		}

		return duration;

	};

	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.time = 0;
			animation.active = true;

		} else {

			console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

		}

	};

	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.active = false;

		}

	};

	THREE.MorphBlendMesh.prototype.update = function ( delta ) {

		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

			var animation = this.animationsList[ i ];

			if ( ! animation.active ) continue;

			var frameTime = animation.duration / animation.length;

			animation.time += animation.direction * delta;

			if ( animation.mirroredLoop ) {

				if ( animation.time > animation.duration || animation.time < 0 ) {

					animation.direction *= - 1;

					if ( animation.time > animation.duration ) {

						animation.time = animation.duration;
						animation.directionBackwards = true;

					}

					if ( animation.time < 0 ) {

						animation.time = 0;
						animation.directionBackwards = false;

					}

				}

			} else {

				animation.time = animation.time % animation.duration;

				if ( animation.time < 0 ) animation.time += animation.duration;

			}

			var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;

			if ( keyframe !== animation.currentFrame ) {

				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

				this.morphTargetInfluences[ keyframe ] = 0;

				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;

			}

			var mix = ( animation.time % frameTime ) / frameTime;

			if ( animation.directionBackwards ) mix = 1 - mix;

			if ( animation.currentFrame !== animation.lastFrame ) {

				this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
				this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

			} else {

				this.morphTargetInfluences[ animation.currentFrame ] = weight;

			}

		}

	};



/***/ },
/* 196 */
/*!**********************************!*\
  !*** ./~/cannon/build/cannon.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/*
	 * Copyright (c) 2015 cannon.js Authors
	 *
	 * Permission is hereby granted, free of charge, to any person
	 * obtaining a copy of this software and associated documentation
	 * files (the "Software"), to deal in the Software without
	 * restriction, including without limitation the rights to use, copy,
	 * modify, merge, publish, distribute, sublicense, and/or sell copies
	 * of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */

	!function(e){if(true)module.exports=e();else if("function"==typeof define&&false)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.CANNON=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	module.exports={
	  "name": "cannon",
	  "version": "0.6.2",
	  "description": "A lightweight 3D physics engine written in JavaScript.",
	  "homepage": "https://github.com/schteppe/cannon.js",
	  "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
	  "keywords": [
	    "cannon.js",
	    "cannon",
	    "physics",
	    "engine",
	    "3d"
	  ],
	  "main": "./build/cannon.js",
	  "engines": {
	    "node": "*"
	  },
	  "repository": {
	    "type": "git",
	    "url": "https://github.com/schteppe/cannon.js.git"
	  },
	  "bugs": {
	    "url": "https://github.com/schteppe/cannon.js/issues"
	  },
	  "licenses": [
	    {
	      "type": "MIT"
	    }
	  ],
	  "devDependencies": {
	    "jshint": "latest",
	    "uglify-js": "latest",
	    "nodeunit": "^0.9.0",
	    "grunt": "~0.4.0",
	    "grunt-contrib-jshint": "~0.1.1",
	    "grunt-contrib-nodeunit": "^0.4.1",
	    "grunt-contrib-concat": "~0.1.3",
	    "grunt-contrib-uglify": "^0.5.1",
	    "grunt-browserify": "^2.1.4",
	    "grunt-contrib-yuidoc": "^0.5.2",
	    "browserify": "*"
	  },
	  "dependencies": {}
	}

	},{}],2:[function(_dereq_,module,exports){
	// Export classes
	module.exports = {
	    version :                       _dereq_('../package.json').version,

	    AABB :                          _dereq_('./collision/AABB'),
	    ArrayCollisionMatrix :          _dereq_('./collision/ArrayCollisionMatrix'),
	    Body :                          _dereq_('./objects/Body'),
	    Box :                           _dereq_('./shapes/Box'),
	    Broadphase :                    _dereq_('./collision/Broadphase'),
	    Constraint :                    _dereq_('./constraints/Constraint'),
	    ContactEquation :               _dereq_('./equations/ContactEquation'),
	    Narrowphase :                   _dereq_('./world/Narrowphase'),
	    ConeTwistConstraint :           _dereq_('./constraints/ConeTwistConstraint'),
	    ContactMaterial :               _dereq_('./material/ContactMaterial'),
	    ConvexPolyhedron :              _dereq_('./shapes/ConvexPolyhedron'),
	    Cylinder :                      _dereq_('./shapes/Cylinder'),
	    DistanceConstraint :            _dereq_('./constraints/DistanceConstraint'),
	    Equation :                      _dereq_('./equations/Equation'),
	    EventTarget :                   _dereq_('./utils/EventTarget'),
	    FrictionEquation :              _dereq_('./equations/FrictionEquation'),
	    GSSolver :                      _dereq_('./solver/GSSolver'),
	    GridBroadphase :                _dereq_('./collision/GridBroadphase'),
	    Heightfield :                   _dereq_('./shapes/Heightfield'),
	    HingeConstraint :               _dereq_('./constraints/HingeConstraint'),
	    LockConstraint :                _dereq_('./constraints/LockConstraint'),
	    Mat3 :                          _dereq_('./math/Mat3'),
	    Material :                      _dereq_('./material/Material'),
	    NaiveBroadphase :               _dereq_('./collision/NaiveBroadphase'),
	    ObjectCollisionMatrix :         _dereq_('./collision/ObjectCollisionMatrix'),
	    Pool :                          _dereq_('./utils/Pool'),
	    Particle :                      _dereq_('./shapes/Particle'),
	    Plane :                         _dereq_('./shapes/Plane'),
	    PointToPointConstraint :        _dereq_('./constraints/PointToPointConstraint'),
	    Quaternion :                    _dereq_('./math/Quaternion'),
	    Ray :                           _dereq_('./collision/Ray'),
	    RaycastVehicle :                _dereq_('./objects/RaycastVehicle'),
	    RaycastResult :                 _dereq_('./collision/RaycastResult'),
	    RigidVehicle :                  _dereq_('./objects/RigidVehicle'),
	    RotationalEquation :            _dereq_('./equations/RotationalEquation'),
	    RotationalMotorEquation :       _dereq_('./equations/RotationalMotorEquation'),
	    SAPBroadphase :                 _dereq_('./collision/SAPBroadphase'),
	    SPHSystem :                     _dereq_('./objects/SPHSystem'),
	    Shape :                         _dereq_('./shapes/Shape'),
	    Solver :                        _dereq_('./solver/Solver'),
	    Sphere :                        _dereq_('./shapes/Sphere'),
	    SplitSolver :                   _dereq_('./solver/SplitSolver'),
	    Spring :                        _dereq_('./objects/Spring'),
	    Trimesh :                       _dereq_('./shapes/Trimesh'),
	    Vec3 :                          _dereq_('./math/Vec3'),
	    Vec3Pool :                      _dereq_('./utils/Vec3Pool'),
	    World :                         _dereq_('./world/World'),
	};

	},{"../package.json":1,"./collision/AABB":3,"./collision/ArrayCollisionMatrix":4,"./collision/Broadphase":5,"./collision/GridBroadphase":6,"./collision/NaiveBroadphase":7,"./collision/ObjectCollisionMatrix":8,"./collision/Ray":9,"./collision/RaycastResult":10,"./collision/SAPBroadphase":11,"./constraints/ConeTwistConstraint":12,"./constraints/Constraint":13,"./constraints/DistanceConstraint":14,"./constraints/HingeConstraint":15,"./constraints/LockConstraint":16,"./constraints/PointToPointConstraint":17,"./equations/ContactEquation":19,"./equations/Equation":20,"./equations/FrictionEquation":21,"./equations/RotationalEquation":22,"./equations/RotationalMotorEquation":23,"./material/ContactMaterial":24,"./material/Material":25,"./math/Mat3":27,"./math/Quaternion":28,"./math/Vec3":30,"./objects/Body":31,"./objects/RaycastVehicle":32,"./objects/RigidVehicle":33,"./objects/SPHSystem":34,"./objects/Spring":35,"./shapes/Box":37,"./shapes/ConvexPolyhedron":38,"./shapes/Cylinder":39,"./shapes/Heightfield":40,"./shapes/Particle":41,"./shapes/Plane":42,"./shapes/Shape":43,"./shapes/Sphere":44,"./shapes/Trimesh":45,"./solver/GSSolver":46,"./solver/Solver":47,"./solver/SplitSolver":48,"./utils/EventTarget":49,"./utils/Pool":51,"./utils/Vec3Pool":54,"./world/Narrowphase":55,"./world/World":56}],3:[function(_dereq_,module,exports){
	var Vec3 = _dereq_('../math/Vec3');
	var Utils = _dereq_('../utils/Utils');

	module.exports = AABB;

	/**
	 * Axis aligned bounding box class.
	 * @class AABB
	 * @constructor
	 * @param {Object} [options]
	 * @param {Vec3}   [options.upperBound]
	 * @param {Vec3}   [options.lowerBound]
	 */
	function AABB(options){
	    options = options || {};

	    /**
	     * The lower bound of the bounding box.
	     * @property lowerBound
	     * @type {Vec3}
	     */
	    this.lowerBound = new Vec3();
	    if(options.lowerBound){
	        this.lowerBound.copy(options.lowerBound);
	    }

	    /**
	     * The upper bound of the bounding box.
	     * @property upperBound
	     * @type {Vec3}
	     */
	    this.upperBound = new Vec3();
	    if(options.upperBound){
	        this.upperBound.copy(options.upperBound);
	    }
	}

	var tmp = new Vec3();

	/**
	 * Set the AABB bounds from a set of points.
	 * @method setFromPoints
	 * @param {Array} points An array of Vec3's.
	 * @param {Vec3} position
	 * @param {Quaternion} quaternion
	 * @param {number} skinSize
	 * @return {AABB} The self object
	 */
	AABB.prototype.setFromPoints = function(points, position, quaternion, skinSize){
	    var l = this.lowerBound,
	        u = this.upperBound,
	        q = quaternion;

	    // Set to the first point
	    l.copy(points[0]);
	    if(q){
	        q.vmult(l, l);
	    }
	    u.copy(l);

	    for(var i = 1; i<points.length; i++){
	        var p = points[i];

	        if(q){
	            q.vmult(p, tmp);
	            p = tmp;
	        }

	        if(p.x > u.x){ u.x = p.x; }
	        if(p.x < l.x){ l.x = p.x; }
	        if(p.y > u.y){ u.y = p.y; }
	        if(p.y < l.y){ l.y = p.y; }
	        if(p.z > u.z){ u.z = p.z; }
	        if(p.z < l.z){ l.z = p.z; }
	    }

	    // Add offset
	    if (position) {
	        position.vadd(l, l);
	        position.vadd(u, u);
	    }

	    if(skinSize){
	        l.x -= skinSize;
	        l.y -= skinSize;
	        l.z -= skinSize;
	        u.x += skinSize;
	        u.y += skinSize;
	        u.z += skinSize;
	    }

	    return this;
	};

	/**
	 * Copy bounds from an AABB to this AABB
	 * @method copy
	 * @param  {AABB} aabb Source to copy from
	 * @return {AABB} The this object, for chainability
	 */
	AABB.prototype.copy = function(aabb){
	    this.lowerBound.copy(aabb.lowerBound);
	    this.upperBound.copy(aabb.upperBound);
	    return this;
	};

	/**
	 * Clone an AABB
	 * @method clone
	 */
	AABB.prototype.clone = function(){
	    return new AABB().copy(this);
	};

	/**
	 * Extend this AABB so that it covers the given AABB too.
	 * @method extend
	 * @param  {AABB} aabb
	 */
	AABB.prototype.extend = function(aabb){
	    // Extend lower bound
	    var l = aabb.lowerBound.x;
	    if(this.lowerBound.x > l){
	        this.lowerBound.x = l;
	    }

	    // Upper
	    var u = aabb.upperBound.x;
	    if(this.upperBound.x < u){
	        this.upperBound.x = u;
	    }

	    // Extend lower bound
	    var l = aabb.lowerBound.y;
	    if(this.lowerBound.y > l){
	        this.lowerBound.y = l;
	    }

	    // Upper
	    var u = aabb.upperBound.y;
	    if(this.upperBound.y < u){
	        this.upperBound.y = u;
	    }

	    // Extend lower bound
	    var l = aabb.lowerBound.z;
	    if(this.lowerBound.z > l){
	        this.lowerBound.z = l;
	    }

	    // Upper
	    var u = aabb.upperBound.z;
	    if(this.upperBound.z < u){
	        this.upperBound.z = u;
	    }
	};

	/**
	 * Returns true if the given AABB overlaps this AABB.
	 * @method overlaps
	 * @param  {AABB} aabb
	 * @return {Boolean}
	 */
	AABB.prototype.overlaps = function(aabb){
	    var l1 = this.lowerBound,
	        u1 = this.upperBound,
	        l2 = aabb.lowerBound,
	        u2 = aabb.upperBound;

	    //      l2        u2
	    //      |---------|
	    // |--------|
	    // l1       u1

	    return ((l2.x <= u1.x && u1.x <= u2.x) || (l1.x <= u2.x && u2.x <= u1.x)) &&
	           ((l2.y <= u1.y && u1.y <= u2.y) || (l1.y <= u2.y && u2.y <= u1.y)) &&
	           ((l2.z <= u1.z && u1.z <= u2.z) || (l1.z <= u2.z && u2.z <= u1.z));
	};

	/**
	 * Returns true if the given AABB is fully contained in this AABB.
	 * @method contains
	 * @param {AABB} aabb
	 * @return {Boolean}
	 */
	AABB.prototype.contains = function(aabb){
	    var l1 = this.lowerBound,
	        u1 = this.upperBound,
	        l2 = aabb.lowerBound,
	        u2 = aabb.upperBound;

	    //      l2        u2
	    //      |---------|
	    // |---------------|
	    // l1              u1

	    return (
	        (l1.x <= l2.x && u1.x >= u2.x) &&
	        (l1.y <= l2.y && u1.y >= u2.y) &&
	        (l1.z <= l2.z && u1.z >= u2.z)
	    );
	};

	/**
	 * @method getCorners
	 * @param {Vec3} a
	 * @param {Vec3} b
	 * @param {Vec3} c
	 * @param {Vec3} d
	 * @param {Vec3} e
	 * @param {Vec3} f
	 * @param {Vec3} g
	 * @param {Vec3} h
	 */
	AABB.prototype.getCorners = function(a, b, c, d, e, f, g, h){
	    var l = this.lowerBound,
	        u = this.upperBound;

	    a.copy(l);
	    b.set( u.x, l.y, l.z );
	    c.set( u.x, u.y, l.z );
	    d.set( l.x, u.y, u.z );
	    e.set( u.x, l.y, l.z );
	    f.set( l.x, u.y, l.z );
	    g.set( l.x, l.y, u.z );
	    h.copy(u);
	};

	var transformIntoFrame_corners = [
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3()
	];

	/**
	 * Get the representation of an AABB in another frame.
	 * @method toLocalFrame
	 * @param  {Transform} frame
	 * @param  {AABB} target
	 * @return {AABB} The "target" AABB object.
	 */
	AABB.prototype.toLocalFrame = function(frame, target){

	    var corners = transformIntoFrame_corners;
	    var a = corners[0];
	    var b = corners[1];
	    var c = corners[2];
	    var d = corners[3];
	    var e = corners[4];
	    var f = corners[5];
	    var g = corners[6];
	    var h = corners[7];

	    // Get corners in current frame
	    this.getCorners(a, b, c, d, e, f, g, h);

	    // Transform them to new local frame
	    for(var i=0; i !== 8; i++){
	        var corner = corners[i];
	        frame.pointToLocal(corner, corner);
	    }

	    return target.setFromPoints(corners);
	};

	/**
	 * Get the representation of an AABB in the global frame.
	 * @method toWorldFrame
	 * @param  {Transform} frame
	 * @param  {AABB} target
	 * @return {AABB} The "target" AABB object.
	 */
	AABB.prototype.toWorldFrame = function(frame, target){

	    var corners = transformIntoFrame_corners;
	    var a = corners[0];
	    var b = corners[1];
	    var c = corners[2];
	    var d = corners[3];
	    var e = corners[4];
	    var f = corners[5];
	    var g = corners[6];
	    var h = corners[7];

	    // Get corners in current frame
	    this.getCorners(a, b, c, d, e, f, g, h);

	    // Transform them to new local frame
	    for(var i=0; i !== 8; i++){
	        var corner = corners[i];
	        frame.pointToWorld(corner, corner);
	    }

	    return target.setFromPoints(corners);
	};

	},{"../math/Vec3":30,"../utils/Utils":53}],4:[function(_dereq_,module,exports){
	module.exports = ArrayCollisionMatrix;

	/**
	 * Collision "matrix". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
	 * @class ArrayCollisionMatrix
	 * @constructor
	 */
	function ArrayCollisionMatrix() {

	    /**
	     * The matrix storage
	     * @property matrix
	     * @type {Array}
	     */
		this.matrix = [];
	}

	/**
	 * Get an element
	 * @method get
	 * @param  {Number} i
	 * @param  {Number} j
	 * @return {Number}
	 */
	ArrayCollisionMatrix.prototype.get = function(i, j) {
		i = i.index;
		j = j.index;
	    if (j > i) {
	        var temp = j;
	        j = i;
	        i = temp;
	    }
		return this.matrix[(i*(i + 1)>>1) + j-1];
	};

	/**
	 * Set an element
	 * @method set
	 * @param {Number} i
	 * @param {Number} j
	 * @param {Number} value
	 */
	ArrayCollisionMatrix.prototype.set = function(i, j, value) {
		i = i.index;
		j = j.index;
	    if (j > i) {
	        var temp = j;
	        j = i;
	        i = temp;
	    }
		this.matrix[(i*(i + 1)>>1) + j-1] = value ? 1 : 0;
	};

	/**
	 * Sets all elements to zero
	 * @method reset
	 */
	ArrayCollisionMatrix.prototype.reset = function() {
		for (var i=0, l=this.matrix.length; i!==l; i++) {
			this.matrix[i]=0;
		}
	};

	/**
	 * Sets the max number of objects
	 * @method setNumObjects
	 * @param {Number} n
	 */
	ArrayCollisionMatrix.prototype.setNumObjects = function(n) {
		this.matrix.length = n*(n-1)>>1;
	};

	},{}],5:[function(_dereq_,module,exports){
	var Body = _dereq_('../objects/Body');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Shape = _dereq_('../shapes/Shape');
	var Plane = _dereq_('../shapes/Plane');

	module.exports = Broadphase;

	/**
	 * Base class for broadphase implementations
	 * @class Broadphase
	 * @constructor
	 * @author schteppe
	 */
	function Broadphase(){
	    /**
	    * The world to search for collisions in.
	    * @property world
	    * @type {World}
	    */
	    this.world = null;

	    /**
	     * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.
	     * @property useBoundingBoxes
	     * @type {Boolean}
	     */
	    this.useBoundingBoxes = false;

	    /**
	     * Set to true if the objects in the world moved.
	     * @property {Boolean} dirty
	     */
	    this.dirty = true;
	}

	/**
	 * Get the collision pairs from the world
	 * @method collisionPairs
	 * @param {World} world The world to search in
	 * @param {Array} p1 Empty array to be filled with body objects
	 * @param {Array} p2 Empty array to be filled with body objects
	 */
	Broadphase.prototype.collisionPairs = function(world,p1,p2){
	    throw new Error("collisionPairs not implemented for this BroadPhase class!");
	};

	/**
	 * Check if a body pair needs to be intersection tested at all.
	 * @method needBroadphaseCollision
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @return {bool}
	 */
	var Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC = Body.STATIC | Body.KINEMATIC;
	Broadphase.prototype.needBroadphaseCollision = function(bodyA,bodyB){

	    // Check collision filter masks
	    if( (bodyA.collisionFilterGroup & bodyB.collisionFilterMask)===0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask)===0){
	        return false;
	    }

	    // Check types
	    if(((bodyA.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyA.sleepState === Body.SLEEPING) &&
	       ((bodyB.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyB.sleepState === Body.SLEEPING)) {
	        // Both bodies are static, kinematic or sleeping. Skip.
	        return false;
	    }

	    return true;
	};

	/**
	 * Check if the bounding volumes of two bodies intersect.
	 * @method intersectionTest
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {array} pairs1
	 * @param {array} pairs2
	  */
	Broadphase.prototype.intersectionTest = function(bodyA, bodyB, pairs1, pairs2){
	    if(this.useBoundingBoxes){
	        this.doBoundingBoxBroadphase(bodyA,bodyB,pairs1,pairs2);
	    } else {
	        this.doBoundingSphereBroadphase(bodyA,bodyB,pairs1,pairs2);
	    }
	};

	/**
	 * Check if the bounding spheres of two bodies are intersecting.
	 * @method doBoundingSphereBroadphase
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Array} pairs1 bodyA is appended to this array if intersection
	 * @param {Array} pairs2 bodyB is appended to this array if intersection
	 */
	var Broadphase_collisionPairs_r = new Vec3(), // Temp objects
	    Broadphase_collisionPairs_normal =  new Vec3(),
	    Broadphase_collisionPairs_quat =  new Quaternion(),
	    Broadphase_collisionPairs_relpos  =  new Vec3();
	Broadphase.prototype.doBoundingSphereBroadphase = function(bodyA,bodyB,pairs1,pairs2){
	    var r = Broadphase_collisionPairs_r;
	    bodyB.position.vsub(bodyA.position,r);
	    var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);
	    var norm2 = r.norm2();
	    if(norm2 < boundingRadiusSum2){
	        pairs1.push(bodyA);
	        pairs2.push(bodyB);
	    }
	};

	/**
	 * Check if the bounding boxes of two bodies are intersecting.
	 * @method doBoundingBoxBroadphase
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Array} pairs1
	 * @param {Array} pairs2
	 */
	Broadphase.prototype.doBoundingBoxBroadphase = function(bodyA,bodyB,pairs1,pairs2){
	    if(bodyA.aabbNeedsUpdate){
	        bodyA.computeAABB();
	    }
	    if(bodyB.aabbNeedsUpdate){
	        bodyB.computeAABB();
	    }

	    // Check AABB / AABB
	    if(bodyA.aabb.overlaps(bodyB.aabb)){
	        pairs1.push(bodyA);
	        pairs2.push(bodyB);
	    }
	};

	/**
	 * Removes duplicate pairs from the pair arrays.
	 * @method makePairsUnique
	 * @param {Array} pairs1
	 * @param {Array} pairs2
	 */
	var Broadphase_makePairsUnique_temp = { keys:[] },
	    Broadphase_makePairsUnique_p1 = [],
	    Broadphase_makePairsUnique_p2 = [];
	Broadphase.prototype.makePairsUnique = function(pairs1,pairs2){
	    var t = Broadphase_makePairsUnique_temp,
	        p1 = Broadphase_makePairsUnique_p1,
	        p2 = Broadphase_makePairsUnique_p2,
	        N = pairs1.length;

	    for(var i=0; i!==N; i++){
	        p1[i] = pairs1[i];
	        p2[i] = pairs2[i];
	    }

	    pairs1.length = 0;
	    pairs2.length = 0;

	    for(var i=0; i!==N; i++){
	        var id1 = p1[i].id,
	            id2 = p2[i].id;
	        var key = id1 < id2 ? id1+","+id2 :  id2+","+id1;
	        t[key] = i;
	        t.keys.push(key);
	    }

	    for(var i=0; i!==t.keys.length; i++){
	        var key = t.keys.pop(),
	            pairIndex = t[key];
	        pairs1.push(p1[pairIndex]);
	        pairs2.push(p2[pairIndex]);
	        delete t[key];
	    }
	};

	/**
	 * To be implemented by subcasses
	 * @method setWorld
	 * @param {World} world
	 */
	Broadphase.prototype.setWorld = function(world){
	};

	/**
	 * Check if the bounding spheres of two bodies overlap.
	 * @method boundingSphereCheck
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @return {boolean}
	 */
	var bsc_dist = new Vec3();
	Broadphase.boundingSphereCheck = function(bodyA,bodyB){
	    var dist = bsc_dist;
	    bodyA.position.vsub(bodyB.position,dist);
	    return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius,2) > dist.norm2();
	};

	/**
	 * Returns all the bodies within the AABB.
	 * @method aabbQuery
	 * @param  {World} world
	 * @param  {AABB} aabb
	 * @param  {array} result An array to store resulting bodies in.
	 * @return {array}
	 */
	Broadphase.prototype.aabbQuery = function(world, aabb, result){
	    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
	    return [];
	};
	},{"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Plane":42,"../shapes/Shape":43}],6:[function(_dereq_,module,exports){
	module.exports = GridBroadphase;

	var Broadphase = _dereq_('./Broadphase');
	var Vec3 = _dereq_('../math/Vec3');
	var Shape = _dereq_('../shapes/Shape');

	/**
	 * Axis aligned uniform grid broadphase.
	 * @class GridBroadphase
	 * @constructor
	 * @extends Broadphase
	 * @todo Needs support for more than just planes and spheres.
	 * @param {Vec3} aabbMin
	 * @param {Vec3} aabbMax
	 * @param {Number} nx Number of boxes along x
	 * @param {Number} ny Number of boxes along y
	 * @param {Number} nz Number of boxes along z
	 */
	function GridBroadphase(aabbMin,aabbMax,nx,ny,nz){
	    Broadphase.apply(this);
	    this.nx = nx || 10;
	    this.ny = ny || 10;
	    this.nz = nz || 10;
	    this.aabbMin = aabbMin || new Vec3(100,100,100);
	    this.aabbMax = aabbMax || new Vec3(-100,-100,-100);
		var nbins = this.nx * this.ny * this.nz;
		if (nbins <= 0) {
			throw "GridBroadphase: Each dimension's n must be >0";
		}
	    this.bins = [];
		this.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow
		this.bins.length = nbins;
		this.binLengths.length = nbins;
		for (var i=0;i<nbins;i++) {
			this.bins[i]=[];
			this.binLengths[i]=0;
		}
	}
	GridBroadphase.prototype = new Broadphase();
	GridBroadphase.prototype.constructor = GridBroadphase;

	/**
	 * Get all the collision pairs in the physics world
	 * @method collisionPairs
	 * @param {World} world
	 * @param {Array} pairs1
	 * @param {Array} pairs2
	 */
	var GridBroadphase_collisionPairs_d = new Vec3();
	var GridBroadphase_collisionPairs_binPos = new Vec3();
	GridBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){
	    var N = world.numObjects(),
	        bodies = world.bodies;

	    var max = this.aabbMax,
	        min = this.aabbMin,
	        nx = this.nx,
	        ny = this.ny,
	        nz = this.nz;

		var xstep = ny*nz;
		var ystep = nz;
		var zstep = 1;

	    var xmax = max.x,
	        ymax = max.y,
	        zmax = max.z,
	        xmin = min.x,
	        ymin = min.y,
	        zmin = min.z;

	    var xmult = nx / (xmax-xmin),
	        ymult = ny / (ymax-ymin),
	        zmult = nz / (zmax-zmin);

	    var binsizeX = (xmax - xmin) / nx,
	        binsizeY = (ymax - ymin) / ny,
	        binsizeZ = (zmax - zmin) / nz;

		var binRadius = Math.sqrt(binsizeX*binsizeX + binsizeY*binsizeY + binsizeZ*binsizeZ) * 0.5;

	    var types = Shape.types;
	    var SPHERE =            types.SPHERE,
	        PLANE =             types.PLANE,
	        BOX =               types.BOX,
	        COMPOUND =          types.COMPOUND,
	        CONVEXPOLYHEDRON =  types.CONVEXPOLYHEDRON;

	    var bins=this.bins,
			binLengths=this.binLengths,
	        Nbins=this.bins.length;

	    // Reset bins
	    for(var i=0; i!==Nbins; i++){
	        binLengths[i] = 0;
	    }

	    var ceil = Math.ceil;
		var min = Math.min;
		var max = Math.max;

		function addBoxToBins(x0,y0,z0,x1,y1,z1,bi) {
			var xoff0 = ((x0 - xmin) * xmult)|0,
				yoff0 = ((y0 - ymin) * ymult)|0,
				zoff0 = ((z0 - zmin) * zmult)|0,
				xoff1 = ceil((x1 - xmin) * xmult),
				yoff1 = ceil((y1 - ymin) * ymult),
				zoff1 = ceil((z1 - zmin) * zmult);

			if (xoff0 < 0) { xoff0 = 0; } else if (xoff0 >= nx) { xoff0 = nx - 1; }
			if (yoff0 < 0) { yoff0 = 0; } else if (yoff0 >= ny) { yoff0 = ny - 1; }
			if (zoff0 < 0) { zoff0 = 0; } else if (zoff0 >= nz) { zoff0 = nz - 1; }
			if (xoff1 < 0) { xoff1 = 0; } else if (xoff1 >= nx) { xoff1 = nx - 1; }
			if (yoff1 < 0) { yoff1 = 0; } else if (yoff1 >= ny) { yoff1 = ny - 1; }
			if (zoff1 < 0) { zoff1 = 0; } else if (zoff1 >= nz) { zoff1 = nz - 1; }

			xoff0 *= xstep;
			yoff0 *= ystep;
			zoff0 *= zstep;
			xoff1 *= xstep;
			yoff1 *= ystep;
			zoff1 *= zstep;

			for (var xoff = xoff0; xoff <= xoff1; xoff += xstep) {
				for (var yoff = yoff0; yoff <= yoff1; yoff += ystep) {
					for (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {
						var idx = xoff+yoff+zoff;
						bins[idx][binLengths[idx]++] = bi;
					}
				}
			}
		}

	    // Put all bodies into the bins
	    for(var i=0; i!==N; i++){
	        var bi = bodies[i];
	        var si = bi.shape;

	        switch(si.type){
	        case SPHERE:
	            // Put in bin
	            // check if overlap with other bins
	            var x = bi.position.x,
	                y = bi.position.y,
	                z = bi.position.z;
	            var r = si.radius;

				addBoxToBins(x-r, y-r, z-r, x+r, y+r, z+r, bi);
	            break;

	        case PLANE:
	            if(si.worldNormalNeedsUpdate){
	                si.computeWorldNormal(bi.quaternion);
	            }
	            var planeNormal = si.worldNormal;

				//Relative position from origin of plane object to the first bin
				//Incremented as we iterate through the bins
				var xreset = xmin + binsizeX*0.5 - bi.position.x,
					yreset = ymin + binsizeY*0.5 - bi.position.y,
					zreset = zmin + binsizeZ*0.5 - bi.position.z;

	            var d = GridBroadphase_collisionPairs_d;
				d.set(xreset, yreset, zreset);

				for (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
					for (var yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
						for (var zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
							if (d.dot(planeNormal) < binRadius) {
								var idx = xoff + yoff + zoff;
								bins[idx][binLengths[idx]++] = bi;
							}
						}
					}
				}
	            break;

	        default:
				if (bi.aabbNeedsUpdate) {
					bi.computeAABB();
				}

				addBoxToBins(
					bi.aabb.lowerBound.x,
					bi.aabb.lowerBound.y,
					bi.aabb.lowerBound.z,
					bi.aabb.upperBound.x,
					bi.aabb.upperBound.y,
					bi.aabb.upperBound.z,
					bi);
	            break;
	        }
	    }

	    // Check each bin
	    for(var i=0; i!==Nbins; i++){
			var binLength = binLengths[i];
			//Skip bins with no potential collisions
			if (binLength > 1) {
				var bin = bins[i];

				// Do N^2 broadphase inside
				for(var xi=0; xi!==binLength; xi++){
					var bi = bin[xi];
					for(var yi=0; yi!==xi; yi++){
						var bj = bin[yi];
						if(this.needBroadphaseCollision(bi,bj)){
							this.intersectionTest(bi,bj,pairs1,pairs2);
						}
					}
				}
			}
	    }

	//	for (var zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
	//		console.log("layer "+zi);
	//		for (var yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
	//			var row = '';
	//			for (var xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
	//				var idx = xoff + yoff + zoff;
	//				row += ' ' + binLengths[idx];
	//			}
	//			console.log(row);
	//		}
	//	}

	    this.makePairsUnique(pairs1,pairs2);
	};

	},{"../math/Vec3":30,"../shapes/Shape":43,"./Broadphase":5}],7:[function(_dereq_,module,exports){
	module.exports = NaiveBroadphase;

	var Broadphase = _dereq_('./Broadphase');
	var AABB = _dereq_('./AABB');

	/**
	 * Naive broadphase implementation, used in lack of better ones.
	 * @class NaiveBroadphase
	 * @constructor
	 * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
	 * @extends Broadphase
	 */
	function NaiveBroadphase(){
	    Broadphase.apply(this);
	}
	NaiveBroadphase.prototype = new Broadphase();
	NaiveBroadphase.prototype.constructor = NaiveBroadphase;

	/**
	 * Get all the collision pairs in the physics world
	 * @method collisionPairs
	 * @param {World} world
	 * @param {Array} pairs1
	 * @param {Array} pairs2
	 */
	NaiveBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){
	    var bodies = world.bodies,
	        n = bodies.length,
	        i,j,bi,bj;

	    // Naive N^2 ftw!
	    for(i=0; i!==n; i++){
	        for(j=0; j!==i; j++){

	            bi = bodies[i];
	            bj = bodies[j];

	            if(!this.needBroadphaseCollision(bi,bj)){
	                continue;
	            }

	            this.intersectionTest(bi,bj,pairs1,pairs2);
	        }
	    }
	};

	var tmpAABB = new AABB();

	/**
	 * Returns all the bodies within an AABB.
	 * @method aabbQuery
	 * @param  {World} world
	 * @param  {AABB} aabb
	 * @param {array} result An array to store resulting bodies in.
	 * @return {array}
	 */
	NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
	    result = result || [];

	    for(var i = 0; i < world.bodies.length; i++){
	        var b = world.bodies[i];

	        if(b.aabbNeedsUpdate){
	            b.computeAABB();
	        }

	        // Ugly hack until Body gets aabb
	        if(b.aabb.overlaps(aabb)){
	            result.push(b);
	        }
	    }

	    return result;
	};
	},{"./AABB":3,"./Broadphase":5}],8:[function(_dereq_,module,exports){
	module.exports = ObjectCollisionMatrix;

	/**
	 * Records what objects are colliding with each other
	 * @class ObjectCollisionMatrix
	 * @constructor
	 */
	function ObjectCollisionMatrix() {

	    /**
	     * The matrix storage
	     * @property matrix
	     * @type {Object}
	     */
		this.matrix = {};
	}

	/**
	 * @method get
	 * @param  {Number} i
	 * @param  {Number} j
	 * @return {Number}
	 */
	ObjectCollisionMatrix.prototype.get = function(i, j) {
		i = i.id;
		j = j.id;
	    if (j > i) {
	        var temp = j;
	        j = i;
	        i = temp;
	    }
		return i+'-'+j in this.matrix;
	};

	/**
	 * @method set
	 * @param  {Number} i
	 * @param  {Number} j
	 * @param {Number} value
	 */
	ObjectCollisionMatrix.prototype.set = function(i, j, value) {
		i = i.id;
		j = j.id;
	    if (j > i) {
	        var temp = j;
	        j = i;
	        i = temp;
		}
		if (value) {
			this.matrix[i+'-'+j] = true;
		}
		else {
			delete this.matrix[i+'-'+j];
		}
	};

	/**
	 * Empty the matrix
	 * @method reset
	 */
	ObjectCollisionMatrix.prototype.reset = function() {
		this.matrix = {};
	};

	/**
	 * Set max number of objects
	 * @method setNumObjects
	 * @param {Number} n
	 */
	ObjectCollisionMatrix.prototype.setNumObjects = function(n) {
	};

	},{}],9:[function(_dereq_,module,exports){
	module.exports = Ray;

	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Transform = _dereq_('../math/Transform');
	var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');
	var Box = _dereq_('../shapes/Box');
	var RaycastResult = _dereq_('../collision/RaycastResult');
	var Shape = _dereq_('../shapes/Shape');
	var AABB = _dereq_('../collision/AABB');

	/**
	 * A line in 3D space that intersects bodies and return points.
	 * @class Ray
	 * @constructor
	 * @param {Vec3} from
	 * @param {Vec3} to
	 */
	function Ray(from, to){
	    /**
	     * @property {Vec3} from
	     */
	    this.from = from ? from.clone() : new Vec3();

	    /**
	     * @property {Vec3} to
	     */
	    this.to = to ? to.clone() : new Vec3();

	    /**
	     * @private
	     * @property {Vec3} _direction
	     */
	    this._direction = new Vec3();

	    /**
	     * The precision of the ray. Used when checking parallelity etc.
	     * @property {Number} precision
	     */
	    this.precision = 0.0001;

	    /**
	     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
	     * @property {Boolean} checkCollisionResponse
	     */
	    this.checkCollisionResponse = true;

	    /**
	     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
	     * @property {Boolean} skipBackfaces
	     */
	    this.skipBackfaces = false;

	    /**
	     * @property {number} collisionFilterMask
	     * @default -1
	     */
	    this.collisionFilterMask = -1;

	    /**
	     * @property {number} collisionFilterGroup
	     * @default -1
	     */
	    this.collisionFilterGroup = -1;

	    /**
	     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
	     * @property {number} mode
	     */
	    this.mode = Ray.ANY;

	    /**
	     * Current result object.
	     * @property {RaycastResult} result
	     */
	    this.result = new RaycastResult();

	    /**
	     * Will be set to true during intersectWorld() if the ray hit anything.
	     * @property {Boolean} hasHit
	     */
	    this.hasHit = false;

	    /**
	     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
	     * @property {Function} callback
	     */
	    this.callback = function(result){};
	}
	Ray.prototype.constructor = Ray;

	Ray.CLOSEST = 1;
	Ray.ANY = 2;
	Ray.ALL = 4;

	var tmpAABB = new AABB();
	var tmpArray = [];

	/**
	 * Do itersection against all bodies in the given World.
	 * @method intersectWorld
	 * @param  {World} world
	 * @param  {object} options
	 * @return {Boolean} True if the ray hit anything, otherwise false.
	 */
	Ray.prototype.intersectWorld = function (world, options) {
	    this.mode = options.mode || Ray.ANY;
	    this.result = options.result || new RaycastResult();
	    this.skipBackfaces = !!options.skipBackfaces;
	    this.collisionFilterMask = typeof(options.collisionFilterMask) !== 'undefined' ? options.collisionFilterMask : -1;
	    this.collisionFilterGroup = typeof(options.collisionFilterGroup) !== 'undefined' ? options.collisionFilterGroup : -1;
	    if(options.from){
	        this.from.copy(options.from);
	    }
	    if(options.to){
	        this.to.copy(options.to);
	    }
	    this.callback = options.callback || function(){};
	    this.hasHit = false;

	    this.result.reset();
	    this._updateDirection();

	    this.getAABB(tmpAABB);
	    tmpArray.length = 0;
	    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
	    this.intersectBodies(tmpArray);

	    return this.hasHit;
	};

	var v1 = new Vec3(),
	    v2 = new Vec3();

	/*
	 * As per "Barycentric Technique" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division
	 */
	Ray.pointInTriangle = pointInTriangle;
	function pointInTriangle(p, a, b, c) {
	    c.vsub(a,v0);
	    b.vsub(a,v1);
	    p.vsub(a,v2);

	    var dot00 = v0.dot( v0 );
	    var dot01 = v0.dot( v1 );
	    var dot02 = v0.dot( v2 );
	    var dot11 = v1.dot( v1 );
	    var dot12 = v1.dot( v2 );

	    var u,v;

	    return  ( (u = dot11 * dot02 - dot01 * dot12) >= 0 ) &&
	            ( (v = dot00 * dot12 - dot01 * dot02) >= 0 ) &&
	            ( u + v < ( dot00 * dot11 - dot01 * dot01 ) );
	}

	/**
	 * Shoot a ray at a body, get back information about the hit.
	 * @method intersectBody
	 * @private
	 * @param {Body} body
	 * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
	 */
	var intersectBody_xi = new Vec3();
	var intersectBody_qi = new Quaternion();
	Ray.prototype.intersectBody = function (body, result) {
	    if(result){
	        this.result = result;
	        this._updateDirection();
	    }
	    var checkCollisionResponse = this.checkCollisionResponse;

	    if(checkCollisionResponse && !body.collisionResponse){
	        return;
	    }

	    if((this.collisionFilterGroup & body.collisionFilterMask)===0 || (body.collisionFilterGroup & this.collisionFilterMask)===0){
	        return;
	    }

	    var xi = intersectBody_xi;
	    var qi = intersectBody_qi;

	    for (var i = 0, N = body.shapes.length; i < N; i++) {
	        var shape = body.shapes[i];

	        if(checkCollisionResponse && !shape.collisionResponse){
	            continue; // Skip
	        }

	        body.quaternion.mult(body.shapeOrientations[i], qi);
	        body.quaternion.vmult(body.shapeOffsets[i], xi);
	        xi.vadd(body.position, xi);

	        this.intersectShape(
	            shape,
	            qi,
	            xi,
	            body
	        );

	        if(this.result._shouldStop){
	            break;
	        }
	    }
	};

	/**
	 * @method intersectBodies
	 * @param {Array} bodies An array of Body objects.
	 * @param {RaycastResult} [result] Deprecated
	 */
	Ray.prototype.intersectBodies = function (bodies, result) {
	    if(result){
	        this.result = result;
	        this._updateDirection();
	    }

	    for ( var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i ++ ) {
	        this.intersectBody(bodies[i]);
	    }
	};

	/**
	 * Updates the _direction vector.
	 * @private
	 * @method _updateDirection
	 */
	Ray.prototype._updateDirection = function(){
	    this.to.vsub(this.from, this._direction);
	    this._direction.normalize();
	};

	/**
	 * @method intersectShape
	 * @private
	 * @param {Shape} shape
	 * @param {Quaternion} quat
	 * @param {Vec3} position
	 * @param {Body} body
	 */
	Ray.prototype.intersectShape = function(shape, quat, position, body){
	    var from = this.from;


	    // Checking boundingSphere
	    var distance = distanceFromIntersection(from, this._direction, position);
	    if ( distance > shape.boundingSphereRadius ) {
	        return;
	    }

	    var intersectMethod = this[shape.type];
	    if(intersectMethod){
	        intersectMethod.call(this, shape, quat, position, body);
	    }
	};

	var vector = new Vec3();
	var normal = new Vec3();
	var intersectPoint = new Vec3();

	var a = new Vec3();
	var b = new Vec3();
	var c = new Vec3();
	var d = new Vec3();

	var tmpRaycastResult = new RaycastResult();

	/**
	 * @method intersectBox
	 * @private
	 * @param  {Shape} shape
	 * @param  {Quaternion} quat
	 * @param  {Vec3} position
	 * @param  {Body} body
	 */
	Ray.prototype.intersectBox = function(shape, quat, position, body){
	    return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body);
	};
	Ray.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;

	/**
	 * @method intersectPlane
	 * @private
	 * @param  {Shape} shape
	 * @param  {Quaternion} quat
	 * @param  {Vec3} position
	 * @param  {Body} body
	 */
	Ray.prototype.intersectPlane = function(shape, quat, position, body){
	    var from = this.from;
	    var to = this.to;
	    var direction = this._direction;

	    // Get plane normal
	    var worldNormal = new Vec3(0, 0, 1);
	    quat.vmult(worldNormal, worldNormal);

	    var len = new Vec3();
	    from.vsub(position, len);
	    var planeToFrom = len.dot(worldNormal);
	    to.vsub(position, len);
	    var planeToTo = len.dot(worldNormal);

	    if(planeToFrom * planeToTo > 0){
	        // "from" and "to" are on the same side of the plane... bail out
	        return;
	    }

	    if(from.distanceTo(to) < planeToFrom){
	        return;
	    }

	    var n_dot_dir = worldNormal.dot(direction);

	    if (Math.abs(n_dot_dir) < this.precision) {
	        // No intersection
	        return;
	    }

	    var planePointToFrom = new Vec3();
	    var dir_scaled_with_t = new Vec3();
	    var hitPointWorld = new Vec3();

	    from.vsub(position, planePointToFrom);
	    var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
	    direction.scale(t, dir_scaled_with_t);
	    from.vadd(dir_scaled_with_t, hitPointWorld);

	    this.reportIntersection(worldNormal, hitPointWorld, shape, body, -1);
	};
	Ray.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;

	/**
	 * Get the world AABB of the ray.
	 * @method getAABB
	 * @param  {AABB} aabb
	 */
	Ray.prototype.getAABB = function(result){
	    var to = this.to;
	    var from = this.from;
	    result.lowerBound.x = Math.min(to.x, from.x);
	    result.lowerBound.y = Math.min(to.y, from.y);
	    result.lowerBound.z = Math.min(to.z, from.z);
	    result.upperBound.x = Math.max(to.x, from.x);
	    result.upperBound.y = Math.max(to.y, from.y);
	    result.upperBound.z = Math.max(to.z, from.z);
	};

	var intersectConvexOptions = {
	    faceList: [0]
	};

	/**
	 * @method intersectHeightfield
	 * @private
	 * @param  {Shape} shape
	 * @param  {Quaternion} quat
	 * @param  {Vec3} position
	 * @param  {Body} body
	 */
	Ray.prototype.intersectHeightfield = function(shape, quat, position, body){
	    var data = shape.data,
	        w = shape.elementSize,
	        worldPillarOffset = new Vec3();

	    // Convert the ray to local heightfield coordinates
	    var localRay = new Ray(this.from, this.to);
	    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
	    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);

	    // Get the index of the data points to test against
	    var index = [];
	    var iMinX = null;
	    var iMinY = null;
	    var iMaxX = null;
	    var iMaxY = null;

	    var inside = shape.getIndexOfPosition(localRay.from.x, localRay.from.y, index, false);
	    if(inside){
	        iMinX = index[0];
	        iMinY = index[1];
	        iMaxX = index[0];
	        iMaxY = index[1];
	    }
	    inside = shape.getIndexOfPosition(localRay.to.x, localRay.to.y, index, false);
	    if(inside){
	        if (iMinX === null || index[0] < iMinX) { iMinX = index[0]; }
	        if (iMaxX === null || index[0] > iMaxX) { iMaxX = index[0]; }
	        if (iMinY === null || index[1] < iMinY) { iMinY = index[1]; }
	        if (iMaxY === null || index[1] > iMaxY) { iMaxY = index[1]; }
	    }

	    if(iMinX === null){
	        return;
	    }

	    var minMax = [];
	    shape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
	    var min = minMax[0];
	    var max = minMax[1];

	    // // Bail out if the ray can't touch the bounding box
	    // // TODO
	    // var aabb = new AABB();
	    // this.getAABB(aabb);
	    // if(aabb.intersects()){
	    //     return;
	    // }

	    for(var i = iMinX; i <= iMaxX; i++){
	        for(var j = iMinY; j <= iMaxY; j++){

	            if(this.result._shouldStop){
	                return;
	            }

	            // Lower triangle
	            shape.getConvexTrianglePillar(i, j, false);
	            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
	            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, intersectConvexOptions);

	            if(this.result._shouldStop){
	                return;
	            }

	            // Upper triangle
	            shape.getConvexTrianglePillar(i, j, true);
	            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
	            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, intersectConvexOptions);
	        }
	    }
	};
	Ray.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;

	var Ray_intersectSphere_intersectionPoint = new Vec3();
	var Ray_intersectSphere_normal = new Vec3();

	/**
	 * @method intersectSphere
	 * @private
	 * @param  {Shape} shape
	 * @param  {Quaternion} quat
	 * @param  {Vec3} position
	 * @param  {Body} body
	 */
	Ray.prototype.intersectSphere = function(shape, quat, position, body){
	    var from = this.from,
	        to = this.to,
	        r = shape.radius;

	    var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);
	    var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
	    var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);

	    var delta = Math.pow(b, 2) - 4 * a * c;

	    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
	    var normal = Ray_intersectSphere_normal;

	    if(delta < 0){
	        // No intersection
	        return;

	    } else if(delta === 0){
	        // single intersection point
	        from.lerp(to, delta, intersectionPoint);

	        intersectionPoint.vsub(position, normal);
	        normal.normalize();

	        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

	    } else {
	        var d1 = (- b - Math.sqrt(delta)) / (2 * a);
	        var d2 = (- b + Math.sqrt(delta)) / (2 * a);

	        if(d1 >= 0 && d1 <= 1){
	            from.lerp(to, d1, intersectionPoint);
	            intersectionPoint.vsub(position, normal);
	            normal.normalize();
	            this.reportIntersection(normal, intersectionPoint, shape, body, -1);
	        }

	        if(this.result._shouldStop){
	            return;
	        }

	        if(d2 >= 0 && d2 <= 1){
	            from.lerp(to, d2, intersectionPoint);
	            intersectionPoint.vsub(position, normal);
	            normal.normalize();
	            this.reportIntersection(normal, intersectionPoint, shape, body, -1);
	        }
	    }
	};
	Ray.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;


	var intersectConvex_normal = new Vec3();
	var intersectConvex_minDistNormal = new Vec3();
	var intersectConvex_minDistIntersect = new Vec3();
	var intersectConvex_vector = new Vec3();

	/**
	 * @method intersectConvex
	 * @private
	 * @param  {Shape} shape
	 * @param  {Quaternion} quat
	 * @param  {Vec3} position
	 * @param  {Body} body
	 * @param {object} [options]
	 * @param {array} [options.faceList]
	 */
	Ray.prototype.intersectConvex = function intersectConvex(
	    shape,
	    quat,
	    position,
	    body,
	    options
	){
	    var minDistNormal = intersectConvex_minDistNormal;
	    var normal = intersectConvex_normal;
	    var vector = intersectConvex_vector;
	    var minDistIntersect = intersectConvex_minDistIntersect;
	    var faceList = (options && options.faceList) || null;

	    // Checking faces
	    var faces = shape.faces,
	        vertices = shape.vertices,
	        normals = shape.faceNormals;
	    var direction = this._direction;

	    var from = this.from;
	    var to = this.to;
	    var fromToDistance = from.distanceTo(to);

	    var minDist = -1;
	    var Nfaces = faceList ? faceList.length : faces.length;
	    var result = this.result;

	    for (var j = 0; !result._shouldStop && j < Nfaces; j++) {
	        var fi = faceList ? faceList[j] : j;

	        var face = faces[fi];
	        var faceNormal = normals[fi];
	        var q = quat;
	        var x = position;

	        // determine if ray intersects the plane of the face
	        // note: this works regardless of the direction of the face normal

	        // Get plane point in world coordinates...
	        vector.copy(vertices[face[0]]);
	        q.vmult(vector,vector);
	        vector.vadd(x,vector);

	        // ...but make it relative to the ray from. We'll fix this later.
	        vector.vsub(from,vector);

	        // Get plane normal
	        q.vmult(faceNormal,normal);

	        // If this dot product is negative, we have something interesting
	        var dot = direction.dot(normal);

	        // Bail out if ray and plane are parallel
	        if ( Math.abs( dot ) < this.precision ){
	            continue;
	        }

	        // calc distance to plane
	        var scalar = normal.dot(vector) / dot;

	        // if negative distance, then plane is behind ray
	        if (scalar < 0){
	            continue;
	        }

	        // if (dot < 0) {

	        // Intersection point is from + direction * scalar
	        direction.mult(scalar,intersectPoint);
	        intersectPoint.vadd(from,intersectPoint);

	        // a is the point we compare points b and c with.
	        a.copy(vertices[face[0]]);
	        q.vmult(a,a);
	        x.vadd(a,a);

	        for(var i = 1; !result._shouldStop && i < face.length - 1; i++){
	            // Transform 3 vertices to world coords
	            b.copy(vertices[face[i]]);
	            c.copy(vertices[face[i+1]]);
	            q.vmult(b,b);
	            q.vmult(c,c);
	            x.vadd(b,b);
	            x.vadd(c,c);

	            var distance = intersectPoint.distanceTo(from);

	            if(!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance){
	                continue;
	            }

	            this.reportIntersection(normal, intersectPoint, shape, body, fi);
	        }
	        // }
	    }
	};
	Ray.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;

	var intersectTrimesh_normal = new Vec3();
	var intersectTrimesh_localDirection = new Vec3();
	var intersectTrimesh_localFrom = new Vec3();
	var intersectTrimesh_localTo = new Vec3();
	var intersectTrimesh_worldNormal = new Vec3();
	var intersectTrimesh_worldIntersectPoint = new Vec3();
	var intersectTrimesh_localAABB = new AABB();
	var intersectTrimesh_triangles = [];
	var intersectTrimesh_treeTransform = new Transform();

	/**
	 * @method intersectTrimesh
	 * @private
	 * @param  {Shape} shape
	 * @param  {Quaternion} quat
	 * @param  {Vec3} position
	 * @param  {Body} body
	 * @param {object} [options]
	 * @todo Optimize by transforming the world to local space first.
	 * @todo Use Octree lookup
	 */
	Ray.prototype.intersectTrimesh = function intersectTrimesh(
	    mesh,
	    quat,
	    position,
	    body,
	    options
	){
	    var normal = intersectTrimesh_normal;
	    var triangles = intersectTrimesh_triangles;
	    var treeTransform = intersectTrimesh_treeTransform;
	    var minDistNormal = intersectConvex_minDistNormal;
	    var vector = intersectConvex_vector;
	    var minDistIntersect = intersectConvex_minDistIntersect;
	    var localAABB = intersectTrimesh_localAABB;
	    var localDirection = intersectTrimesh_localDirection;
	    var localFrom = intersectTrimesh_localFrom;
	    var localTo = intersectTrimesh_localTo;
	    var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
	    var worldNormal = intersectTrimesh_worldNormal;
	    var faceList = (options && options.faceList) || null;

	    // Checking faces
	    var indices = mesh.indices,
	        vertices = mesh.vertices,
	        normals = mesh.faceNormals;

	    var from = this.from;
	    var to = this.to;
	    var direction = this._direction;

	    var minDist = -1;
	    treeTransform.position.copy(position);
	    treeTransform.quaternion.copy(quat);

	    // Transform ray to local space!
	    Transform.vectorToLocalFrame(position, quat, direction, localDirection);
	    //body.vectorToLocalFrame(direction, localDirection);
	    Transform.pointToLocalFrame(position, quat, from, localFrom);
	    //body.pointToLocalFrame(from, localFrom);
	    Transform.pointToLocalFrame(position, quat, to, localTo);
	    //body.pointToLocalFrame(to, localTo);
	    var fromToDistanceSquared = localFrom.distanceSquared(localTo);

	    mesh.tree.rayQuery(this, treeTransform, triangles);

	    for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {
	        var trianglesIndex = triangles[i];

	        mesh.getNormal(trianglesIndex, normal);

	        // determine if ray intersects the plane of the face
	        // note: this works regardless of the direction of the face normal

	        // Get plane point in world coordinates...
	        mesh.getVertex(indices[trianglesIndex * 3], a);

	        // ...but make it relative to the ray from. We'll fix this later.
	        a.vsub(localFrom,vector);

	        // Get plane normal
	        // quat.vmult(normal, normal);

	        // If this dot product is negative, we have something interesting
	        var dot = localDirection.dot(normal);

	        // Bail out if ray and plane are parallel
	        // if (Math.abs( dot ) < this.precision){
	        //     continue;
	        // }

	        // calc distance to plane
	        var scalar = normal.dot(vector) / dot;

	        // if negative distance, then plane is behind ray
	        if (scalar < 0){
	            continue;
	        }

	        // Intersection point is from + direction * scalar
	        localDirection.scale(scalar,intersectPoint);
	        intersectPoint.vadd(localFrom,intersectPoint);

	        // Get triangle vertices
	        mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
	        mesh.getVertex(indices[trianglesIndex * 3 + 2], c);

	        var squaredDistance = intersectPoint.distanceSquared(localFrom);

	        if(!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared){
	            continue;
	        }

	        // transform intersectpoint and normal to world
	        Transform.vectorToWorldFrame(quat, normal, worldNormal);
	        //body.vectorToWorldFrame(normal, worldNormal);
	        Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
	        //body.pointToWorldFrame(intersectPoint, worldIntersectPoint);
	        this.reportIntersection(worldNormal, worldIntersectPoint, mesh, body, trianglesIndex);
	    }
	    triangles.length = 0;
	};
	Ray.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh;


	/**
	 * @method reportIntersection
	 * @private
	 * @param  {Vec3} normal
	 * @param  {Vec3} hitPointWorld
	 * @param  {Shape} shape
	 * @param  {Body} body
	 * @return {boolean} True if the intersections should continue
	 */
	Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex){
	    var from = this.from;
	    var to = this.to;
	    var distance = from.distanceTo(hitPointWorld);
	    var result = this.result;

	    // Skip back faces?
	    if(this.skipBackfaces && normal.dot(this._direction) > 0){
	        return;
	    }

	    result.hitFaceIndex = typeof(hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;

	    switch(this.mode){
	    case Ray.ALL:
	        this.hasHit = true;
	        result.set(
	            from,
	            to,
	            normal,
	            hitPointWorld,
	            shape,
	            body,
	            distance
	        );
	        result.hasHit = true;
	        this.callback(result);
	        break;

	    case Ray.CLOSEST:

	        // Store if closer than current closest
	        if(distance < result.distance || !result.hasHit){
	            this.hasHit = true;
	            result.hasHit = true;
	            result.set(
	                from,
	                to,
	                normal,
	                hitPointWorld,
	                shape,
	                body,
	                distance
	            );
	        }
	        break;

	    case Ray.ANY:

	        // Report and stop.
	        this.hasHit = true;
	        result.hasHit = true;
	        result.set(
	            from,
	            to,
	            normal,
	            hitPointWorld,
	            shape,
	            body,
	            distance
	        );
	        result._shouldStop = true;
	        break;
	    }
	};

	var v0 = new Vec3(),
	    intersect = new Vec3();
	function distanceFromIntersection(from, direction, position) {

	    // v0 is vector from from to position
	    position.vsub(from,v0);
	    var dot = v0.dot(direction);

	    // intersect = direction*dot + from
	    direction.mult(dot,intersect);
	    intersect.vadd(from,intersect);

	    var distance = position.distanceTo(intersect);

	    return distance;
	}


	},{"../collision/AABB":3,"../collision/RaycastResult":10,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../shapes/Box":37,"../shapes/ConvexPolyhedron":38,"../shapes/Shape":43}],10:[function(_dereq_,module,exports){
	var Vec3 = _dereq_('../math/Vec3');

	module.exports = RaycastResult;

	/**
	 * Storage for Ray casting data.
	 * @class RaycastResult
	 * @constructor
	 */
	function RaycastResult(){

		/**
		 * @property {Vec3} rayFromWorld
		 */
		this.rayFromWorld = new Vec3();

		/**
		 * @property {Vec3} rayToWorld
		 */
		this.rayToWorld = new Vec3();

		/**
		 * @property {Vec3} hitNormalWorld
		 */
		this.hitNormalWorld = new Vec3();

		/**
		 * @property {Vec3} hitPointWorld
		 */
		this.hitPointWorld = new Vec3();

		/**
		 * @property {boolean} hasHit
		 */
		this.hasHit = false;

		/**
		 * The hit shape, or null.
		 * @property {Shape} shape
		 */
		this.shape = null;

		/**
		 * The hit body, or null.
		 * @property {Body} body
		 */
		this.body = null;

		/**
		 * The index of the hit triangle, if the hit shape was a trimesh.
		 * @property {number} hitFaceIndex
		 * @default -1
		 */
		this.hitFaceIndex = -1;

		/**
		 * Distance to the hit. Will be set to -1 if there was no hit.
		 * @property {number} distance
		 * @default -1
		 */
		this.distance = -1;

		/**
		 * If the ray should stop traversing the bodies.
		 * @private
		 * @property {Boolean} _shouldStop
		 * @default false
		 */
		this._shouldStop = false;
	}

	/**
	 * Reset all result data.
	 * @method reset
	 */
	RaycastResult.prototype.reset = function () {
		this.rayFromWorld.setZero();
		this.rayToWorld.setZero();
		this.hitNormalWorld.setZero();
		this.hitPointWorld.setZero();
		this.hasHit = false;
		this.shape = null;
		this.body = null;
		this.hitFaceIndex = -1;
		this.distance = -1;
		this._shouldStop = false;
	};

	/**
	 * @method abort
	 */
	RaycastResult.prototype.abort = function(){
		this._shouldStop = true;
	};

	/**
	 * @method set
	 * @param {Vec3} rayFromWorld
	 * @param {Vec3} rayToWorld
	 * @param {Vec3} hitNormalWorld
	 * @param {Vec3} hitPointWorld
	 * @param {Shape} shape
	 * @param {Body} body
	 * @param {number} distance
	 */
	RaycastResult.prototype.set = function(
		rayFromWorld,
		rayToWorld,
		hitNormalWorld,
		hitPointWorld,
		shape,
		body,
		distance
	){
		this.rayFromWorld.copy(rayFromWorld);
		this.rayToWorld.copy(rayToWorld);
		this.hitNormalWorld.copy(hitNormalWorld);
		this.hitPointWorld.copy(hitPointWorld);
		this.shape = shape;
		this.body = body;
		this.distance = distance;
	};
	},{"../math/Vec3":30}],11:[function(_dereq_,module,exports){
	var Shape = _dereq_('../shapes/Shape');
	var Broadphase = _dereq_('../collision/Broadphase');

	module.exports = SAPBroadphase;

	/**
	 * Sweep and prune broadphase along one axis.
	 *
	 * @class SAPBroadphase
	 * @constructor
	 * @param {World} [world]
	 * @extends Broadphase
	 */
	function SAPBroadphase(world){
	    Broadphase.apply(this);

	    /**
	     * List of bodies currently in the broadphase.
	     * @property axisList
	     * @type {Array}
	     */
	    this.axisList = [];

	    /**
	     * The world to search in.
	     * @property world
	     * @type {World}
	     */
	    this.world = null;

	    /**
	     * Axis to sort the bodies along. Set to 0 for x axis, and 1 for y axis. For best performance, choose an axis that the bodies are spread out more on.
	     * @property axisIndex
	     * @type {Number}
	     */
	    this.axisIndex = 0;

	    var axisList = this.axisList;

	    this._addBodyHandler = function(e){
	        axisList.push(e.body);
	    };

	    this._removeBodyHandler = function(e){
	        var idx = axisList.indexOf(e.body);
	        if(idx !== -1){
	            axisList.splice(idx,1);
	        }
	    };

	    if(world){
	        this.setWorld(world);
	    }
	}
	SAPBroadphase.prototype = new Broadphase();

	/**
	 * Change the world
	 * @method setWorld
	 * @param  {World} world
	 */
	SAPBroadphase.prototype.setWorld = function(world){
	    // Clear the old axis array
	    this.axisList.length = 0;

	    // Add all bodies from the new world
	    for(var i=0; i<world.bodies.length; i++){
	        this.axisList.push(world.bodies[i]);
	    }

	    // Remove old handlers, if any
	    world.removeEventListener("addBody", this._addBodyHandler);
	    world.removeEventListener("removeBody", this._removeBodyHandler);

	    // Add handlers to update the list of bodies.
	    world.addEventListener("addBody", this._addBodyHandler);
	    world.addEventListener("removeBody", this._removeBodyHandler);

	    this.world = world;
	    this.dirty = true;
	};

	/**
	 * @static
	 * @method insertionSortX
	 * @param  {Array} a
	 * @return {Array}
	 */
	SAPBroadphase.insertionSortX = function(a) {
	    for(var i=1,l=a.length;i<l;i++) {
	        var v = a[i];
	        for(var j=i - 1;j>=0;j--) {
	            if(a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x){
	                break;
	            }
	            a[j+1] = a[j];
	        }
	        a[j+1] = v;
	    }
	    return a;
	};

	/**
	 * @static
	 * @method insertionSortY
	 * @param  {Array} a
	 * @return {Array}
	 */
	SAPBroadphase.insertionSortY = function(a) {
	    for(var i=1,l=a.length;i<l;i++) {
	        var v = a[i];
	        for(var j=i - 1;j>=0;j--) {
	            if(a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y){
	                break;
	            }
	            a[j+1] = a[j];
	        }
	        a[j+1] = v;
	    }
	    return a;
	};

	/**
	 * @static
	 * @method insertionSortZ
	 * @param  {Array} a
	 * @return {Array}
	 */
	SAPBroadphase.insertionSortZ = function(a) {
	    for(var i=1,l=a.length;i<l;i++) {
	        var v = a[i];
	        for(var j=i - 1;j>=0;j--) {
	            if(a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z){
	                break;
	            }
	            a[j+1] = a[j];
	        }
	        a[j+1] = v;
	    }
	    return a;
	};

	/**
	 * Collect all collision pairs
	 * @method collisionPairs
	 * @param  {World} world
	 * @param  {Array} p1
	 * @param  {Array} p2
	 */
	SAPBroadphase.prototype.collisionPairs = function(world,p1,p2){
	    var bodies = this.axisList,
	        N = bodies.length,
	        axisIndex = this.axisIndex,
	        i, j;

	    if(this.dirty){
	        this.sortList();
	        this.dirty = false;
	    }

	    // Look through the list
	    for(i=0; i !== N; i++){
	        var bi = bodies[i];

	        for(j=i+1; j < N; j++){
	            var bj = bodies[j];

	            if(!this.needBroadphaseCollision(bi,bj)){
	                continue;
	            }

	            if(!SAPBroadphase.checkBounds(bi,bj,axisIndex)){
	                break;
	            }

	            this.intersectionTest(bi,bj,p1,p2);
	        }
	    }
	};

	SAPBroadphase.prototype.sortList = function(){
	    var axisList = this.axisList;
	    var axisIndex = this.axisIndex;
	    var N = axisList.length;

	    // Update AABBs
	    for(var i = 0; i!==N; i++){
	        var bi = axisList[i];
	        if(bi.aabbNeedsUpdate){
	            bi.computeAABB();
	        }
	    }

	    // Sort the list
	    if(axisIndex === 0){
	        SAPBroadphase.insertionSortX(axisList);
	    } else if(axisIndex === 1){
	        SAPBroadphase.insertionSortY(axisList);
	    } else if(axisIndex === 2){
	        SAPBroadphase.insertionSortZ(axisList);
	    }
	};

	/**
	 * Check if the bounds of two bodies overlap, along the given SAP axis.
	 * @static
	 * @method checkBounds
	 * @param  {Body} bi
	 * @param  {Body} bj
	 * @param  {Number} axisIndex
	 * @return {Boolean}
	 */
	SAPBroadphase.checkBounds = function(bi, bj, axisIndex){
	    var biPos;
	    var bjPos;

	    if(axisIndex === 0){
	        biPos = bi.position.x;
	        bjPos = bj.position.x;
	    } else if(axisIndex === 1){
	        biPos = bi.position.y;
	        bjPos = bj.position.y;
	    } else if(axisIndex === 2){
	        biPos = bi.position.z;
	        bjPos = bj.position.z;
	    }

	    var ri = bi.boundingRadius,
	        rj = bj.boundingRadius,
	        boundA1 = biPos - ri,
	        boundA2 = biPos + ri,
	        boundB1 = bjPos - rj,
	        boundB2 = bjPos + rj;

	    return boundB1 < boundA2;
	};

	/**
	 * Computes the variance of the body positions and estimates the best
	 * axis to use. Will automatically set property .axisIndex.
	 * @method autoDetectAxis
	 */
	SAPBroadphase.prototype.autoDetectAxis = function(){
	    var sumX=0,
	        sumX2=0,
	        sumY=0,
	        sumY2=0,
	        sumZ=0,
	        sumZ2=0,
	        bodies = this.axisList,
	        N = bodies.length,
	        invN=1/N;

	    for(var i=0; i!==N; i++){
	        var b = bodies[i];

	        var centerX = b.position.x;
	        sumX += centerX;
	        sumX2 += centerX*centerX;

	        var centerY = b.position.y;
	        sumY += centerY;
	        sumY2 += centerY*centerY;

	        var centerZ = b.position.z;
	        sumZ += centerZ;
	        sumZ2 += centerZ*centerZ;
	    }

	    var varianceX = sumX2 - sumX*sumX*invN,
	        varianceY = sumY2 - sumY*sumY*invN,
	        varianceZ = sumZ2 - sumZ*sumZ*invN;

	    if(varianceX > varianceY){
	        if(varianceX > varianceZ){
	            this.axisIndex = 0;
	        } else{
	            this.axisIndex = 2;
	        }
	    } else if(varianceY > varianceZ){
	        this.axisIndex = 1;
	    } else{
	        this.axisIndex = 2;
	    }
	};

	/**
	 * Returns all the bodies within an AABB.
	 * @method aabbQuery
	 * @param  {World} world
	 * @param  {AABB} aabb
	 * @param {array} result An array to store resulting bodies in.
	 * @return {array}
	 */
	SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
	    result = result || [];

	    if(this.dirty){
	        this.sortList();
	        this.dirty = false;
	    }

	    var axisIndex = this.axisIndex, axis = 'x';
	    if(axisIndex === 1){ axis = 'y'; }
	    if(axisIndex === 2){ axis = 'z'; }

	    var axisList = this.axisList;
	    var lower = aabb.lowerBound[axis];
	    var upper = aabb.upperBound[axis];
	    for(var i = 0; i < axisList.length; i++){
	        var b = axisList[i];

	        if(b.aabbNeedsUpdate){
	            b.computeAABB();
	        }

	        if(b.aabb.overlaps(aabb)){
	            result.push(b);
	        }
	    }

	    return result;
	};
	},{"../collision/Broadphase":5,"../shapes/Shape":43}],12:[function(_dereq_,module,exports){
	module.exports = ConeTwistConstraint;

	var Constraint = _dereq_('./Constraint');
	var PointToPointConstraint = _dereq_('./PointToPointConstraint');
	var ConeEquation = _dereq_('../equations/ConeEquation');
	var RotationalEquation = _dereq_('../equations/RotationalEquation');
	var ContactEquation = _dereq_('../equations/ContactEquation');
	var Vec3 = _dereq_('../math/Vec3');

	/**
	 * @class ConeTwistConstraint
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {object} [options]
	 * @param {Vec3} [options.pivotA]
	 * @param {Vec3} [options.pivotB]
	 * @param {Vec3} [options.axisA]
	 * @param {Vec3} [options.axisB]
	 * @param {Number} [options.maxForce=1e6]
	 * @extends PointToPointConstraint
	 */
	function ConeTwistConstraint(bodyA, bodyB, options){
	    options = options || {};
	    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

	    // Set pivot point in between
	    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
	    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
	    this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
	    this.axisB = options.axisB ? options.axisB.clone() : new Vec3();

	    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

	    this.collideConnected = !!options.collideConnected;

	    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;

	    /**
	     * @property {ConeEquation} coneEquation
	     */
	    var c = this.coneEquation = new ConeEquation(bodyA,bodyB,options);

	    /**
	     * @property {RotationalEquation} twistEquation
	     */
	    var t = this.twistEquation = new RotationalEquation(bodyA,bodyB,options);
	    this.twistAngle = typeof(options.twistAngle) !== 'undefined' ? options.twistAngle : 0;

	    // Make the cone equation push the bodies toward the cone axis, not outward
	    c.maxForce = 0;
	    c.minForce = -maxForce;

	    // Make the twist equation add torque toward the initial position
	    t.maxForce = 0;
	    t.minForce = -maxForce;

	    this.equations.push(c, t);
	}
	ConeTwistConstraint.prototype = new PointToPointConstraint();
	ConeTwistConstraint.constructor = ConeTwistConstraint;

	var ConeTwistConstraint_update_tmpVec1 = new Vec3();
	var ConeTwistConstraint_update_tmpVec2 = new Vec3();

	ConeTwistConstraint.prototype.update = function(){
	    var bodyA = this.bodyA,
	        bodyB = this.bodyB,
	        cone = this.coneEquation,
	        twist = this.twistEquation;

	    PointToPointConstraint.prototype.update.call(this);

	    // Update the axes to the cone constraint
	    bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
	    bodyB.vectorToWorldFrame(this.axisB, cone.axisB);

	    // Update the world axes in the twist constraint
	    this.axisA.tangents(twist.axisA, twist.axisA);
	    bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);

	    this.axisB.tangents(twist.axisB, twist.axisB);
	    bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);

	    cone.angle = this.angle;
	    twist.maxAngle = this.twistAngle;
	};


	},{"../equations/ConeEquation":18,"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],13:[function(_dereq_,module,exports){
	module.exports = Constraint;

	var Utils = _dereq_('../utils/Utils');

	/**
	 * Constraint base class
	 * @class Constraint
	 * @author schteppe
	 * @constructor
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {object} [options]
	 * @param {boolean} [options.collideConnected=true]
	 * @param {boolean} [options.wakeUpBodies=true]
	 */
	function Constraint(bodyA, bodyB, options){
	    options = Utils.defaults(options,{
	        collideConnected : true,
	        wakeUpBodies : true,
	    });

	    /**
	     * Equations to be solved in this constraint
	     * @property equations
	     * @type {Array}
	     */
	    this.equations = [];

	    /**
	     * @property {Body} bodyA
	     */
	    this.bodyA = bodyA;

	    /**
	     * @property {Body} bodyB
	     */
	    this.bodyB = bodyB;

	    /**
	     * @property {Number} id
	     */
	    this.id = Constraint.idCounter++;

	    /**
	     * Set to true if you want the bodies to collide when they are connected.
	     * @property collideConnected
	     * @type {boolean}
	     */
	    this.collideConnected = options.collideConnected;

	    if(options.wakeUpBodies){
	        if(bodyA){
	            bodyA.wakeUp();
	        }
	        if(bodyB){
	            bodyB.wakeUp();
	        }
	    }
	}

	/**
	 * Update all the equations with data.
	 * @method update
	 */
	Constraint.prototype.update = function(){
	    throw new Error("method update() not implmemented in this Constraint subclass!");
	};

	/**
	 * Enables all equations in the constraint.
	 * @method enable
	 */
	Constraint.prototype.enable = function(){
	    var eqs = this.equations;
	    for(var i=0; i<eqs.length; i++){
	        eqs[i].enabled = true;
	    }
	};

	/**
	 * Disables all equations in the constraint.
	 * @method disable
	 */
	Constraint.prototype.disable = function(){
	    var eqs = this.equations;
	    for(var i=0; i<eqs.length; i++){
	        eqs[i].enabled = false;
	    }
	};

	Constraint.idCounter = 0;

	},{"../utils/Utils":53}],14:[function(_dereq_,module,exports){
	module.exports = DistanceConstraint;

	var Constraint = _dereq_('./Constraint');
	var ContactEquation = _dereq_('../equations/ContactEquation');

	/**
	 * Constrains two bodies to be at a constant distance from each others center of mass.
	 * @class DistanceConstraint
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Number} [distance] The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
	 * @param {Number} [maxForce=1e6]
	 * @extends Constraint
	 */
	function DistanceConstraint(bodyA,bodyB,distance,maxForce){
	    Constraint.call(this,bodyA,bodyB);

	    if(typeof(distance)==="undefined") {
	        distance = bodyA.position.distanceTo(bodyB.position);
	    }

	    if(typeof(maxForce)==="undefined") {
	        maxForce = 1e6;
	    }

	    /**
	     * @property {number} distance
	     */
	    this.distance = distance;

	    /**
	     * @property {ContactEquation} distanceEquation
	     */
	    var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
	    this.equations.push(eq);

	    // Make it bidirectional
	    eq.minForce = -maxForce;
	    eq.maxForce =  maxForce;
	}
	DistanceConstraint.prototype = new Constraint();

	DistanceConstraint.prototype.update = function(){
	    var bodyA = this.bodyA;
	    var bodyB = this.bodyB;
	    var eq = this.distanceEquation;
	    var halfDist = this.distance * 0.5;
	    var normal = eq.ni;

	    bodyB.position.vsub(bodyA.position, normal);
	    normal.normalize();
	    normal.mult(halfDist, eq.ri);
	    normal.mult(-halfDist, eq.rj);
	};
	},{"../equations/ContactEquation":19,"./Constraint":13}],15:[function(_dereq_,module,exports){
	module.exports = HingeConstraint;

	var Constraint = _dereq_('./Constraint');
	var PointToPointConstraint = _dereq_('./PointToPointConstraint');
	var RotationalEquation = _dereq_('../equations/RotationalEquation');
	var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');
	var ContactEquation = _dereq_('../equations/ContactEquation');
	var Vec3 = _dereq_('../math/Vec3');

	/**
	 * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
	 * @class HingeConstraint
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {object} [options]
	 * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.
	 * @param {Vec3} [options.axisA] An axis that bodyA can rotate around, defined locally in bodyA.
	 * @param {Vec3} [options.pivotB]
	 * @param {Vec3} [options.axisB]
	 * @param {Number} [options.maxForce=1e6]
	 * @extends PointToPointConstraint
	 */
	function HingeConstraint(bodyA, bodyB, options){
	    options = options || {};
	    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;
	    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
	    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();

	    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

	    /**
	     * Rotation axis, defined locally in bodyA.
	     * @property {Vec3} axisA
	     */
	    var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1,0,0);
	    axisA.normalize();

	    /**
	     * Rotation axis, defined locally in bodyB.
	     * @property {Vec3} axisB
	     */
	    var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1,0,0);
	    axisB.normalize();

	    /**
	     * @property {RotationalEquation} rotationalEquation1
	     */
	    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);

	    /**
	     * @property {RotationalEquation} rotationalEquation2
	     */
	    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);

	    /**
	     * @property {RotationalMotorEquation} motorEquation
	     */
	    var motor = this.motorEquation = new RotationalMotorEquation(bodyA,bodyB,maxForce);
	    motor.enabled = false; // Not enabled by default

	    // Equations to be fed to the solver
	    this.equations.push(
	        r1, // rotational1
	        r2, // rotational2
	        motor
	    );
	}
	HingeConstraint.prototype = new PointToPointConstraint();
	HingeConstraint.constructor = HingeConstraint;

	/**
	 * @method enableMotor
	 */
	HingeConstraint.prototype.enableMotor = function(){
	    this.motorEquation.enabled = true;
	};

	/**
	 * @method disableMotor
	 */
	HingeConstraint.prototype.disableMotor = function(){
	    this.motorEquation.enabled = false;
	};

	/**
	 * @method setMotorSpeed
	 * @param {number} speed
	 */
	HingeConstraint.prototype.setMotorSpeed = function(speed){
	    this.motorEquation.targetVelocity = speed;
	};

	/**
	 * @method setMotorMaxForce
	 * @param {number} maxForce
	 */
	HingeConstraint.prototype.setMotorMaxForce = function(maxForce){
	    this.motorEquation.maxForce = maxForce;
	    this.motorEquation.minForce = -maxForce;
	};

	var HingeConstraint_update_tmpVec1 = new Vec3();
	var HingeConstraint_update_tmpVec2 = new Vec3();

	HingeConstraint.prototype.update = function(){
	    var bodyA = this.bodyA,
	        bodyB = this.bodyB,
	        motor = this.motorEquation,
	        r1 = this.rotationalEquation1,
	        r2 = this.rotationalEquation2,
	        worldAxisA = HingeConstraint_update_tmpVec1,
	        worldAxisB = HingeConstraint_update_tmpVec2;

	    var axisA = this.axisA;
	    var axisB = this.axisB;

	    PointToPointConstraint.prototype.update.call(this);

	    // Get world axes
	    bodyA.quaternion.vmult(axisA, worldAxisA);
	    bodyB.quaternion.vmult(axisB, worldAxisB);

	    worldAxisA.tangents(r1.axisA, r2.axisA);
	    r1.axisB.copy(worldAxisB);
	    r2.axisB.copy(worldAxisB);

	    if(this.motorEquation.enabled){
	        bodyA.quaternion.vmult(this.axisA, motor.axisA);
	        bodyB.quaternion.vmult(this.axisB, motor.axisB);
	    }
	};


	},{"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../equations/RotationalMotorEquation":23,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],16:[function(_dereq_,module,exports){
	module.exports = LockConstraint;

	var Constraint = _dereq_('./Constraint');
	var PointToPointConstraint = _dereq_('./PointToPointConstraint');
	var RotationalEquation = _dereq_('../equations/RotationalEquation');
	var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');
	var ContactEquation = _dereq_('../equations/ContactEquation');
	var Vec3 = _dereq_('../math/Vec3');

	/**
	 * Lock constraint. Will remove all degrees of freedom between the bodies.
	 * @class LockConstraint
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {object} [options]
	 * @param {Number} [options.maxForce=1e6]
	 * @extends PointToPointConstraint
	 */
	function LockConstraint(bodyA, bodyB, options){
	    options = options || {};
	    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

	    // Set pivot point in between
	    var pivotA = new Vec3();
	    var pivotB = new Vec3();
	    var halfWay = new Vec3();
	    bodyA.position.vadd(bodyB.position, halfWay);
	    halfWay.scale(0.5, halfWay);
	    bodyB.pointToLocalFrame(halfWay, pivotB);
	    bodyA.pointToLocalFrame(halfWay, pivotA);
	    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

	    /**
	     * @property {RotationalEquation} rotationalEquation1
	     */
	    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);

	    /**
	     * @property {RotationalEquation} rotationalEquation2
	     */
	    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);

	    /**
	     * @property {RotationalEquation} rotationalEquation3
	     */
	    var r3 = this.rotationalEquation3 = new RotationalEquation(bodyA,bodyB,options);

	    this.equations.push(r1, r2, r3);
	}
	LockConstraint.prototype = new PointToPointConstraint();
	LockConstraint.constructor = LockConstraint;

	var LockConstraint_update_tmpVec1 = new Vec3();
	var LockConstraint_update_tmpVec2 = new Vec3();

	LockConstraint.prototype.update = function(){
	    var bodyA = this.bodyA,
	        bodyB = this.bodyB,
	        motor = this.motorEquation,
	        r1 = this.rotationalEquation1,
	        r2 = this.rotationalEquation2,
	        r3 = this.rotationalEquation3,
	        worldAxisA = LockConstraint_update_tmpVec1,
	        worldAxisB = LockConstraint_update_tmpVec2;

	    PointToPointConstraint.prototype.update.call(this);

	    bodyA.vectorToWorldFrame(Vec3.UNIT_X, r1.axisA);
	    bodyB.vectorToWorldFrame(Vec3.UNIT_Y, r1.axisB);

	    bodyA.vectorToWorldFrame(Vec3.UNIT_Y, r2.axisA);
	    bodyB.vectorToWorldFrame(Vec3.UNIT_Z, r2.axisB);

	    bodyA.vectorToWorldFrame(Vec3.UNIT_Z, r3.axisA);
	    bodyB.vectorToWorldFrame(Vec3.UNIT_X, r3.axisB);
	};


	},{"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../equations/RotationalMotorEquation":23,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],17:[function(_dereq_,module,exports){
	module.exports = PointToPointConstraint;

	var Constraint = _dereq_('./Constraint');
	var ContactEquation = _dereq_('../equations/ContactEquation');
	var Vec3 = _dereq_('../math/Vec3');

	/**
	 * Connects two bodies at given offset points.
	 * @class PointToPointConstraint
	 * @extends Constraint
	 * @constructor
	 * @param {Body} bodyA
	 * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
	 * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
	 * @param {Vec3} pivotB See pivotA.
	 * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.
	 *
	 * @example
	 *     var bodyA = new Body({ mass: 1 });
	 *     var bodyB = new Body({ mass: 1 });
	 *     bodyA.position.set(-1, 0, 0);
	 *     bodyB.position.set(1, 0, 0);
	 *     bodyA.addShape(shapeA);
	 *     bodyB.addShape(shapeB);
	 *     world.addBody(bodyA);
	 *     world.addBody(bodyB);
	 *     var localPivotA = new Vec3(1, 0, 0);
	 *     var localPivotB = new Vec3(-1, 0, 0);
	 *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);
	 *     world.addConstraint(constraint);
	 */
	function PointToPointConstraint(bodyA,pivotA,bodyB,pivotB,maxForce){
	    Constraint.call(this,bodyA,bodyB);

	    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;

	    /**
	     * Pivot, defined locally in bodyA.
	     * @property {Vec3} pivotA
	     */
	    this.pivotA = pivotA ? pivotA.clone() : new Vec3();

	    /**
	     * Pivot, defined locally in bodyB.
	     * @property {Vec3} pivotB
	     */
	    this.pivotB = pivotB ? pivotB.clone() : new Vec3();

	    /**
	     * @property {ContactEquation} equationX
	     */
	    var x = this.equationX = new ContactEquation(bodyA,bodyB);

	    /**
	     * @property {ContactEquation} equationY
	     */
	    var y = this.equationY = new ContactEquation(bodyA,bodyB);

	    /**
	     * @property {ContactEquation} equationZ
	     */
	    var z = this.equationZ = new ContactEquation(bodyA,bodyB);

	    // Equations to be fed to the solver
	    this.equations.push(x, y, z);

	    // Make the equations bidirectional
	    x.minForce = y.minForce = z.minForce = -maxForce;
	    x.maxForce = y.maxForce = z.maxForce =  maxForce;

	    x.ni.set(1, 0, 0);
	    y.ni.set(0, 1, 0);
	    z.ni.set(0, 0, 1);
	}
	PointToPointConstraint.prototype = new Constraint();

	PointToPointConstraint.prototype.update = function(){
	    var bodyA = this.bodyA;
	    var bodyB = this.bodyB;
	    var x = this.equationX;
	    var y = this.equationY;
	    var z = this.equationZ;

	    // Rotate the pivots to world space
	    bodyA.quaternion.vmult(this.pivotA,x.ri);
	    bodyB.quaternion.vmult(this.pivotB,x.rj);

	    y.ri.copy(x.ri);
	    y.rj.copy(x.rj);
	    z.ri.copy(x.ri);
	    z.rj.copy(x.rj);
	};
	},{"../equations/ContactEquation":19,"../math/Vec3":30,"./Constraint":13}],18:[function(_dereq_,module,exports){
	module.exports = ConeEquation;

	var Vec3 = _dereq_('../math/Vec3');
	var Mat3 = _dereq_('../math/Mat3');
	var Equation = _dereq_('./Equation');

	/**
	 * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
	 * @class ConeEquation
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Vec3} [options.axisA] Local axis in A
	 * @param {Vec3} [options.axisB] Local axis in B
	 * @param {Vec3} [options.angle] The "cone angle" to keep
	 * @param {number} [options.maxForce=1e6]
	 * @extends Equation
	 */
	function ConeEquation(bodyA, bodyB, options){
	    options = options || {};
	    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

	    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);

	    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
	    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);

	    /**
	     * The cone angle to keep
	     * @property {number} angle
	     */
	    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;
	}

	ConeEquation.prototype = new Equation();
	ConeEquation.prototype.constructor = ConeEquation;

	var tmpVec1 = new Vec3();
	var tmpVec2 = new Vec3();

	ConeEquation.prototype.computeB = function(h){
	    var a = this.a,
	        b = this.b,

	        ni = this.axisA,
	        nj = this.axisB,

	        nixnj = tmpVec1,
	        njxni = tmpVec2,

	        GA = this.jacobianElementA,
	        GB = this.jacobianElementB;

	    // Caluclate cross products
	    ni.cross(nj, nixnj);
	    nj.cross(ni, njxni);

	    // The angle between two vector is:
	    // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b

	    // g = a * b
	    // gdot = (b x a) * wi + (a x b) * wj
	    // G = [0 bxa 0 axb]
	    // W = [vi wi vj wj]
	    GA.rotational.copy(njxni);
	    GB.rotational.copy(nixnj);

	    var g = Math.cos(this.angle) - ni.dot(nj),
	        GW = this.computeGW(),
	        GiMf = this.computeGiMf();

	    var B = - g * a - GW * b - h * GiMf;

	    return B;
	};


	},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],19:[function(_dereq_,module,exports){
	module.exports = ContactEquation;

	var Equation = _dereq_('./Equation');
	var Vec3 = _dereq_('../math/Vec3');
	var Mat3 = _dereq_('../math/Mat3');

	/**
	 * Contact/non-penetration constraint equation
	 * @class ContactEquation
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @extends Equation
	 */
	function ContactEquation(bodyA, bodyB, maxForce){
	    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;
	    Equation.call(this, bodyA, bodyB, 0, maxForce);

	    /**
	     * @property restitution
	     * @type {Number}
	     */
	    this.restitution = 0.0; // "bounciness": u1 = -e*u0

	    /**
	     * World-oriented vector that goes from the center of bi to the contact point.
	     * @property {Vec3} ri
	     */
	    this.ri = new Vec3();

	    /**
	     * World-oriented vector that starts in body j position and goes to the contact point.
	     * @property {Vec3} rj
	     */
	    this.rj = new Vec3();

	    /**
	     * Contact normal, pointing out of body i.
	     * @property {Vec3} ni
	     */
	    this.ni = new Vec3();
	}

	ContactEquation.prototype = new Equation();
	ContactEquation.prototype.constructor = ContactEquation;

	var ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors
	var ContactEquation_computeB_temp2 = new Vec3();
	var ContactEquation_computeB_temp3 = new Vec3();
	ContactEquation.prototype.computeB = function(h){
	    var a = this.a,
	        b = this.b,
	        bi = this.bi,
	        bj = this.bj,
	        ri = this.ri,
	        rj = this.rj,
	        rixn = ContactEquation_computeB_temp1,
	        rjxn = ContactEquation_computeB_temp2,

	        vi = bi.velocity,
	        wi = bi.angularVelocity,
	        fi = bi.force,
	        taui = bi.torque,

	        vj = bj.velocity,
	        wj = bj.angularVelocity,
	        fj = bj.force,
	        tauj = bj.torque,

	        penetrationVec = ContactEquation_computeB_temp3,

	        GA = this.jacobianElementA,
	        GB = this.jacobianElementB,

	        n = this.ni;

	    // Caluclate cross products
	    ri.cross(n,rixn);
	    rj.cross(n,rjxn);

	    // g = xj+rj -(xi+ri)
	    // G = [ -ni  -rixn  ni  rjxn ]
	    n.negate(GA.spatial);
	    rixn.negate(GA.rotational);
	    GB.spatial.copy(n);
	    GB.rotational.copy(rjxn);

	    // Calculate the penetration vector
	    penetrationVec.copy(bj.position);
	    penetrationVec.vadd(rj,penetrationVec);
	    penetrationVec.vsub(bi.position,penetrationVec);
	    penetrationVec.vsub(ri,penetrationVec);

	    var g = n.dot(penetrationVec);

	    // Compute iteration
	    var ePlusOne = this.restitution + 1;
	    var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
	    var GiMf = this.computeGiMf();

	    var B = - g * a - GW * b - h*GiMf;

	    return B;
	};

	var ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
	var ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
	var ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
	var ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
	var ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();

	/**
	 * Get the current relative velocity in the contact point.
	 * @method getImpactVelocityAlongNormal
	 * @return {number}
	 */
	ContactEquation.prototype.getImpactVelocityAlongNormal = function(){
	    var vi = ContactEquation_getImpactVelocityAlongNormal_vi;
	    var vj = ContactEquation_getImpactVelocityAlongNormal_vj;
	    var xi = ContactEquation_getImpactVelocityAlongNormal_xi;
	    var xj = ContactEquation_getImpactVelocityAlongNormal_xj;
	    var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;

	    this.bi.position.vadd(this.ri, xi);
	    this.bj.position.vadd(this.rj, xj);

	    this.bi.getVelocityAtWorldPoint(xi, vi);
	    this.bj.getVelocityAtWorldPoint(xj, vj);

	    vi.vsub(vj, relVel);

	    return this.ni.dot(relVel);
	};


	},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],20:[function(_dereq_,module,exports){
	module.exports = Equation;

	var JacobianElement = _dereq_('../math/JacobianElement'),
	    Vec3 = _dereq_('../math/Vec3');

	/**
	 * Equation base class
	 * @class Equation
	 * @constructor
	 * @author schteppe
	 * @param {Body} bi
	 * @param {Body} bj
	 * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.
	 * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.
	 */
	function Equation(bi,bj,minForce,maxForce){
	    this.id = Equation.id++;

	    /**
	     * @property {number} minForce
	     */
	    this.minForce = typeof(minForce)==="undefined" ? -1e6 : minForce;

	    /**
	     * @property {number} maxForce
	     */
	    this.maxForce = typeof(maxForce)==="undefined" ? 1e6 : maxForce;

	    /**
	     * @property bi
	     * @type {Body}
	     */
	    this.bi = bi;

	    /**
	     * @property bj
	     * @type {Body}
	     */
	    this.bj = bj;

	    /**
	     * SPOOK parameter
	     * @property {number} a
	     */
	    this.a = 0.0;

	    /**
	     * SPOOK parameter
	     * @property {number} b
	     */
	    this.b = 0.0;

	    /**
	     * SPOOK parameter
	     * @property {number} eps
	     */
	    this.eps = 0.0;

	    /**
	     * @property {JacobianElement} jacobianElementA
	     */
	    this.jacobianElementA = new JacobianElement();

	    /**
	     * @property {JacobianElement} jacobianElementB
	     */
	    this.jacobianElementB = new JacobianElement();

	    /**
	     * @property {boolean} enabled
	     * @default true
	     */
	    this.enabled = true;

	    // Set typical spook params
	    this.setSpookParams(1e7,4,1/60);
	}
	Equation.prototype.constructor = Equation;

	Equation.id = 0;

	/**
	 * Recalculates a,b,eps.
	 * @method setSpookParams
	 */
	Equation.prototype.setSpookParams = function(stiffness,relaxation,timeStep){
	    var d = relaxation,
	        k = stiffness,
	        h = timeStep;
	    this.a = 4.0 / (h * (1 + 4 * d));
	    this.b = (4.0 * d) / (1 + 4 * d);
	    this.eps = 4.0 / (h * h * k * (1 + 4 * d));
	};

	/**
	 * Computes the RHS of the SPOOK equation
	 * @method computeB
	 * @return {Number}
	 */
	Equation.prototype.computeB = function(a,b,h){
	    var GW = this.computeGW(),
	        Gq = this.computeGq(),
	        GiMf = this.computeGiMf();
	    return - Gq * a - GW * b - GiMf*h;
	};

	/**
	 * Computes G*q, where q are the generalized body coordinates
	 * @method computeGq
	 * @return {Number}
	 */
	Equation.prototype.computeGq = function(){
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	        bi = this.bi,
	        bj = this.bj,
	        xi = bi.position,
	        xj = bj.position;
	    return GA.spatial.dot(xi) + GB.spatial.dot(xj);
	};

	var zero = new Vec3();

	/**
	 * Computes G*W, where W are the body velocities
	 * @method computeGW
	 * @return {Number}
	 */
	Equation.prototype.computeGW = function(){
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	        bi = this.bi,
	        bj = this.bj,
	        vi = bi.velocity,
	        vj = bj.velocity,
	        wi = bi.angularVelocity || zero,
	        wj = bj.angularVelocity || zero;
	    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);
	};


	/**
	 * Computes G*Wlambda, where W are the body velocities
	 * @method computeGWlambda
	 * @return {Number}
	 */
	Equation.prototype.computeGWlambda = function(){
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	        bi = this.bi,
	        bj = this.bj,
	        vi = bi.vlambda,
	        vj = bj.vlambda,
	        wi = bi.wlambda || zero,
	        wj = bj.wlambda || zero;
	    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);
	};

	/**
	 * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
	 * @method computeGiMf
	 * @return {Number}
	 */
	var iMfi = new Vec3(),
	    iMfj = new Vec3(),
	    invIi_vmult_taui = new Vec3(),
	    invIj_vmult_tauj = new Vec3();
	Equation.prototype.computeGiMf = function(){
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	        bi = this.bi,
	        bj = this.bj,
	        fi = bi.force,
	        ti = bi.torque,
	        fj = bj.force,
	        tj = bj.torque,
	        invMassi = bi.invMassSolve,
	        invMassj = bj.invMassSolve;

	    if(bi.invInertiaWorldSolve){ bi.invInertiaWorldSolve.vmult(ti,invIi_vmult_taui); }
	    else { invIi_vmult_taui.set(0,0,0); }
	    if(bj.invInertiaWorldSolve){ bj.invInertiaWorldSolve.vmult(tj,invIj_vmult_tauj); }
	    else { invIj_vmult_tauj.set(0,0,0); }

	    fi.mult(invMassi,iMfi);
	    fj.mult(invMassj,iMfj);

	    return GA.multiplyVectors(iMfi,invIi_vmult_taui) + GB.multiplyVectors(iMfj,invIj_vmult_tauj);
	};

	/**
	 * Computes G*inv(M)*G'
	 * @method computeGiMGt
	 * @return {Number}
	 */
	var tmp = new Vec3();
	Equation.prototype.computeGiMGt = function(){
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	        bi = this.bi,
	        bj = this.bj,
	        invMassi = bi.invMassSolve,
	        invMassj = bj.invMassSolve,
	        invIi = bi.invInertiaWorldSolve,
	        invIj = bj.invInertiaWorldSolve,
	        result = invMassi + invMassj;

	    if(invIi){
	        invIi.vmult(GA.rotational,tmp);
	        result += tmp.dot(GA.rotational);
	    }

	    if(invIj){
	        invIj.vmult(GB.rotational,tmp);
	        result += tmp.dot(GB.rotational);
	    }

	    return  result;
	};

	var addToWlambda_temp = new Vec3(),
	    addToWlambda_Gi = new Vec3(),
	    addToWlambda_Gj = new Vec3(),
	    addToWlambda_ri = new Vec3(),
	    addToWlambda_rj = new Vec3(),
	    addToWlambda_Mdiag = new Vec3();

	/**
	 * Add constraint velocity to the bodies.
	 * @method addToWlambda
	 * @param {Number} deltalambda
	 */
	Equation.prototype.addToWlambda = function(deltalambda){
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	        bi = this.bi,
	        bj = this.bj,
	        temp = addToWlambda_temp;

	    // Add to linear velocity
	    // v_lambda += inv(M) * delta_lamba * G
	    GA.spatial.mult(bi.invMassSolve * deltalambda,temp);
	    bi.vlambda.vadd(temp, bi.vlambda);

	    GB.spatial.mult(bj.invMassSolve * deltalambda,temp);
	    bj.vlambda.vadd(temp, bj.vlambda);

	    // Add to angular velocity
	    if(bi.invInertiaWorldSolve){
	        bi.invInertiaWorldSolve.vmult(GA.rotational,temp);
	        temp.mult(deltalambda,temp);
	        bi.wlambda.vadd(temp,bi.wlambda);
	    }

	    if(bj.invInertiaWorldSolve){
	        bj.invInertiaWorldSolve.vmult(GB.rotational,temp);
	        temp.mult(deltalambda,temp);
	        bj.wlambda.vadd(temp,bj.wlambda);
	    }
	};

	/**
	 * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
	 * @method computeInvC
	 * @param  {Number} eps
	 * @return {Number}
	 */
	Equation.prototype.computeC = function(){
	    return this.computeGiMGt() + this.eps;
	};

	},{"../math/JacobianElement":26,"../math/Vec3":30}],21:[function(_dereq_,module,exports){
	module.exports = FrictionEquation;

	var Equation = _dereq_('./Equation');
	var Vec3 = _dereq_('../math/Vec3');
	var Mat3 = _dereq_('../math/Mat3');

	/**
	 * Constrains the slipping in a contact along a tangent
	 * @class FrictionEquation
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
	 * @extends Equation
	 */
	function FrictionEquation(bodyA, bodyB, slipForce){
	    Equation.call(this,bodyA, bodyB, -slipForce, slipForce);
	    this.ri = new Vec3();
	    this.rj = new Vec3();
	    this.t = new Vec3(); // tangent
	}

	FrictionEquation.prototype = new Equation();
	FrictionEquation.prototype.constructor = FrictionEquation;

	var FrictionEquation_computeB_temp1 = new Vec3();
	var FrictionEquation_computeB_temp2 = new Vec3();
	FrictionEquation.prototype.computeB = function(h){
	    var a = this.a,
	        b = this.b,
	        bi = this.bi,
	        bj = this.bj,
	        ri = this.ri,
	        rj = this.rj,
	        rixt = FrictionEquation_computeB_temp1,
	        rjxt = FrictionEquation_computeB_temp2,
	        t = this.t;

	    // Caluclate cross products
	    ri.cross(t,rixt);
	    rj.cross(t,rjxt);

	    // G = [-t -rixt t rjxt]
	    // And remember, this is a pure velocity constraint, g is always zero!
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB;
	    t.negate(GA.spatial);
	    rixt.negate(GA.rotational);
	    GB.spatial.copy(t);
	    GB.rotational.copy(rjxt);

	    var GW = this.computeGW();
	    var GiMf = this.computeGiMf();

	    var B = - GW * b - h * GiMf;

	    return B;
	};

	},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],22:[function(_dereq_,module,exports){
	module.exports = RotationalEquation;

	var Vec3 = _dereq_('../math/Vec3');
	var Mat3 = _dereq_('../math/Mat3');
	var Equation = _dereq_('./Equation');

	/**
	 * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
	 * @class RotationalEquation
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Vec3} [options.axisA]
	 * @param {Vec3} [options.axisB]
	 * @param {number} [options.maxForce]
	 * @extends Equation
	 */
	function RotationalEquation(bodyA, bodyB, options){
	    options = options || {};
	    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

	    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);

	    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
	    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);

	    this.maxAngle = Math.PI / 2;
	}

	RotationalEquation.prototype = new Equation();
	RotationalEquation.prototype.constructor = RotationalEquation;

	var tmpVec1 = new Vec3();
	var tmpVec2 = new Vec3();

	RotationalEquation.prototype.computeB = function(h){
	    var a = this.a,
	        b = this.b,

	        ni = this.axisA,
	        nj = this.axisB,

	        nixnj = tmpVec1,
	        njxni = tmpVec2,

	        GA = this.jacobianElementA,
	        GB = this.jacobianElementB;

	    // Caluclate cross products
	    ni.cross(nj, nixnj);
	    nj.cross(ni, njxni);

	    // g = ni * nj
	    // gdot = (nj x ni) * wi + (ni x nj) * wj
	    // G = [0 njxni 0 nixnj]
	    // W = [vi wi vj wj]
	    GA.rotational.copy(njxni);
	    GB.rotational.copy(nixnj);

	    var g = Math.cos(this.maxAngle) - ni.dot(nj),
	        GW = this.computeGW(),
	        GiMf = this.computeGiMf();

	    var B = - g * a - GW * b - h * GiMf;

	    return B;
	};


	},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],23:[function(_dereq_,module,exports){
	module.exports = RotationalMotorEquation;

	var Vec3 = _dereq_('../math/Vec3');
	var Mat3 = _dereq_('../math/Mat3');
	var Equation = _dereq_('./Equation');

	/**
	 * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
	 * @class RotationalMotorEquation
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Number} maxForce
	 * @extends Equation
	 */
	function RotationalMotorEquation(bodyA, bodyB, maxForce){
	    maxForce = typeof(maxForce)!=='undefined' ? maxForce : 1e6;
	    Equation.call(this,bodyA,bodyB,-maxForce,maxForce);

	    /**
	     * World oriented rotational axis
	     * @property {Vec3} axisA
	     */
	    this.axisA = new Vec3();

	    /**
	     * World oriented rotational axis
	     * @property {Vec3} axisB
	     */
	    this.axisB = new Vec3(); // World oriented rotational axis

	    /**
	     * Motor velocity
	     * @property {Number} targetVelocity
	     */
	    this.targetVelocity = 0;
	}

	RotationalMotorEquation.prototype = new Equation();
	RotationalMotorEquation.prototype.constructor = RotationalMotorEquation;

	RotationalMotorEquation.prototype.computeB = function(h){
	    var a = this.a,
	        b = this.b,
	        bi = this.bi,
	        bj = this.bj,

	        axisA = this.axisA,
	        axisB = this.axisB,

	        GA = this.jacobianElementA,
	        GB = this.jacobianElementB;

	    // g = 0
	    // gdot = axisA * wi - axisB * wj
	    // gdot = G * W = G * [vi wi vj wj]
	    // =>
	    // G = [0 axisA 0 -axisB]

	    GA.rotational.copy(axisA);
	    axisB.negate(GB.rotational);

	    var GW = this.computeGW() - this.targetVelocity,
	        GiMf = this.computeGiMf();

	    var B = - GW * b - h * GiMf;

	    return B;
	};

	},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],24:[function(_dereq_,module,exports){
	var Utils = _dereq_('../utils/Utils');

	module.exports = ContactMaterial;

	/**
	 * Defines what happens when two materials meet.
	 * @class ContactMaterial
	 * @constructor
	 * @param {Material} m1
	 * @param {Material} m2
	 * @param {object} [options]
	 * @param {Number} [options.friction=0.3]
	 * @param {Number} [options.restitution=0.3]
	 * @param {number} [options.contactEquationStiffness=1e7]
	 * @param {number} [options.contactEquationRelaxation=3]
	 * @param {number} [options.frictionEquationStiffness=1e7]
	 * @param {Number} [options.frictionEquationRelaxation=3]
	 */
	function ContactMaterial(m1, m2, options){
	    options = Utils.defaults(options, {
	        friction: 0.3,
	        restitution: 0.3,
	        contactEquationStiffness: 1e7,
	        contactEquationRelaxation: 3,
	        frictionEquationStiffness: 1e7,
	        frictionEquationRelaxation: 3
	    });

	    /**
	     * Identifier of this material
	     * @property {Number} id
	     */
	    this.id = ContactMaterial.idCounter++;

	    /**
	     * Participating materials
	     * @property {Array} materials
	     * @todo  Should be .materialA and .materialB instead
	     */
	    this.materials = [m1, m2];

	    /**
	     * Friction coefficient
	     * @property {Number} friction
	     */
	    this.friction = options.friction;

	    /**
	     * Restitution coefficient
	     * @property {Number} restitution
	     */
	    this.restitution = options.restitution;

	    /**
	     * Stiffness of the produced contact equations
	     * @property {Number} contactEquationStiffness
	     */
	    this.contactEquationStiffness = options.contactEquationStiffness;

	    /**
	     * Relaxation time of the produced contact equations
	     * @property {Number} contactEquationRelaxation
	     */
	    this.contactEquationRelaxation = options.contactEquationRelaxation;

	    /**
	     * Stiffness of the produced friction equations
	     * @property {Number} frictionEquationStiffness
	     */
	    this.frictionEquationStiffness = options.frictionEquationStiffness;

	    /**
	     * Relaxation time of the produced friction equations
	     * @property {Number} frictionEquationRelaxation
	     */
	    this.frictionEquationRelaxation = options.frictionEquationRelaxation;
	}

	ContactMaterial.idCounter = 0;

	},{"../utils/Utils":53}],25:[function(_dereq_,module,exports){
	module.exports = Material;

	/**
	 * Defines a physics material.
	 * @class Material
	 * @constructor
	 * @param {object} [options]
	 * @author schteppe
	 */
	function Material(options){
	    var name = '';
	    options = options || {};

	    // Backwards compatibility fix
	    if(typeof(options) === 'string'){
	        name = options;
	        options = {};
	    } else if(typeof(options) === 'object') {
	        name = '';
	    }

	    /**
	     * @property name
	     * @type {String}
	     */
	    this.name = name;

	    /**
	     * material id.
	     * @property id
	     * @type {number}
	     */
	    this.id = Material.idCounter++;

	    /**
	     * Friction for this material. If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
	     * @property {number} friction
	     */
	    this.friction = typeof(options.friction) !== 'undefined' ? options.friction : -1;

	    /**
	     * Restitution for this material. If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
	     * @property {number} restitution
	     */
	    this.restitution = typeof(options.restitution) !== 'undefined' ? options.restitution : -1;
	}

	Material.idCounter = 0;

	},{}],26:[function(_dereq_,module,exports){
	module.exports = JacobianElement;

	var Vec3 = _dereq_('./Vec3');

	/**
	 * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
	 * @class JacobianElement
	 * @constructor
	 */
	function JacobianElement(){

	    /**
	     * @property {Vec3} spatial
	     */
	    this.spatial = new Vec3();

	    /**
	     * @property {Vec3} rotational
	     */
	    this.rotational = new Vec3();
	}

	/**
	 * Multiply with other JacobianElement
	 * @method multiplyElement
	 * @param  {JacobianElement} element
	 * @return {Number}
	 */
	JacobianElement.prototype.multiplyElement = function(element){
	    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
	};

	/**
	 * Multiply with two vectors
	 * @method multiplyVectors
	 * @param  {Vec3} spatial
	 * @param  {Vec3} rotational
	 * @return {Number}
	 */
	JacobianElement.prototype.multiplyVectors = function(spatial,rotational){
	    return spatial.dot(this.spatial) + rotational.dot(this.rotational);
	};

	},{"./Vec3":30}],27:[function(_dereq_,module,exports){
	module.exports = Mat3;

	var Vec3 = _dereq_('./Vec3');

	/**
	 * A 3x3 matrix.
	 * @class Mat3
	 * @constructor
	 * @param array elements Array of nine elements. Optional.
	 * @author schteppe / http://github.com/schteppe
	 */
	function Mat3(elements){
	    /**
	     * A vector of length 9, containing all matrix elements
	     * @property {Array} elements
	     */
	    if(elements){
	        this.elements = elements;
	    } else {
	        this.elements = [0,0,0,0,0,0,0,0,0];
	    }
	}

	/**
	 * Sets the matrix to identity
	 * @method identity
	 * @todo Should perhaps be renamed to setIdentity() to be more clear.
	 * @todo Create another function that immediately creates an identity matrix eg. eye()
	 */
	Mat3.prototype.identity = function(){
	    var e = this.elements;
	    e[0] = 1;
	    e[1] = 0;
	    e[2] = 0;

	    e[3] = 0;
	    e[4] = 1;
	    e[5] = 0;

	    e[6] = 0;
	    e[7] = 0;
	    e[8] = 1;
	};

	/**
	 * Set all elements to zero
	 * @method setZero
	 */
	Mat3.prototype.setZero = function(){
	    var e = this.elements;
	    e[0] = 0;
	    e[1] = 0;
	    e[2] = 0;
	    e[3] = 0;
	    e[4] = 0;
	    e[5] = 0;
	    e[6] = 0;
	    e[7] = 0;
	    e[8] = 0;
	};

	/**
	 * Sets the matrix diagonal elements from a Vec3
	 * @method setTrace
	 * @param {Vec3} vec3
	 */
	Mat3.prototype.setTrace = function(vec3){
	    var e = this.elements;
	    e[0] = vec3.x;
	    e[4] = vec3.y;
	    e[8] = vec3.z;
	};

	/**
	 * Gets the matrix diagonal elements
	 * @method getTrace
	 * @return {Vec3}
	 */
	Mat3.prototype.getTrace = function(target){
	    var target = target || new Vec3();
	    var e = this.elements;
	    target.x = e[0];
	    target.y = e[4];
	    target.z = e[8];
	};

	/**
	 * Matrix-Vector multiplication
	 * @method vmult
	 * @param {Vec3} v The vector to multiply with
	 * @param {Vec3} target Optional, target to save the result in.
	 */
	Mat3.prototype.vmult = function(v,target){
	    target = target || new Vec3();

	    var e = this.elements,
	        x = v.x,
	        y = v.y,
	        z = v.z;
	    target.x = e[0]*x + e[1]*y + e[2]*z;
	    target.y = e[3]*x + e[4]*y + e[5]*z;
	    target.z = e[6]*x + e[7]*y + e[8]*z;

	    return target;
	};

	/**
	 * Matrix-scalar multiplication
	 * @method smult
	 * @param {Number} s
	 */
	Mat3.prototype.smult = function(s){
	    for(var i=0; i<this.elements.length; i++){
	        this.elements[i] *= s;
	    }
	};

	/**
	 * Matrix multiplication
	 * @method mmult
	 * @param {Mat3} m Matrix to multiply with from left side.
	 * @return {Mat3} The result.
	 */
	Mat3.prototype.mmult = function(m,target){
	    var r = target || new Mat3();
	    for(var i=0; i<3; i++){
	        for(var j=0; j<3; j++){
	            var sum = 0.0;
	            for(var k=0; k<3; k++){
	                sum += m.elements[i+k*3] * this.elements[k+j*3];
	            }
	            r.elements[i+j*3] = sum;
	        }
	    }
	    return r;
	};

	/**
	 * Scale each column of the matrix
	 * @method scale
	 * @param {Vec3} v
	 * @return {Mat3} The result.
	 */
	Mat3.prototype.scale = function(v,target){
	    target = target || new Mat3();
	    var e = this.elements,
	        t = target.elements;
	    for(var i=0; i!==3; i++){
	        t[3*i + 0] = v.x * e[3*i + 0];
	        t[3*i + 1] = v.y * e[3*i + 1];
	        t[3*i + 2] = v.z * e[3*i + 2];
	    }
	    return target;
	};

	/**
	 * Solve Ax=b
	 * @method solve
	 * @param {Vec3} b The right hand side
	 * @param {Vec3} target Optional. Target vector to save in.
	 * @return {Vec3} The solution x
	 * @todo should reuse arrays
	 */
	Mat3.prototype.solve = function(b,target){
	    target = target || new Vec3();

	    // Construct equations
	    var nr = 3; // num rows
	    var nc = 4; // num cols
	    var eqns = [];
	    for(var i=0; i<nr*nc; i++){
	        eqns.push(0);
	    }
	    var i,j;
	    for(i=0; i<3; i++){
	        for(j=0; j<3; j++){
	            eqns[i+nc*j] = this.elements[i+3*j];
	        }
	    }
	    eqns[3+4*0] = b.x;
	    eqns[3+4*1] = b.y;
	    eqns[3+4*2] = b.z;

	    // Compute right upper triangular version of the matrix - Gauss elimination
	    var n = 3, k = n, np;
	    var kp = 4; // num rows
	    var p, els;
	    do {
	        i = k - n;
	        if (eqns[i+nc*i] === 0) {
	            // the pivot is null, swap lines
	            for (j = i + 1; j < k; j++) {
	                if (eqns[i+nc*j] !== 0) {
	                    np = kp;
	                    do {  // do ligne( i ) = ligne( i ) + ligne( k )
	                        p = kp - np;
	                        eqns[p+nc*i] += eqns[p+nc*j];
	                    } while (--np);
	                    break;
	                }
	            }
	        }
	        if (eqns[i+nc*i] !== 0) {
	            for (j = i + 1; j < k; j++) {
	                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
	                np = kp;
	                do {  // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
	                    p = kp - np;
	                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
	                } while (--np);
	            }
	        }
	    } while (--n);

	    // Get the solution
	    target.z = eqns[2*nc+3] / eqns[2*nc+2];
	    target.y = (eqns[1*nc+3] - eqns[1*nc+2]*target.z) / eqns[1*nc+1];
	    target.x = (eqns[0*nc+3] - eqns[0*nc+2]*target.z - eqns[0*nc+1]*target.y) / eqns[0*nc+0];

	    if(isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x===Infinity || target.y===Infinity || target.z===Infinity){
	        throw "Could not solve equation! Got x=["+target.toString()+"], b=["+b.toString()+"], A=["+this.toString()+"]";
	    }

	    return target;
	};

	/**
	 * Get an element in the matrix by index. Index starts at 0, not 1!!!
	 * @method e
	 * @param {Number} row
	 * @param {Number} column
	 * @param {Number} value Optional. If provided, the matrix element will be set to this value.
	 * @return {Number}
	 */
	Mat3.prototype.e = function( row , column ,value){
	    if(value===undefined){
	        return this.elements[column+3*row];
	    } else {
	        // Set value
	        this.elements[column+3*row] = value;
	    }
	};

	/**
	 * Copy another matrix into this matrix object.
	 * @method copy
	 * @param {Mat3} source
	 * @return {Mat3} this
	 */
	Mat3.prototype.copy = function(source){
	    for(var i=0; i < source.elements.length; i++){
	        this.elements[i] = source.elements[i];
	    }
	    return this;
	};

	/**
	 * Returns a string representation of the matrix.
	 * @method toString
	 * @return string
	 */
	Mat3.prototype.toString = function(){
	    var r = "";
	    var sep = ",";
	    for(var i=0; i<9; i++){
	        r += this.elements[i] + sep;
	    }
	    return r;
	};

	/**
	 * reverse the matrix
	 * @method reverse
	 * @param {Mat3} target Optional. Target matrix to save in.
	 * @return {Mat3} The solution x
	 */
	Mat3.prototype.reverse = function(target){

	    target = target || new Mat3();

	    // Construct equations
	    var nr = 3; // num rows
	    var nc = 6; // num cols
	    var eqns = [];
	    for(var i=0; i<nr*nc; i++){
	        eqns.push(0);
	    }
	    var i,j;
	    for(i=0; i<3; i++){
	        for(j=0; j<3; j++){
	            eqns[i+nc*j] = this.elements[i+3*j];
	        }
	    }
	    eqns[3+6*0] = 1;
	    eqns[3+6*1] = 0;
	    eqns[3+6*2] = 0;
	    eqns[4+6*0] = 0;
	    eqns[4+6*1] = 1;
	    eqns[4+6*2] = 0;
	    eqns[5+6*0] = 0;
	    eqns[5+6*1] = 0;
	    eqns[5+6*2] = 1;

	    // Compute right upper triangular version of the matrix - Gauss elimination
	    var n = 3, k = n, np;
	    var kp = nc; // num rows
	    var p;
	    do {
	        i = k - n;
	        if (eqns[i+nc*i] === 0) {
	            // the pivot is null, swap lines
	            for (j = i + 1; j < k; j++) {
	                if (eqns[i+nc*j] !== 0) {
	                    np = kp;
	                    do { // do line( i ) = line( i ) + line( k )
	                        p = kp - np;
	                        eqns[p+nc*i] += eqns[p+nc*j];
	                    } while (--np);
	                    break;
	                }
	            }
	        }
	        if (eqns[i+nc*i] !== 0) {
	            for (j = i + 1; j < k; j++) {
	                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
	                np = kp;
	                do { // do line( k ) = line( k ) - multiplier * line( i )
	                    p = kp - np;
	                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
	                } while (--np);
	            }
	        }
	    } while (--n);

	    // eliminate the upper left triangle of the matrix
	    i = 2;
	    do {
	        j = i-1;
	        do {
	            var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
	            np = nc;
	            do {
	                p = nc - np;
	                eqns[p+nc*j] =  eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
	            } while (--np);
	        } while (j--);
	    } while (--i);

	    // operations on the diagonal
	    i = 2;
	    do {
	        var multiplier = 1 / eqns[i+nc*i];
	        np = nc;
	        do {
	            p = nc - np;
	            eqns[p+nc*i] = eqns[p+nc*i] * multiplier ;
	        } while (--np);
	    } while (i--);

	    i = 2;
	    do {
	        j = 2;
	        do {
	            p = eqns[nr+j+nc*i];
	            if( isNaN( p ) || p ===Infinity ){
	                throw "Could not reverse! A=["+this.toString()+"]";
	            }
	            target.e( i , j , p );
	        } while (j--);
	    } while (i--);

	    return target;
	};

	/**
	 * Set the matrix from a quaterion
	 * @method setRotationFromQuaternion
	 * @param {Quaternion} q
	 */
	Mat3.prototype.setRotationFromQuaternion = function( q ) {
	    var x = q.x, y = q.y, z = q.z, w = q.w,
	        x2 = x + x, y2 = y + y, z2 = z + z,
	        xx = x * x2, xy = x * y2, xz = x * z2,
	        yy = y * y2, yz = y * z2, zz = z * z2,
	        wx = w * x2, wy = w * y2, wz = w * z2,
	        e = this.elements;

	    e[3*0 + 0] = 1 - ( yy + zz );
	    e[3*0 + 1] = xy - wz;
	    e[3*0 + 2] = xz + wy;

	    e[3*1 + 0] = xy + wz;
	    e[3*1 + 1] = 1 - ( xx + zz );
	    e[3*1 + 2] = yz - wx;

	    e[3*2 + 0] = xz - wy;
	    e[3*2 + 1] = yz + wx;
	    e[3*2 + 2] = 1 - ( xx + yy );

	    return this;
	};

	/**
	 * Transpose the matrix
	 * @method transpose
	 * @param  {Mat3} target Where to store the result.
	 * @return {Mat3} The target Mat3, or a new Mat3 if target was omitted.
	 */
	Mat3.prototype.transpose = function( target ) {
	    target = target || new Mat3();

	    var Mt = target.elements,
	        M = this.elements;

	    for(var i=0; i!==3; i++){
	        for(var j=0; j!==3; j++){
	            Mt[3*i + j] = M[3*j + i];
	        }
	    }

	    return target;
	};

	},{"./Vec3":30}],28:[function(_dereq_,module,exports){
	module.exports = Quaternion;

	var Vec3 = _dereq_('./Vec3');

	/**
	 * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
	 * @class Quaternion
	 * @constructor
	 * @param {Number} x Multiplier of the imaginary basis vector i.
	 * @param {Number} y Multiplier of the imaginary basis vector j.
	 * @param {Number} z Multiplier of the imaginary basis vector k.
	 * @param {Number} w Multiplier of the real part.
	 * @see http://en.wikipedia.org/wiki/Quaternion
	 */
	function Quaternion(x,y,z,w){
	    /**
	     * @property {Number} x
	     */
	    this.x = x!==undefined ? x : 0;

	    /**
	     * @property {Number} y
	     */
	    this.y = y!==undefined ? y : 0;

	    /**
	     * @property {Number} z
	     */
	    this.z = z!==undefined ? z : 0;

	    /**
	     * The multiplier of the real quaternion basis vector.
	     * @property {Number} w
	     */
	    this.w = w!==undefined ? w : 1;
	}

	/**
	 * Set the value of the quaternion.
	 * @method set
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} z
	 * @param {Number} w
	 */
	Quaternion.prototype.set = function(x,y,z,w){
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    this.w = w;
	};

	/**
	 * Convert to a readable format
	 * @method toString
	 * @return string
	 */
	Quaternion.prototype.toString = function(){
	    return this.x+","+this.y+","+this.z+","+this.w;
	};

	/**
	 * Convert to an Array
	 * @method toArray
	 * @return Array
	 */
	Quaternion.prototype.toArray = function(){
	    return [this.x, this.y, this.z, this.w];
	};

	/**
	 * Set the quaternion components given an axis and an angle.
	 * @method setFromAxisAngle
	 * @param {Vec3} axis
	 * @param {Number} angle in radians
	 */
	Quaternion.prototype.setFromAxisAngle = function(axis,angle){
	    var s = Math.sin(angle*0.5);
	    this.x = axis.x * s;
	    this.y = axis.y * s;
	    this.z = axis.z * s;
	    this.w = Math.cos(angle*0.5);
	};

	/**
	 * Converts the quaternion to axis/angle representation.
	 * @method toAxisAngle
	 * @param {Vec3} targetAxis Optional. A vector object to reuse for storing the axis.
	 * @return Array An array, first elemnt is the axis and the second is the angle in radians.
	 */
	Quaternion.prototype.toAxisAngle = function(targetAxis){
	    targetAxis = targetAxis || new Vec3();
	    this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
	    var angle = 2 * Math.acos(this.w);
	    var s = Math.sqrt(1-this.w*this.w); // assuming quaternion normalised then w is less than 1, so term always positive.
	    if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
	        // if s close to zero then direction of axis not important
	        targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
	        targetAxis.y = this.y;
	        targetAxis.z = this.z;
	    } else {
	        targetAxis.x = this.x / s; // normalise axis
	        targetAxis.y = this.y / s;
	        targetAxis.z = this.z / s;
	    }
	    return [targetAxis,angle];
	};

	var sfv_t1 = new Vec3(),
	    sfv_t2 = new Vec3();

	/**
	 * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
	 * @method setFromVectors
	 * @param {Vec3} u
	 * @param {Vec3} v
	 */
	Quaternion.prototype.setFromVectors = function(u,v){
	    if(u.isAntiparallelTo(v)){
	        var t1 = sfv_t1;
	        var t2 = sfv_t2;

	        u.tangents(t1,t2);
	        this.setFromAxisAngle(t1,Math.PI);
	    } else {
	        var a = u.cross(v);
	        this.x = a.x;
	        this.y = a.y;
	        this.z = a.z;
	        this.w = Math.sqrt(Math.pow(u.norm(),2) * Math.pow(v.norm(),2)) + u.dot(v);
	        this.normalize();
	    }
	};

	/**
	 * Quaternion multiplication
	 * @method mult
	 * @param {Quaternion} q
	 * @param {Quaternion} target Optional.
	 * @return {Quaternion}
	 */
	var Quaternion_mult_va = new Vec3();
	var Quaternion_mult_vb = new Vec3();
	var Quaternion_mult_vaxvb = new Vec3();
	Quaternion.prototype.mult = function(q,target){
	    target = target || new Quaternion();
	    var w = this.w,
	        va = Quaternion_mult_va,
	        vb = Quaternion_mult_vb,
	        vaxvb = Quaternion_mult_vaxvb;

	    va.set(this.x,this.y,this.z);
	    vb.set(q.x,q.y,q.z);
	    target.w = w*q.w - va.dot(vb);
	    va.cross(vb,vaxvb);

	    target.x = w * vb.x + q.w*va.x + vaxvb.x;
	    target.y = w * vb.y + q.w*va.y + vaxvb.y;
	    target.z = w * vb.z + q.w*va.z + vaxvb.z;

	    return target;
	};

	/**
	 * Get the inverse quaternion rotation.
	 * @method inverse
	 * @param {Quaternion} target
	 * @return {Quaternion}
	 */
	Quaternion.prototype.inverse = function(target){
	    var x = this.x, y = this.y, z = this.z, w = this.w;
	    target = target || new Quaternion();

	    this.conjugate(target);
	    var inorm2 = 1/(x*x + y*y + z*z + w*w);
	    target.x *= inorm2;
	    target.y *= inorm2;
	    target.z *= inorm2;
	    target.w *= inorm2;

	    return target;
	};

	/**
	 * Get the quaternion conjugate
	 * @method conjugate
	 * @param {Quaternion} target
	 * @return {Quaternion}
	 */
	Quaternion.prototype.conjugate = function(target){
	    target = target || new Quaternion();

	    target.x = -this.x;
	    target.y = -this.y;
	    target.z = -this.z;
	    target.w = this.w;

	    return target;
	};

	/**
	 * Normalize the quaternion. Note that this changes the values of the quaternion.
	 * @method normalize
	 */
	Quaternion.prototype.normalize = function(){
	    var l = Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);
	    if ( l === 0 ) {
	        this.x = 0;
	        this.y = 0;
	        this.z = 0;
	        this.w = 0;
	    } else {
	        l = 1 / l;
	        this.x *= l;
	        this.y *= l;
	        this.z *= l;
	        this.w *= l;
	    }
	};

	/**
	 * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
	 * @method normalizeFast
	 * @see http://jsperf.com/fast-quaternion-normalization
	 * @author unphased, https://github.com/unphased
	 */
	Quaternion.prototype.normalizeFast = function () {
	    var f = (3.0-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2.0;
	    if ( f === 0 ) {
	        this.x = 0;
	        this.y = 0;
	        this.z = 0;
	        this.w = 0;
	    } else {
	        this.x *= f;
	        this.y *= f;
	        this.z *= f;
	        this.w *= f;
	    }
	};

	/**
	 * Multiply the quaternion by a vector
	 * @method vmult
	 * @param {Vec3} v
	 * @param {Vec3} target Optional
	 * @return {Vec3}
	 */
	Quaternion.prototype.vmult = function(v,target){
	    target = target || new Vec3();

	    var x = v.x,
	        y = v.y,
	        z = v.z;

	    var qx = this.x,
	        qy = this.y,
	        qz = this.z,
	        qw = this.w;

	    // q*v
	    var ix =  qw * x + qy * z - qz * y,
	    iy =  qw * y + qz * x - qx * z,
	    iz =  qw * z + qx * y - qy * x,
	    iw = -qx * x - qy * y - qz * z;

	    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

	    return target;
	};

	/**
	 * Copies value of source to this quaternion.
	 * @method copy
	 * @param {Quaternion} source
	 * @return {Quaternion} this
	 */
	Quaternion.prototype.copy = function(source){
	    this.x = source.x;
	    this.y = source.y;
	    this.z = source.z;
	    this.w = source.w;
	    return this;
	};

	/**
	 * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
	 * @method toEuler
	 * @param {Vec3} target
	 * @param string order Three-character string e.g. "YZX", which also is default.
	 */
	Quaternion.prototype.toEuler = function(target,order){
	    order = order || "YZX";

	    var heading, attitude, bank;
	    var x = this.x, y = this.y, z = this.z, w = this.w;

	    switch(order){
	    case "YZX":
	        var test = x*y + z*w;
	        if (test > 0.499) { // singularity at north pole
	            heading = 2 * Math.atan2(x,w);
	            attitude = Math.PI/2;
	            bank = 0;
	        }
	        if (test < -0.499) { // singularity at south pole
	            heading = -2 * Math.atan2(x,w);
	            attitude = - Math.PI/2;
	            bank = 0;
	        }
	        if(isNaN(heading)){
	            var sqx = x*x;
	            var sqy = y*y;
	            var sqz = z*z;
	            heading = Math.atan2(2*y*w - 2*x*z , 1 - 2*sqy - 2*sqz); // Heading
	            attitude = Math.asin(2*test); // attitude
	            bank = Math.atan2(2*x*w - 2*y*z , 1 - 2*sqx - 2*sqz); // bank
	        }
	        break;
	    default:
	        throw new Error("Euler order "+order+" not supported yet.");
	    }

	    target.y = heading;
	    target.z = attitude;
	    target.x = bank;
	};

	/**
	 * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
	 * @method setFromEuler
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} z
	 * @param {String} order The order to apply angles: 'XYZ' or 'YXZ' or any other combination
	 */
	Quaternion.prototype.setFromEuler = function ( x, y, z, order ) {
	    order = order || "XYZ";

	    var c1 = Math.cos( x / 2 );
	    var c2 = Math.cos( y / 2 );
	    var c3 = Math.cos( z / 2 );
	    var s1 = Math.sin( x / 2 );
	    var s2 = Math.sin( y / 2 );
	    var s3 = Math.sin( z / 2 );

	    if ( order === 'XYZ' ) {

	        this.x = s1 * c2 * c3 + c1 * s2 * s3;
	        this.y = c1 * s2 * c3 - s1 * c2 * s3;
	        this.z = c1 * c2 * s3 + s1 * s2 * c3;
	        this.w = c1 * c2 * c3 - s1 * s2 * s3;

	    } else if ( order === 'YXZ' ) {

	        this.x = s1 * c2 * c3 + c1 * s2 * s3;
	        this.y = c1 * s2 * c3 - s1 * c2 * s3;
	        this.z = c1 * c2 * s3 - s1 * s2 * c3;
	        this.w = c1 * c2 * c3 + s1 * s2 * s3;

	    } else if ( order === 'ZXY' ) {

	        this.x = s1 * c2 * c3 - c1 * s2 * s3;
	        this.y = c1 * s2 * c3 + s1 * c2 * s3;
	        this.z = c1 * c2 * s3 + s1 * s2 * c3;
	        this.w = c1 * c2 * c3 - s1 * s2 * s3;

	    } else if ( order === 'ZYX' ) {

	        this.x = s1 * c2 * c3 - c1 * s2 * s3;
	        this.y = c1 * s2 * c3 + s1 * c2 * s3;
	        this.z = c1 * c2 * s3 - s1 * s2 * c3;
	        this.w = c1 * c2 * c3 + s1 * s2 * s3;

	    } else if ( order === 'YZX' ) {

	        this.x = s1 * c2 * c3 + c1 * s2 * s3;
	        this.y = c1 * s2 * c3 + s1 * c2 * s3;
	        this.z = c1 * c2 * s3 - s1 * s2 * c3;
	        this.w = c1 * c2 * c3 - s1 * s2 * s3;

	    } else if ( order === 'XZY' ) {

	        this.x = s1 * c2 * c3 - c1 * s2 * s3;
	        this.y = c1 * s2 * c3 - s1 * c2 * s3;
	        this.z = c1 * c2 * s3 + s1 * s2 * c3;
	        this.w = c1 * c2 * c3 + s1 * s2 * s3;

	    }

	    return this;

	};

	Quaternion.prototype.clone = function(){
	    return new Quaternion(this.x, this.y, this.z, this.w);
	};
	},{"./Vec3":30}],29:[function(_dereq_,module,exports){
	var Vec3 = _dereq_('./Vec3');
	var Quaternion = _dereq_('./Quaternion');

	module.exports = Transform;

	/**
	 * @class Transform
	 * @constructor
	 */
	function Transform(options) {
	    options = options || {};

		/**
		 * @property {Vec3} position
		 */
		this.position = new Vec3();
	    if(options.position){
	        this.position.copy(options.position);
	    }

		/**
		 * @property {Quaternion} quaternion
		 */
		this.quaternion = new Quaternion();
	    if(options.quaternion){
	        this.quaternion.copy(options.quaternion);
	    }
	}

	var tmpQuat = new Quaternion();

	/**
	 * @static
	 * @method pointToLocaFrame
	 * @param {Vec3} position
	 * @param {Quaternion} quaternion
	 * @param {Vec3} worldPoint
	 * @param {Vec3} result
	 */
	Transform.pointToLocalFrame = function(position, quaternion, worldPoint, result){
	    var result = result || new Vec3();
	    worldPoint.vsub(position, result);
	    quaternion.conjugate(tmpQuat);
	    tmpQuat.vmult(result, result);
	    return result;
	};

	/**
	 * Get a global point in local transform coordinates.
	 * @method pointToLocal
	 * @param  {Vec3} point
	 * @param  {Vec3} result
	 * @return {Vec3} The "result" vector object
	 */
	Transform.prototype.pointToLocal = function(worldPoint, result){
	    return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
	};

	/**
	 * @static
	 * @method pointToWorldFrame
	 * @param {Vec3} position
	 * @param {Vec3} quaternion
	 * @param {Vec3} localPoint
	 * @param {Vec3} result
	 */
	Transform.pointToWorldFrame = function(position, quaternion, localPoint, result){
	    var result = result || new Vec3();
	    quaternion.vmult(localPoint, result);
	    result.vadd(position, result);
	    return result;
	};

	/**
	 * Get a local point in global transform coordinates.
	 * @method pointToWorld
	 * @param  {Vec3} point
	 * @param  {Vec3} result
	 * @return {Vec3} The "result" vector object
	 */
	Transform.prototype.pointToWorld = function(localPoint, result){
	    return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
	};


	Transform.prototype.vectorToWorldFrame = function(localVector, result){
	    var result = result || new Vec3();
	    this.quaternion.vmult(localVector, result);
	    return result;
	};

	Transform.vectorToWorldFrame = function(quaternion, localVector, result){
	    quaternion.vmult(localVector, result);
	    return result;
	};

	Transform.vectorToLocalFrame = function(position, quaternion, worldVector, result){
	    var result = result || new Vec3();
	    quaternion.w *= -1;
	    quaternion.vmult(worldVector, result);
	    quaternion.w *= -1;
	    return result;
	};

	},{"./Quaternion":28,"./Vec3":30}],30:[function(_dereq_,module,exports){
	module.exports = Vec3;

	var Mat3 = _dereq_('./Mat3');

	/**
	 * 3-dimensional vector
	 * @class Vec3
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} z
	 * @author schteppe
	 * @example
	 *     var v = new Vec3(1, 2, 3);
	 *     console.log('x=' + v.x); // x=1
	 */
	function Vec3(x,y,z){
	    /**
	     * @property x
	     * @type {Number}
	     */
	    this.x = x||0.0;

	    /**
	     * @property y
	     * @type {Number}
	     */
	    this.y = y||0.0;

	    /**
	     * @property z
	     * @type {Number}
	     */
	    this.z = z||0.0;
	}

	/**
	 * @static
	 * @property {Vec3} ZERO
	 */
	Vec3.ZERO = new Vec3(0, 0, 0);

	/**
	 * @static
	 * @property {Vec3} UNIT_X
	 */
	Vec3.UNIT_X = new Vec3(1, 0, 0);

	/**
	 * @static
	 * @property {Vec3} UNIT_Y
	 */
	Vec3.UNIT_Y = new Vec3(0, 1, 0);

	/**
	 * @static
	 * @property {Vec3} UNIT_Z
	 */
	Vec3.UNIT_Z = new Vec3(0, 0, 1);

	/**
	 * Vector cross product
	 * @method cross
	 * @param {Vec3} v
	 * @param {Vec3} target Optional. Target to save in.
	 * @return {Vec3}
	 */
	Vec3.prototype.cross = function(v,target){
	    var vx=v.x, vy=v.y, vz=v.z, x=this.x, y=this.y, z=this.z;
	    target = target || new Vec3();

	    target.x = (y * vz) - (z * vy);
	    target.y = (z * vx) - (x * vz);
	    target.z = (x * vy) - (y * vx);

	    return target;
	};

	/**
	 * Set the vectors' 3 elements
	 * @method set
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} z
	 * @return Vec3
	 */
	Vec3.prototype.set = function(x,y,z){
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    return this;
	};

	/**
	 * Set all components of the vector to zero.
	 * @method setZero
	 */
	Vec3.prototype.setZero = function(){
	    this.x = this.y = this.z = 0;
	};

	/**
	 * Vector addition
	 * @method vadd
	 * @param {Vec3} v
	 * @param {Vec3} target Optional.
	 * @return {Vec3}
	 */
	Vec3.prototype.vadd = function(v,target){
	    if(target){
	        target.x = v.x + this.x;
	        target.y = v.y + this.y;
	        target.z = v.z + this.z;
	    } else {
	        return new Vec3(this.x + v.x,
	                               this.y + v.y,
	                               this.z + v.z);
	    }
	};

	/**
	 * Vector subtraction
	 * @method vsub
	 * @param {Vec3} v
	 * @param {Vec3} target Optional. Target to save in.
	 * @return {Vec3}
	 */
	Vec3.prototype.vsub = function(v,target){
	    if(target){
	        target.x = this.x - v.x;
	        target.y = this.y - v.y;
	        target.z = this.z - v.z;
	    } else {
	        return new Vec3(this.x-v.x,
	                               this.y-v.y,
	                               this.z-v.z);
	    }
	};

	/**
	 * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
	 * @method crossmat
	 * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
	 * @return {Mat3}
	 */
	Vec3.prototype.crossmat = function(){
	    return new Mat3([     0,  -this.z,   this.y,
	                            this.z,        0,  -this.x,
	                           -this.y,   this.x,        0]);
	};

	/**
	 * Normalize the vector. Note that this changes the values in the vector.
	 * @method normalize
	 * @return {Number} Returns the norm of the vector
	 */
	Vec3.prototype.normalize = function(){
	    var x=this.x, y=this.y, z=this.z;
	    var n = Math.sqrt(x*x + y*y + z*z);
	    if(n>0.0){
	        var invN = 1/n;
	        this.x *= invN;
	        this.y *= invN;
	        this.z *= invN;
	    } else {
	        // Make something up
	        this.x = 0;
	        this.y = 0;
	        this.z = 0;
	    }
	    return n;
	};

	/**
	 * Get the version of this vector that is of length 1.
	 * @method unit
	 * @param {Vec3} target Optional target to save in
	 * @return {Vec3} Returns the unit vector
	 */
	Vec3.prototype.unit = function(target){
	    target = target || new Vec3();
	    var x=this.x, y=this.y, z=this.z;
	    var ninv = Math.sqrt(x*x + y*y + z*z);
	    if(ninv>0.0){
	        ninv = 1.0/ninv;
	        target.x = x * ninv;
	        target.y = y * ninv;
	        target.z = z * ninv;
	    } else {
	        target.x = 1;
	        target.y = 0;
	        target.z = 0;
	    }
	    return target;
	};

	/**
	 * Get the length of the vector
	 * @method norm
	 * @return {Number}
	 * @deprecated Use .length() instead
	 */
	Vec3.prototype.norm = function(){
	    var x=this.x, y=this.y, z=this.z;
	    return Math.sqrt(x*x + y*y + z*z);
	};

	/**
	 * Get the length of the vector
	 * @method length
	 * @return {Number}
	 */
	Vec3.prototype.length = Vec3.prototype.norm;

	/**
	 * Get the squared length of the vector
	 * @method norm2
	 * @return {Number}
	 * @deprecated Use .lengthSquared() instead.
	 */
	Vec3.prototype.norm2 = function(){
	    return this.dot(this);
	};

	/**
	 * Get the squared length of the vector.
	 * @method lengthSquared
	 * @return {Number}
	 */
	Vec3.prototype.lengthSquared = Vec3.prototype.norm2;

	/**
	 * Get distance from this point to another point
	 * @method distanceTo
	 * @param  {Vec3} p
	 * @return {Number}
	 */
	Vec3.prototype.distanceTo = function(p){
	    var x=this.x, y=this.y, z=this.z;
	    var px=p.x, py=p.y, pz=p.z;
	    return Math.sqrt((px-x)*(px-x)+
	                     (py-y)*(py-y)+
	                     (pz-z)*(pz-z));
	};

	/**
	 * Get squared distance from this point to another point
	 * @method distanceSquared
	 * @param  {Vec3} p
	 * @return {Number}
	 */
	Vec3.prototype.distanceSquared = function(p){
	    var x=this.x, y=this.y, z=this.z;
	    var px=p.x, py=p.y, pz=p.z;
	    return (px-x)*(px-x) + (py-y)*(py-y) + (pz-z)*(pz-z);
	};

	/**
	 * Multiply all the components of the vector with a scalar.
	 * @deprecated Use .scale instead
	 * @method mult
	 * @param {Number} scalar
	 * @param {Vec3} target The vector to save the result in.
	 * @return {Vec3}
	 * @deprecated Use .scale() instead
	 */
	Vec3.prototype.mult = function(scalar,target){
	    target = target || new Vec3();
	    var x = this.x,
	        y = this.y,
	        z = this.z;
	    target.x = scalar * x;
	    target.y = scalar * y;
	    target.z = scalar * z;
	    return target;
	};

	/**
	 * Multiply the vector with a scalar.
	 * @method scale
	 * @param {Number} scalar
	 * @param {Vec3} target
	 * @return {Vec3}
	 */
	Vec3.prototype.scale = Vec3.prototype.mult;

	/**
	 * Calculate dot product
	 * @method dot
	 * @param {Vec3} v
	 * @return {Number}
	 */
	Vec3.prototype.dot = function(v){
	    return this.x * v.x + this.y * v.y + this.z * v.z;
	};

	/**
	 * @method isZero
	 * @return bool
	 */
	Vec3.prototype.isZero = function(){
	    return this.x===0 && this.y===0 && this.z===0;
	};

	/**
	 * Make the vector point in the opposite direction.
	 * @method negate
	 * @param {Vec3} target Optional target to save in
	 * @return {Vec3}
	 */
	Vec3.prototype.negate = function(target){
	    target = target || new Vec3();
	    target.x = -this.x;
	    target.y = -this.y;
	    target.z = -this.z;
	    return target;
	};

	/**
	 * Compute two artificial tangents to the vector
	 * @method tangents
	 * @param {Vec3} t1 Vector object to save the first tangent in
	 * @param {Vec3} t2 Vector object to save the second tangent in
	 */
	var Vec3_tangents_n = new Vec3();
	var Vec3_tangents_randVec = new Vec3();
	Vec3.prototype.tangents = function(t1,t2){
	    var norm = this.norm();
	    if(norm>0.0){
	        var n = Vec3_tangents_n;
	        var inorm = 1/norm;
	        n.set(this.x*inorm,this.y*inorm,this.z*inorm);
	        var randVec = Vec3_tangents_randVec;
	        if(Math.abs(n.x) < 0.9){
	            randVec.set(1,0,0);
	            n.cross(randVec,t1);
	        } else {
	            randVec.set(0,1,0);
	            n.cross(randVec,t1);
	        }
	        n.cross(t1,t2);
	    } else {
	        // The normal length is zero, make something up
	        t1.set(1, 0, 0);
	        t2.set(0, 1, 0);
	    }
	};

	/**
	 * Converts to a more readable format
	 * @method toString
	 * @return string
	 */
	Vec3.prototype.toString = function(){
	    return this.x+","+this.y+","+this.z;
	};

	/**
	 * Converts to an array
	 * @method toArray
	 * @return Array
	 */
	Vec3.prototype.toArray = function(){
	    return [this.x, this.y, this.z];
	};

	/**
	 * Copies value of source to this vector.
	 * @method copy
	 * @param {Vec3} source
	 * @return {Vec3} this
	 */
	Vec3.prototype.copy = function(source){
	    this.x = source.x;
	    this.y = source.y;
	    this.z = source.z;
	    return this;
	};


	/**
	 * Do a linear interpolation between two vectors
	 * @method lerp
	 * @param {Vec3} v
	 * @param {Number} t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
	 * @param {Vec3} target
	 */
	Vec3.prototype.lerp = function(v,t,target){
	    var x=this.x, y=this.y, z=this.z;
	    target.x = x + (v.x-x)*t;
	    target.y = y + (v.y-y)*t;
	    target.z = z + (v.z-z)*t;
	};

	/**
	 * Check if a vector equals is almost equal to another one.
	 * @method almostEquals
	 * @param {Vec3} v
	 * @param {Number} precision
	 * @return bool
	 */
	Vec3.prototype.almostEquals = function(v,precision){
	    if(precision===undefined){
	        precision = 1e-6;
	    }
	    if( Math.abs(this.x-v.x)>precision ||
	        Math.abs(this.y-v.y)>precision ||
	        Math.abs(this.z-v.z)>precision){
	        return false;
	    }
	    return true;
	};

	/**
	 * Check if a vector is almost zero
	 * @method almostZero
	 * @param {Number} precision
	 */
	Vec3.prototype.almostZero = function(precision){
	    if(precision===undefined){
	        precision = 1e-6;
	    }
	    if( Math.abs(this.x)>precision ||
	        Math.abs(this.y)>precision ||
	        Math.abs(this.z)>precision){
	        return false;
	    }
	    return true;
	};

	var antip_neg = new Vec3();

	/**
	 * Check if the vector is anti-parallel to another vector.
	 * @method isAntiparallelTo
	 * @param  {Vec3}  v
	 * @param  {Number}  precision Set to zero for exact comparisons
	 * @return {Boolean}
	 */
	Vec3.prototype.isAntiparallelTo = function(v,precision){
	    this.negate(antip_neg);
	    return antip_neg.almostEquals(v,precision);
	};

	/**
	 * Clone the vector
	 * @method clone
	 * @return {Vec3}
	 */
	Vec3.prototype.clone = function(){
	    return new Vec3(this.x, this.y, this.z);
	};
	},{"./Mat3":27}],31:[function(_dereq_,module,exports){
	module.exports = Body;

	var EventTarget = _dereq_('../utils/EventTarget');
	var Shape = _dereq_('../shapes/Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Mat3 = _dereq_('../math/Mat3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Material = _dereq_('../material/Material');
	var AABB = _dereq_('../collision/AABB');
	var Box = _dereq_('../shapes/Box');

	/**
	 * Base class for all body types.
	 * @class Body
	 * @constructor
	 * @extends EventTarget
	 * @param {object} [options]
	 * @param {Vec3} [options.position]
	 * @param {Vec3} [options.velocity]
	 * @param {Vec3} [options.angularVelocity]
	 * @param {Quaternion} [options.quaternion]
	 * @param {number} [options.mass]
	 * @param {Material} [options.material]
	 * @param {number} [options.type]
	 * @param {number} [options.linearDamping=0.01]
	 * @param {number} [options.angularDamping=0.01]
	 * @param {boolean} [options.allowSleep=true]
	 * @param {number} [options.sleepSpeedLimit=0.1]
	 * @param {number} [options.sleepTimeLimit=1]
	 * @param {number} [options.collisionFilterGroup=1]
	 * @param {number} [options.collisionFilterMask=1]
	 * @param {boolean} [options.fixedRotation=false]
	 * @param {Body} [options.shape]
	 * @example
	 *     var body = new Body({
	 *         mass: 1
	 *     });
	 *     var shape = new Sphere(1);
	 *     body.addShape(shape);
	 *     world.add(body);
	 */
	function Body(options){
	    options = options || {};

	    EventTarget.apply(this);

	    this.id = Body.idCounter++;

	    /**
	     * Reference to the world the body is living in
	     * @property world
	     * @type {World}
	     */
	    this.world = null;

	    /**
	     * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this Body object.
	     * @property preStep
	     * @type {Function}
	     * @deprecated Use World events instead
	     */
	    this.preStep = null;

	    /**
	     * Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this Body object.
	     * @property postStep
	     * @type {Function}
	     * @deprecated Use World events instead
	     */
	    this.postStep = null;

	    this.vlambda = new Vec3();

	    /**
	     * @property {Number} collisionFilterGroup
	     */
	    this.collisionFilterGroup = typeof(options.collisionFilterGroup) === 'number' ? options.collisionFilterGroup : 1;

	    /**
	     * @property {Number} collisionFilterMask
	     */
	    this.collisionFilterMask = typeof(options.collisionFilterMask) === 'number' ? options.collisionFilterMask : 1;

	    /**
	     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
	     * @property {Number} collisionResponse
	     */
		this.collisionResponse = true;

	    /**
	     * @property position
	     * @type {Vec3}
	     */
	    this.position = new Vec3();

	    if(options.position){
	        this.position.copy(options.position);
	    }

	    /**
	     * @property {Vec3} previousPosition
	     */
	    this.previousPosition = new Vec3();

	    /**
	     * Initial position of the body
	     * @property initPosition
	     * @type {Vec3}
	     */
	    this.initPosition = new Vec3();

	    /**
	     * @property velocity
	     * @type {Vec3}
	     */
	    this.velocity = new Vec3();

	    if(options.velocity){
	        this.velocity.copy(options.velocity);
	    }

	    /**
	     * @property initVelocity
	     * @type {Vec3}
	     */
	    this.initVelocity = new Vec3();

	    /**
	     * Linear force on the body
	     * @property force
	     * @type {Vec3}
	     */
	    this.force = new Vec3();

	    var mass = typeof(options.mass) === 'number' ? options.mass : 0;

	    /**
	     * @property mass
	     * @type {Number}
	     * @default 0
	     */
	    this.mass = mass;

	    /**
	     * @property invMass
	     * @type {Number}
	     */
	    this.invMass = mass > 0 ? 1.0 / mass : 0;

	    /**
	     * @property material
	     * @type {Material}
	     */
	    this.material = options.material || null;

	    /**
	     * @property linearDamping
	     * @type {Number}
	     */
	    this.linearDamping = typeof(options.linearDamping) === 'number' ? options.linearDamping : 0.01;

	    /**
	     * One of: Body.DYNAMIC, Body.STATIC and Body.KINEMATIC.
	     * @property type
	     * @type {Number}
	     */
	    this.type = (mass <= 0.0 ? Body.STATIC : Body.DYNAMIC);
	    if(typeof(options.type) === typeof(Body.STATIC)){
	        this.type = options.type;
	    }

	    /**
	     * If true, the body will automatically fall to sleep.
	     * @property allowSleep
	     * @type {Boolean}
	     * @default true
	     */
	    this.allowSleep = typeof(options.allowSleep) !== 'undefined' ? options.allowSleep : true;

	    /**
	     * Current sleep state.
	     * @property sleepState
	     * @type {Number}
	     */
	    this.sleepState = 0;

	    /**
	     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
	     * @property sleepSpeedLimit
	     * @type {Number}
	     * @default 0.1
	     */
	    this.sleepSpeedLimit = typeof(options.sleepSpeedLimit) !== 'undefined' ? options.sleepSpeedLimit : 0.1;

	    /**
	     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
	     * @property sleepTimeLimit
	     * @type {Number}
	     * @default 1
	     */
	    this.sleepTimeLimit = typeof(options.sleepTimeLimit) !== 'undefined' ? options.sleepTimeLimit : 1;

	    this.timeLastSleepy = 0;

	    this._wakeUpAfterNarrowphase = false;


	    /**
	     * Rotational force on the body, around center of mass
	     * @property {Vec3} torque
	     */
	    this.torque = new Vec3();

	    /**
	     * Orientation of the body
	     * @property quaternion
	     * @type {Quaternion}
	     */
	    this.quaternion = new Quaternion();

	    if(options.quaternion){
	        this.quaternion.copy(options.quaternion);
	    }

	    /**
	     * @property initQuaternion
	     * @type {Quaternion}
	     */
	    this.initQuaternion = new Quaternion();

	    /**
	     * @property angularVelocity
	     * @type {Vec3}
	     */
	    this.angularVelocity = new Vec3();

	    if(options.angularVelocity){
	        this.angularVelocity.copy(options.angularVelocity);
	    }

	    /**
	     * @property initAngularVelocity
	     * @type {Vec3}
	     */
	    this.initAngularVelocity = new Vec3();

	    this.interpolatedPosition = new Vec3();
	    this.interpolatedQuaternion = new Quaternion();

	    /**
	     * @property shapes
	     * @type {array}
	     */
	    this.shapes = [];

	    /**
	     * @property shapeOffsets
	     * @type {array}
	     */
	    this.shapeOffsets = [];

	    /**
	     * @property shapeOrientations
	     * @type {array}
	     */
	    this.shapeOrientations = [];

	    /**
	     * @property inertia
	     * @type {Vec3}
	     */
	    this.inertia = new Vec3();

	    /**
	     * @property {Vec3} invInertia
	     */
	    this.invInertia = new Vec3();

	    /**
	     * @property {Mat3} invInertiaWorld
	     */
	    this.invInertiaWorld = new Mat3();

	    this.invMassSolve = 0;

	    /**
	     * @property {Vec3} invInertiaSolve
	     */
	    this.invInertiaSolve = new Vec3();

	    /**
	     * @property {Mat3} invInertiaWorldSolve
	     */
	    this.invInertiaWorldSolve = new Mat3();

	    /**
	     * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() after changing this.
	     * @property {Boolean} fixedRotation
	     * @default false
	     */
	    this.fixedRotation = typeof(options.fixedRotation) !== "undefined" ? options.fixedRotation : false;

	    /**
	     * @property {Number} angularDamping
	     */
	    this.angularDamping = typeof(options.angularDamping) !== 'undefined' ? options.angularDamping : 0.01;

	    /**
	     * @property aabb
	     * @type {AABB}
	     */
	    this.aabb = new AABB();

	    /**
	     * Indicates if the AABB needs to be updated before use.
	     * @property aabbNeedsUpdate
	     * @type {Boolean}
	     */
	    this.aabbNeedsUpdate = true;

	    this.wlambda = new Vec3();

	    if(options.shape){
	        this.addShape(options.shape);
	    }

	    this.updateMassProperties();
	}
	Body.prototype = new EventTarget();
	Body.prototype.constructor = Body;

	/**
	 * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
	 * @static
	 * @property DYNAMIC
	 * @type {Number}
	 */
	Body.DYNAMIC = 1;

	/**
	 * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
	 * @static
	 * @property STATIC
	 * @type {Number}
	 */
	Body.STATIC = 2;

	/**
	 * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
	 * @static
	 * @property KINEMATIC
	 * @type {Number}
	 */
	Body.KINEMATIC = 4;



	/**
	 * @static
	 * @property AWAKE
	 * @type {number}
	 */
	Body.AWAKE = 0;

	/**
	 * @static
	 * @property SLEEPY
	 * @type {number}
	 */
	Body.SLEEPY = 1;

	/**
	 * @static
	 * @property SLEEPING
	 * @type {number}
	 */
	Body.SLEEPING = 2;

	Body.idCounter = 0;

	/**
	 * Wake the body up.
	 * @method wakeUp
	 */
	Body.prototype.wakeUp = function(){
	    var s = this.sleepState;
	    this.sleepState = 0;
	    if(s === Body.SLEEPING){
	        this.dispatchEvent({type:"wakeup"});
	    }
	};

	/**
	 * Force body sleep
	 * @method sleep
	 */
	Body.prototype.sleep = function(){
	    this.sleepState = Body.SLEEPING;
	    this.velocity.set(0,0,0);
	    this.angularVelocity.set(0,0,0);
	};

	Body.sleepyEvent = {
	    type: "sleepy"
	};

	Body.sleepEvent = {
	    type: "sleep"
	};

	/**
	 * Called every timestep to update internal sleep timer and change sleep state if needed.
	 * @method sleepTick
	 * @param {Number} time The world time in seconds
	 */
	Body.prototype.sleepTick = function(time){
	    if(this.allowSleep){
	        var sleepState = this.sleepState;
	        var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();
	        var speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);
	        if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){
	            this.sleepState = Body.SLEEPY; // Sleepy
	            this.timeLastSleepy = time;
	            this.dispatchEvent(Body.sleepyEvent);
	        } else if(sleepState===Body.SLEEPY && speedSquared > speedLimitSquared){
	            this.wakeUp(); // Wake up
	        } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){
	            this.sleep(); // Sleeping
	            this.dispatchEvent(Body.sleepEvent);
	        }
	    }
	};

	/**
	 * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
	 * @method updateSolveMassProperties
	 */
	Body.prototype.updateSolveMassProperties = function(){
	    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
	        this.invMassSolve = 0;
	        this.invInertiaSolve.setZero();
	        this.invInertiaWorldSolve.setZero();
	    } else {
	        this.invMassSolve = this.invMass;
	        this.invInertiaSolve.copy(this.invInertia);
	        this.invInertiaWorldSolve.copy(this.invInertiaWorld);
	    }
	};

	/**
	 * Convert a world point to local body frame.
	 * @method pointToLocalFrame
	 * @param  {Vec3} worldPoint
	 * @param  {Vec3} result
	 * @return {Vec3}
	 */
	Body.prototype.pointToLocalFrame = function(worldPoint,result){
	    var result = result || new Vec3();
	    worldPoint.vsub(this.position,result);
	    this.quaternion.conjugate().vmult(result,result);
	    return result;
	};

	/**
	 * Convert a world vector to local body frame.
	 * @method vectorToLocalFrame
	 * @param  {Vec3} worldPoint
	 * @param  {Vec3} result
	 * @return {Vec3}
	 */
	Body.prototype.vectorToLocalFrame = function(worldVector, result){
	    var result = result || new Vec3();
	    this.quaternion.conjugate().vmult(worldVector,result);
	    return result;
	};

	/**
	 * Convert a local body point to world frame.
	 * @method pointToWorldFrame
	 * @param  {Vec3} localPoint
	 * @param  {Vec3} result
	 * @return {Vec3}
	 */
	Body.prototype.pointToWorldFrame = function(localPoint,result){
	    var result = result || new Vec3();
	    this.quaternion.vmult(localPoint,result);
	    result.vadd(this.position,result);
	    return result;
	};

	/**
	 * Convert a local body point to world frame.
	 * @method vectorToWorldFrame
	 * @param  {Vec3} localVector
	 * @param  {Vec3} result
	 * @return {Vec3}
	 */
	Body.prototype.vectorToWorldFrame = function(localVector, result){
	    var result = result || new Vec3();
	    this.quaternion.vmult(localVector, result);
	    return result;
	};

	var tmpVec = new Vec3();
	var tmpQuat = new Quaternion();

	/**
	 * Add a shape to the body with a local offset and orientation.
	 * @method addShape
	 * @param {Shape} shape
	 * @param {Vec3} offset
	 * @param {Quaternion} quaternion
	 * @return {Body} The body object, for chainability.
	 */
	Body.prototype.addShape = function(shape, _offset, _orientation){
	    var offset = new Vec3();
	    var orientation = new Quaternion();

	    if(_offset){
	        offset.copy(_offset);
	    }
	    if(_orientation){
	        orientation.copy(_orientation);
	    }

	    this.shapes.push(shape);
	    this.shapeOffsets.push(offset);
	    this.shapeOrientations.push(orientation);
	    this.updateMassProperties();
	    this.updateBoundingRadius();

	    this.aabbNeedsUpdate = true;

	    return this;
	};

	/**
	 * Update the bounding radius of the body. Should be done if any of the shapes are changed.
	 * @method updateBoundingRadius
	 */
	Body.prototype.updateBoundingRadius = function(){
	    var shapes = this.shapes,
	        shapeOffsets = this.shapeOffsets,
	        N = shapes.length,
	        radius = 0;

	    for(var i=0; i!==N; i++){
	        var shape = shapes[i];
	        shape.updateBoundingSphereRadius();
	        var offset = shapeOffsets[i].norm(),
	            r = shape.boundingSphereRadius;
	        if(offset + r > radius){
	            radius = offset + r;
	        }
	    }

	    this.boundingRadius = radius;
	};

	var computeAABB_shapeAABB = new AABB();

	/**
	 * Updates the .aabb
	 * @method computeAABB
	 * @todo rename to updateAABB()
	 */
	Body.prototype.computeAABB = function(){
	    var shapes = this.shapes,
	        shapeOffsets = this.shapeOffsets,
	        shapeOrientations = this.shapeOrientations,
	        N = shapes.length,
	        offset = tmpVec,
	        orientation = tmpQuat,
	        bodyQuat = this.quaternion,
	        aabb = this.aabb,
	        shapeAABB = computeAABB_shapeAABB;

	    for(var i=0; i!==N; i++){
	        var shape = shapes[i];

	        // Get shape world quaternion
	        shapeOrientations[i].mult(bodyQuat, orientation);

	        // Get shape world position
	        orientation.vmult(shapeOffsets[i], offset);
	        offset.vadd(this.position, offset);

	        // vec2.rotate(offset, shapeOffsets[i], bodyAngle);
	        // vec2.add(offset, offset, this.position);

	        // Get shape AABB
	        shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);

	        if(i === 0){
	            aabb.copy(shapeAABB);
	        } else {
	            aabb.extend(shapeAABB);
	        }
	    }

	    this.aabbNeedsUpdate = false;
	};

	var uiw_m1 = new Mat3(),
	    uiw_m2 = new Mat3(),
	    uiw_m3 = new Mat3();

	/**
	 * Update .inertiaWorld and .invInertiaWorld
	 * @method updateInertiaWorld
	 */
	Body.prototype.updateInertiaWorld = function(force){
	    var I = this.invInertia;
	    if (I.x === I.y && I.y === I.z && !force) {
	        // If inertia M = s*I, where I is identity and s a scalar, then
	        //    R*M*R' = R*(s*I)*R' = s*R*I*R' = s*R*R' = s*I = M
	        // where R is the rotation matrix.
	        // In other words, we don't have to transform the inertia if all
	        // inertia diagonal entries are equal.
	    } else {
	        var m1 = uiw_m1,
	            m2 = uiw_m2,
	            m3 = uiw_m3;
	        m1.setRotationFromQuaternion(this.quaternion);
	        m1.transpose(m2);
	        m1.scale(I,m1);
	        m1.mmult(m2,this.invInertiaWorld);
	        //m3.getTrace(this.invInertiaWorld);
	    }

	    /*
	    this.quaternion.vmult(this.inertia,this.inertiaWorld);
	    this.quaternion.vmult(this.invInertia,this.invInertiaWorld);
	    */
	};

	/**
	 * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.torque.
	 * @method applyForce
	 * @param  {Vec3} force The amount of force to add.
	 * @param  {Vec3} worldPoint A world point to apply the force on.
	 */
	var Body_applyForce_r = new Vec3();
	var Body_applyForce_rotForce = new Vec3();
	Body.prototype.applyForce = function(force,worldPoint){
	    if(this.type !== Body.DYNAMIC){
	        return;
	    }

	    // Compute point position relative to the body center
	    var r = Body_applyForce_r;
	    worldPoint.vsub(this.position,r);

	    // Compute produced rotational force
	    var rotForce = Body_applyForce_rotForce;
	    r.cross(force,rotForce);

	    // Add linear force
	    this.force.vadd(force,this.force);

	    // Add rotational force
	    this.torque.vadd(rotForce,this.torque);
	};

	/**
	 * Apply force to a local point in the body.
	 * @method applyLocalForce
	 * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
	 * @param  {Vec3} localPoint A local point in the body to apply the force on.
	 */
	var Body_applyLocalForce_worldForce = new Vec3();
	var Body_applyLocalForce_worldPoint = new Vec3();
	Body.prototype.applyLocalForce = function(localForce, localPoint){
	    if(this.type !== Body.DYNAMIC){
	        return;
	    }

	    var worldForce = Body_applyLocalForce_worldForce;
	    var worldPoint = Body_applyLocalForce_worldPoint;

	    // Transform the force vector to world space
	    this.vectorToWorldFrame(localForce, worldForce);
	    this.pointToWorldFrame(localPoint, worldPoint);

	    this.applyForce(worldForce, worldPoint);
	};

	/**
	 * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
	 * @method applyImpulse
	 * @param  {Vec3} impulse The amount of impulse to add.
	 * @param  {Vec3} worldPoint A world point to apply the force on.
	 */
	var Body_applyImpulse_r = new Vec3();
	var Body_applyImpulse_velo = new Vec3();
	var Body_applyImpulse_rotVelo = new Vec3();
	Body.prototype.applyImpulse = function(impulse, worldPoint){
	    if(this.type !== Body.DYNAMIC){
	        return;
	    }

	    // Compute point position relative to the body center
	    var r = Body_applyImpulse_r;
	    worldPoint.vsub(this.position,r);

	    // Compute produced central impulse velocity
	    var velo = Body_applyImpulse_velo;
	    velo.copy(impulse);
	    velo.mult(this.invMass,velo);

	    // Add linear impulse
	    this.velocity.vadd(velo, this.velocity);

	    // Compute produced rotational impulse velocity
	    var rotVelo = Body_applyImpulse_rotVelo;
	    r.cross(impulse,rotVelo);

	    /*
	    rotVelo.x *= this.invInertia.x;
	    rotVelo.y *= this.invInertia.y;
	    rotVelo.z *= this.invInertia.z;
	    */
	    this.invInertiaWorld.vmult(rotVelo,rotVelo);

	    // Add rotational Impulse
	    this.angularVelocity.vadd(rotVelo, this.angularVelocity);
	};

	/**
	 * Apply locally-defined impulse to a local point in the body.
	 * @method applyLocalImpulse
	 * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
	 * @param  {Vec3} localPoint A local point in the body to apply the force on.
	 */
	var Body_applyLocalImpulse_worldImpulse = new Vec3();
	var Body_applyLocalImpulse_worldPoint = new Vec3();
	Body.prototype.applyLocalImpulse = function(localImpulse, localPoint){
	    if(this.type !== Body.DYNAMIC){
	        return;
	    }

	    var worldImpulse = Body_applyLocalImpulse_worldImpulse;
	    var worldPoint = Body_applyLocalImpulse_worldPoint;

	    // Transform the force vector to world space
	    this.vectorToWorldFrame(localImpulse, worldImpulse);
	    this.pointToWorldFrame(localPoint, worldPoint);

	    this.applyImpulse(worldImpulse, worldPoint);
	};

	var Body_updateMassProperties_halfExtents = new Vec3();

	/**
	 * Should be called whenever you change the body shape or mass.
	 * @method updateMassProperties
	 */
	Body.prototype.updateMassProperties = function(){
	    var halfExtents = Body_updateMassProperties_halfExtents;

	    this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
	    var I = this.inertia;
	    var fixed = this.fixedRotation;

	    // Approximate with AABB box
	    this.computeAABB();
	    halfExtents.set(
	        (this.aabb.upperBound.x-this.aabb.lowerBound.x) / 2,
	        (this.aabb.upperBound.y-this.aabb.lowerBound.y) / 2,
	        (this.aabb.upperBound.z-this.aabb.lowerBound.z) / 2
	    );
	    Box.calculateInertia(halfExtents, this.mass, I);

	    this.invInertia.set(
	        I.x > 0 && !fixed ? 1.0 / I.x : 0,
	        I.y > 0 && !fixed ? 1.0 / I.y : 0,
	        I.z > 0 && !fixed ? 1.0 / I.z : 0
	    );
	    this.updateInertiaWorld(true);
	};

	/**
	 * Get world velocity of a point in the body.
	 * @method getVelocityAtWorldPoint
	 * @param  {Vec3} worldPoint
	 * @param  {Vec3} result
	 * @return {Vec3} The result vector.
	 */
	Body.prototype.getVelocityAtWorldPoint = function(worldPoint, result){
	    var r = new Vec3();
	    worldPoint.vsub(this.position, r);
	    this.angularVelocity.cross(r, result);
	    this.velocity.vadd(result, result);
	    return result;
	};

	},{"../collision/AABB":3,"../material/Material":25,"../math/Mat3":27,"../math/Quaternion":28,"../math/Vec3":30,"../shapes/Box":37,"../shapes/Shape":43,"../utils/EventTarget":49}],32:[function(_dereq_,module,exports){
	var Body = _dereq_('./Body');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var RaycastResult = _dereq_('../collision/RaycastResult');
	var Ray = _dereq_('../collision/Ray');
	var WheelInfo = _dereq_('../objects/WheelInfo');

	module.exports = RaycastVehicle;

	/**
	 * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
	 * @class RaycastVehicle
	 * @constructor
	 * @param {object} [options]
	 * @param {Body} [options.chassisBody] The car chassis body.
	 * @param {integer} [options.indexRightAxis] Axis to use for right. x=0, y=1, z=2
	 * @param {integer} [options.indexLeftAxis]
	 * @param {integer} [options.indexUpAxis]
	 */
	function RaycastVehicle(options){

	    /**
	     * @property {Body} chassisBody
	     */
	    this.chassisBody = options.chassisBody;

	    /**
	     * An array of WheelInfo objects.
	     * @property {array} wheelInfos
	     */
	    this.wheelInfos = [];

	    /**
	     * Will be set to true if the car is sliding.
	     * @property {boolean} sliding
	     */
	    this.sliding = false;

	    /**
	     * @property {World} world
	     */
	    this.world = null;

	    /**
	     * Index of the right axis, 0=x, 1=y, 2=z
	     * @property {integer} indexRightAxis
	     * @default 1
	     */
	    this.indexRightAxis = typeof(options.indexRightAxis) !== 'undefined' ? options.indexRightAxis : 1;

	    /**
	     * Index of the forward axis, 0=x, 1=y, 2=z
	     * @property {integer} indexForwardAxis
	     * @default 0
	     */
	    this.indexForwardAxis = typeof(options.indexForwardAxis) !== 'undefined' ? options.indexForwardAxis : 0;

	    /**
	     * Index of the up axis, 0=x, 1=y, 2=z
	     * @property {integer} indexUpAxis
	     * @default 2
	     */
	    this.indexUpAxis = typeof(options.indexUpAxis) !== 'undefined' ? options.indexUpAxis : 2;
	}

	var tmpVec1 = new Vec3();
	var tmpVec2 = new Vec3();
	var tmpVec3 = new Vec3();
	var tmpVec4 = new Vec3();
	var tmpVec5 = new Vec3();
	var tmpVec6 = new Vec3();
	var tmpRay = new Ray();

	/**
	 * Add a wheel. For information about the options, see WheelInfo.
	 * @method addWheel
	 * @param {object} [options]
	 */
	RaycastVehicle.prototype.addWheel = function(options){
	    options = options || {};

	    var info = new WheelInfo(options);
	    var index = this.wheelInfos.length;
	    this.wheelInfos.push(info);

	    return index;
	};

	/**
	 * Set the steering value of a wheel.
	 * @method setSteeringValue
	 * @param {number} value
	 * @param {integer} wheelIndex
	 */
	RaycastVehicle.prototype.setSteeringValue = function(value, wheelIndex){
	    var wheel = this.wheelInfos[wheelIndex];
	    wheel.steering = value;
	};

	var torque = new Vec3();

	/**
	 * Set the wheel force to apply on one of the wheels each time step
	 * @method applyEngineForce
	 * @param  {number} value
	 * @param  {integer} wheelIndex
	 */
	RaycastVehicle.prototype.applyEngineForce = function(value, wheelIndex){
	    this.wheelInfos[wheelIndex].engineForce = value;
	};

	/**
	 * Set the braking force of a wheel
	 * @method setBrake
	 * @param {number} brake
	 * @param {integer} wheelIndex
	 */
	RaycastVehicle.prototype.setBrake = function(brake, wheelIndex){
	    this.wheelInfos[wheelIndex].brake = brake;
	};

	/**
	 * Add the vehicle including its constraints to the world.
	 * @method addToWorld
	 * @param {World} world
	 */
	RaycastVehicle.prototype.addToWorld = function(world){
	    var constraints = this.constraints;
	    world.add(this.chassisBody);
	    var that = this;
	    this.preStepCallback = function(){
	        that.updateVehicle(world.dt);
	    };
	    world.addEventListener('preStep', this.preStepCallback);
	    this.world = world;
	};

	/**
	 * Get one of the wheel axles, world-oriented.
	 * @private
	 * @method getVehicleAxisWorld
	 * @param  {integer} axisIndex
	 * @param  {Vec3} result
	 */
	RaycastVehicle.prototype.getVehicleAxisWorld = function(axisIndex, result){
	    result.set(
	        axisIndex === 0 ? 1 : 0,
	        axisIndex === 1 ? 1 : 0,
	        axisIndex === 2 ? 1 : 0
	    );
	    this.chassisBody.vectorToWorldFrame(result, result);
	};

	RaycastVehicle.prototype.updateVehicle = function(timeStep){
	    var wheelInfos = this.wheelInfos;
	    var numWheels = wheelInfos.length;
	    var chassisBody = this.chassisBody;

	    for (var i = 0; i < numWheels; i++) {
	        this.updateWheelTransform(i);
	    }

	    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();

	    var forwardWorld = new Vec3();
	    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

	    if (forwardWorld.dot(chassisBody.velocity) < 0){
	        this.currentVehicleSpeedKmHour *= -1;
	    }

	    // simulate suspension
	    for (var i = 0; i < numWheels; i++) {
	        this.castRay(wheelInfos[i]);
	    }

	    this.updateSuspension(timeStep);

	    var impulse = new Vec3();
	    var relpos = new Vec3();
	    for (var i = 0; i < numWheels; i++) {
	        //apply suspension force
	        var wheel = wheelInfos[i];
	        var suspensionForce = wheel.suspensionForce;
	        if (suspensionForce > wheel.maxSuspensionForce) {
	            suspensionForce = wheel.maxSuspensionForce;
	        }
	        wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);

	        wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
	        chassisBody.applyImpulse(impulse, wheel.raycastResult.hitPointWorld/*relpos*/);
	    }

	    this.updateFriction(timeStep);

	    var hitNormalWorldScaledWithProj = new Vec3();
	    var fwd  = new Vec3();
	    var vel = new Vec3();
	    for (i = 0; i < numWheels; i++) {
	        var wheel = wheelInfos[i];
	        //var relpos = new Vec3();
	        //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);
	        chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);

	        // Hack to get the rotation in the correct direction
	        var m = 1;
	        switch(this.indexUpAxis){
	        case 1:
	            m = -1;
	            break;
	        }

	        if (wheel.isInContact) {

	            this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
	            var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
	            wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);

	            fwd.vsub(hitNormalWorldScaledWithProj, fwd);

	            var proj2 = fwd.dot(vel);
	            wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
	        }

	        if((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed){
	            // Apply custom rotation when accelerating and sliding
	            wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
	        }

	        // Lock wheels
	        if(Math.abs(wheel.brake) > Math.abs(wheel.engineForce)){
	            wheel.deltaRotation = 0;
	        }

	        wheel.rotation += wheel.deltaRotation; // Use the old value
	        wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
	    }
	};

	RaycastVehicle.prototype.updateSuspension = function(deltaTime) {
	    var chassisBody = this.chassisBody;
	    var chassisMass = chassisBody.mass;
	    var wheelInfos = this.wheelInfos;
	    var numWheels = wheelInfos.length;

	    for (var w_it = 0; w_it < numWheels; w_it++){
	        var wheel = wheelInfos[w_it];

	        if (wheel.isInContact){
	            var force;

	            // Spring
	            var susp_length = wheel.suspensionRestLength;
	            var current_length = wheel.suspensionLength;
	            var length_diff = (susp_length - current_length);

	            force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;

	            // Damper
	            var projected_rel_vel = wheel.suspensionRelativeVelocity;
	            var susp_damping;
	            if (projected_rel_vel < 0) {
	                susp_damping = wheel.dampingCompression;
	            } else {
	                susp_damping = wheel.dampingRelaxation;
	            }
	            force -= susp_damping * projected_rel_vel;

	            wheel.suspensionForce = force * chassisMass;
	            if (wheel.suspensionForce < 0) {
	                wheel.suspensionForce = 0;
	            }
	        } else {
	            wheel.suspensionForce = 0;
	        }
	    }
	};

	/**
	 * Remove the vehicle including its constraints from the world.
	 * @method removeFromWorld
	 * @param {World} world
	 */
	RaycastVehicle.prototype.removeFromWorld = function(world){
	    var constraints = this.constraints;
	    world.remove(this.chassisBody);
	    world.removeEventListener('preStep', this.preStepCallback);
	    this.world = null;
	};

	var castRay_rayvector = new Vec3();
	var castRay_target = new Vec3();
	RaycastVehicle.prototype.castRay = function(wheel) {
	    var rayvector = castRay_rayvector;
	    var target = castRay_target;

	    this.updateWheelTransformWorld(wheel);
	    var chassisBody = this.chassisBody;

	    var depth = -1;

	    var raylen = wheel.suspensionRestLength + wheel.radius;

	    wheel.directionWorld.scale(raylen, rayvector);
	    var source = wheel.chassisConnectionPointWorld;
	    source.vadd(rayvector, target);
	    var raycastResult = wheel.raycastResult;

	    var param = 0;

	    raycastResult.reset();
	    // Turn off ray collision with the chassis temporarily
	    var oldState = chassisBody.collisionResponse;
	    chassisBody.collisionResponse = false;

	    // Cast ray against world
	    this.world.rayTest(source, target, raycastResult);
	    chassisBody.collisionResponse = oldState;

	    var object = raycastResult.body;

	    wheel.raycastResult.groundObject = 0;

	    if (object) {
	        depth = raycastResult.distance;
	        wheel.raycastResult.hitNormalWorld  = raycastResult.hitNormalWorld;
	        wheel.isInContact = true;

	        var hitDistance = raycastResult.distance;
	        wheel.suspensionLength = hitDistance - wheel.radius;

	        // clamp on max suspension travel
	        var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
	        var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;
	        if (wheel.suspensionLength < minSuspensionLength) {
	            wheel.suspensionLength = minSuspensionLength;
	        }
	        if (wheel.suspensionLength > maxSuspensionLength) {
	            wheel.suspensionLength = maxSuspensionLength;
	            wheel.raycastResult.reset();
	        }

	        var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);

	        var chassis_velocity_at_contactPoint = new Vec3();
	        chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);

	        var projVel = wheel.raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );

	        if (denominator >= -0.1) {
	            wheel.suspensionRelativeVelocity = 0;
	            wheel.clippedInvContactDotSuspension = 1 / 0.1;
	        } else {
	            var inv = -1 / denominator;
	            wheel.suspensionRelativeVelocity = projVel * inv;
	            wheel.clippedInvContactDotSuspension = inv;
	        }

	    } else {

	        //put wheel info as in rest position
	        wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
	        wheel.suspensionRelativeVelocity = 0.0;
	        wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
	        wheel.clippedInvContactDotSuspension = 1.0;
	    }

	    return depth;
	};

	RaycastVehicle.prototype.updateWheelTransformWorld = function(wheel){
	    wheel.isInContact = false;
	    var chassisBody = this.chassisBody;
	    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
	    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
	    chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
	};


	/**
	 * Update one of the wheel transform.
	 * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
	 * @method updateWheelTransform
	 * @param {integer} wheelIndex The wheel index to update.
	 */
	RaycastVehicle.prototype.updateWheelTransform = function(wheelIndex){
	    var up = tmpVec4;
	    var right = tmpVec5;
	    var fwd = tmpVec6;

	    var wheel = this.wheelInfos[wheelIndex];
	    this.updateWheelTransformWorld(wheel);

	    wheel.directionLocal.scale(-1, up);
	    right.copy(wheel.axleLocal);
	    up.cross(right, fwd);
	    fwd.normalize();
	    right.normalize();

	    // Rotate around steering over the wheelAxle
	    var steering = wheel.steering;
	    var steeringOrn = new Quaternion();
	    steeringOrn.setFromAxisAngle(up, steering);

	    var rotatingOrn = new Quaternion();
	    rotatingOrn.setFromAxisAngle(right, wheel.rotation);

	    // World rotation of the wheel
	    var q = wheel.worldTransform.quaternion;
	    this.chassisBody.quaternion.mult(steeringOrn, q);
	    q.mult(rotatingOrn, q);

	    q.normalize();

	    // world position of the wheel
	    var p = wheel.worldTransform.position;
	    p.copy(wheel.directionWorld);
	    p.scale(wheel.suspensionLength, p);
	    p.vadd(wheel.chassisConnectionPointWorld, p);
	};

	var directions = [
	    new Vec3(1, 0, 0),
	    new Vec3(0, 1, 0),
	    new Vec3(0, 0, 1)
	];

	/**
	 * Get the world transform of one of the wheels
	 * @method getWheelTransformWorld
	 * @param  {integer} wheelIndex
	 * @return {Transform}
	 */
	RaycastVehicle.prototype.getWheelTransformWorld = function(wheelIndex) {
	    return this.wheelInfos[wheelIndex].worldTransform;
	};


	var updateFriction_surfNormalWS_scaled_proj = new Vec3();
	var updateFriction_axle = [];
	var updateFriction_forwardWS = [];
	var sideFrictionStiffness2 = 1;
	RaycastVehicle.prototype.updateFriction = function(timeStep) {
	    var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;

	    //calculate the impulse, so that the wheels don't move sidewards
	    var wheelInfos = this.wheelInfos;
	    var numWheels = wheelInfos.length;
	    var chassisBody = this.chassisBody;
	    var forwardWS = updateFriction_forwardWS;
	    var axle = updateFriction_axle;

	    var numWheelsOnGround = 0;

	    for (var i = 0; i < numWheels; i++) {
	        var wheel = wheelInfos[i];

	        var groundObject = wheel.raycastResult.body;
	        if (groundObject){
	            numWheelsOnGround++;
	        }

	        wheel.sideImpulse = 0;
	        wheel.forwardImpulse = 0;
	        if(!forwardWS[i]){
	            forwardWS[i] = new Vec3();
	        }
	        if(!axle[i]){
	            axle[i] = new Vec3();
	        }
	    }

	    for (var i = 0; i < numWheels; i++){
	        var wheel = wheelInfos[i];

	        var groundObject = wheel.raycastResult.body;

	        if (groundObject) {
	            var axlei = axle[i];
	            var wheelTrans = this.getWheelTransformWorld(i);

	            // Get world axle
	            wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);

	            var surfNormalWS = wheel.raycastResult.hitNormalWorld;
	            var proj = axlei.dot(surfNormalWS);
	            surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
	            axlei.vsub(surfNormalWS_scaled_proj, axlei);
	            axlei.normalize();

	            surfNormalWS.cross(axlei, forwardWS[i]);
	            forwardWS[i].normalize();

	            wheel.sideImpulse = resolveSingleBilateral(
	                chassisBody,
	                wheel.raycastResult.hitPointWorld,
	                groundObject,
	                wheel.raycastResult.hitPointWorld,
	                axlei
	            );

	            wheel.sideImpulse *= sideFrictionStiffness2;
	        }
	    }

	    var sideFactor = 1;
	    var fwdFactor = 0.5;

	    this.sliding = false;
	    for (var i = 0; i < numWheels; i++) {
	        var wheel = wheelInfos[i];
	        var groundObject = wheel.raycastResult.body;

	        var rollingFriction = 0;

	        wheel.slipInfo = 1;
	        if (groundObject) {
	            var defaultRollingFrictionImpulse = 0;
	            var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;

	            // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
	            // rollingFriction = calcRollingFriction(contactPt);
	            rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);

	            rollingFriction += wheel.engineForce * timeStep;

	            // rollingFriction = 0;
	            var factor = maxImpulse / rollingFriction;
	            wheel.slipInfo *= factor;
	        }

	        //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)

	        wheel.forwardImpulse = 0;
	        wheel.skidInfo = 1;

	        if (groundObject) {
	            wheel.skidInfo = 1;

	            var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
	            var maximpSide = maximp;

	            var maximpSquared = maximp * maximpSide;

	            wheel.forwardImpulse = rollingFriction;//wheelInfo.engineForce* timeStep;

	            var x = wheel.forwardImpulse * fwdFactor;
	            var y = wheel.sideImpulse * sideFactor;

	            var impulseSquared = x * x + y * y;

	            wheel.sliding = false;
	            if (impulseSquared > maximpSquared) {
	                this.sliding = true;
	                wheel.sliding = true;

	                var factor = maximp / Math.sqrt(impulseSquared);

	                wheel.skidInfo *= factor;
	            }
	        }
	    }

	    if (this.sliding) {
	        for (var i = 0; i < numWheels; i++) {
	            var wheel = wheelInfos[i];
	            if (wheel.sideImpulse !== 0) {
	                if (wheel.skidInfo < 1){
	                    wheel.forwardImpulse *= wheel.skidInfo;
	                    wheel.sideImpulse *= wheel.skidInfo;
	                }
	            }
	        }
	    }

	    // apply the impulses
	    for (var i = 0; i < numWheels; i++) {
	        var wheel = wheelInfos[i];

	        var rel_pos = new Vec3();
	        //wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos);
	        // cannons applyimpulse is using world coord for the position
	        rel_pos.copy(wheel.raycastResult.hitPointWorld);

	        if (wheel.forwardImpulse !== 0) {
	            var impulse = new Vec3();
	            forwardWS[i].scale(wheel.forwardImpulse, impulse);
	            chassisBody.applyImpulse(impulse, rel_pos);
	        }

	        if (wheel.sideImpulse !== 0){
	            var groundObject = wheel.raycastResult.body;

	            var rel_pos2 = new Vec3();
	            //wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2);
	            rel_pos2.copy(wheel.raycastResult.hitPointWorld);
	            var sideImp = new Vec3();
	            axle[i].scale(wheel.sideImpulse, sideImp);

	            // Scale the relative position in the up direction with rollInfluence.
	            // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).
	            chassisBody.pointToLocalFrame(rel_pos, rel_pos);
	            rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
	            chassisBody.pointToWorldFrame(rel_pos, rel_pos);
	            chassisBody.applyImpulse(sideImp, rel_pos);

	            //apply friction impulse on the ground
	            sideImp.scale(-1, sideImp);
	            groundObject.applyImpulse(sideImp, rel_pos2);
	        }
	    }
	};

	var calcRollingFriction_vel1 = new Vec3();
	var calcRollingFriction_vel2 = new Vec3();
	var calcRollingFriction_vel = new Vec3();

	function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
	    var j1 = 0;
	    var contactPosWorld = frictionPosWorld;

	    // var rel_pos1 = new Vec3();
	    // var rel_pos2 = new Vec3();
	    var vel1 = calcRollingFriction_vel1;
	    var vel2 = calcRollingFriction_vel2;
	    var vel = calcRollingFriction_vel;
	    // contactPosWorld.vsub(body0.position, rel_pos1);
	    // contactPosWorld.vsub(body1.position, rel_pos2);

	    body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
	    body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
	    vel1.vsub(vel2, vel);

	    var vrel = frictionDirectionWorld.dot(vel);

	    var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
	    var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
	    var relaxation = 1;
	    var jacDiagABInv = relaxation / (denom0 + denom1);

	    // calculate j that moves us to zero relative velocity
	    j1 = -vrel * jacDiagABInv;

	    if (maxImpulse < j1) {
	        j1 = maxImpulse;
	    }
	    if (j1 < -maxImpulse) {
	        j1 = -maxImpulse;
	    }

	    return j1;
	}

	var computeImpulseDenominator_r0 = new Vec3();
	var computeImpulseDenominator_c0 = new Vec3();
	var computeImpulseDenominator_vec = new Vec3();
	var computeImpulseDenominator_m = new Vec3();
	function computeImpulseDenominator(body, pos, normal) {
	    var r0 = computeImpulseDenominator_r0;
	    var c0 = computeImpulseDenominator_c0;
	    var vec = computeImpulseDenominator_vec;
	    var m = computeImpulseDenominator_m;

	    pos.vsub(body.position, r0);
	    r0.cross(normal, c0);
	    body.invInertiaWorld.vmult(c0, m);
	    m.cross(r0, vec);

	    return body.invMass + normal.dot(vec);
	}


	var resolveSingleBilateral_vel1 = new Vec3();
	var resolveSingleBilateral_vel2 = new Vec3();
	var resolveSingleBilateral_vel = new Vec3();

	//bilateral constraint between two dynamic objects
	function resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse){
	    var normalLenSqr = normal.norm2();
	    if (normalLenSqr > 1.1){
	        return 0; // no impulse
	    }
	    // var rel_pos1 = new Vec3();
	    // var rel_pos2 = new Vec3();
	    // pos1.vsub(body1.position, rel_pos1);
	    // pos2.vsub(body2.position, rel_pos2);

	    var vel1 = resolveSingleBilateral_vel1;
	    var vel2 = resolveSingleBilateral_vel2;
	    var vel = resolveSingleBilateral_vel;
	    body1.getVelocityAtWorldPoint(pos1, vel1);
	    body2.getVelocityAtWorldPoint(pos2, vel2);

	    vel1.vsub(vel2, vel);

	    var rel_vel = normal.dot(vel);

	    var contactDamping = 0.2;
	    var massTerm = 1 / (body1.invMass + body2.invMass);
	    var impulse = - contactDamping * rel_vel * massTerm;

	    return impulse;
	}
	},{"../collision/Ray":9,"../collision/RaycastResult":10,"../math/Quaternion":28,"../math/Vec3":30,"../objects/WheelInfo":36,"./Body":31}],33:[function(_dereq_,module,exports){
	var Body = _dereq_('./Body');
	var Sphere = _dereq_('../shapes/Sphere');
	var Box = _dereq_('../shapes/Box');
	var Vec3 = _dereq_('../math/Vec3');
	var HingeConstraint = _dereq_('../constraints/HingeConstraint');

	module.exports = RigidVehicle;

	/**
	 * Simple vehicle helper class with spherical rigid body wheels.
	 * @class RigidVehicle
	 * @constructor
	 * @param {Body} [options.chassisBody]
	 */
	function RigidVehicle(options){
	    this.wheelBodies = [];

	    /**
	     * @property coordinateSystem
	     * @type {Vec3}
	     */
	    this.coordinateSystem = typeof(options.coordinateSystem)==='undefined' ? new Vec3(1, 2, 3) : options.coordinateSystem.clone();

	    /**
	     * @property {Body} chassisBody
	     */
	    this.chassisBody = options.chassisBody;

	    if(!this.chassisBody){
	        // No chassis body given. Create it!
	        var chassisShape = new Box(new Vec3(5, 2, 0.5));
	        this.chassisBody = new Body(1, chassisShape);
	    }

	    /**
	     * @property constraints
	     * @type {Array}
	     */
	    this.constraints = [];

	    this.wheelAxes = [];
	    this.wheelForces = [];
	}

	/**
	 * Add a wheel
	 * @method addWheel
	 * @param {object} options
	 * @param {boolean} [options.isFrontWheel]
	 * @param {Vec3} [options.position] Position of the wheel, locally in the chassis body.
	 * @param {Vec3} [options.direction] Slide direction of the wheel along the suspension.
	 * @param {Vec3} [options.axis] Axis of rotation of the wheel, locally defined in the chassis.
	 * @param {Body} [options.body] The wheel body.
	 */
	RigidVehicle.prototype.addWheel = function(options){
	    options = options || {};
	    var wheelBody = options.body;
	    if(!wheelBody){
	        wheelBody =  new Body(1, new Sphere(1.2));
	    }
	    this.wheelBodies.push(wheelBody);
	    this.wheelForces.push(0);

	    // Position constrain wheels
	    var zero = new Vec3();
	    var position = typeof(options.position) !== 'undefined' ? options.position.clone() : new Vec3();

	    // Set position locally to the chassis
	    var worldPosition = new Vec3();
	    this.chassisBody.pointToWorldFrame(position, worldPosition);
	    wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z);

	    // Constrain wheel
	    var axis = typeof(options.axis) !== 'undefined' ? options.axis.clone() : new Vec3(0, 1, 0);
	    this.wheelAxes.push(axis);

	    var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
	        pivotA: position,
	        axisA: axis,
	        pivotB: Vec3.ZERO,
	        axisB: axis,
	        collideConnected: false
	    });
	    this.constraints.push(hingeConstraint);

	    return this.wheelBodies.length - 1;
	};

	/**
	 * Set the steering value of a wheel.
	 * @method setSteeringValue
	 * @param {number} value
	 * @param {integer} wheelIndex
	 * @todo check coordinateSystem
	 */
	RigidVehicle.prototype.setSteeringValue = function(value, wheelIndex){
	    // Set angle of the hinge axis
	    var axis = this.wheelAxes[wheelIndex];

	    var c = Math.cos(value),
	        s = Math.sin(value),
	        x = axis.x,
	        y = axis.y;
	    this.constraints[wheelIndex].axisA.set(
	        c*x -s*y,
	        s*x +c*y,
	        0
	    );
	};

	/**
	 * Set the target rotational speed of the hinge constraint.
	 * @method setMotorSpeed
	 * @param {number} value
	 * @param {integer} wheelIndex
	 */
	RigidVehicle.prototype.setMotorSpeed = function(value, wheelIndex){
	    var hingeConstraint = this.constraints[wheelIndex];
	    hingeConstraint.enableMotor();
	    hingeConstraint.motorTargetVelocity = value;
	};

	/**
	 * Set the target rotational speed of the hinge constraint.
	 * @method disableMotor
	 * @param {number} value
	 * @param {integer} wheelIndex
	 */
	RigidVehicle.prototype.disableMotor = function(wheelIndex){
	    var hingeConstraint = this.constraints[wheelIndex];
	    hingeConstraint.disableMotor();
	};

	var torque = new Vec3();

	/**
	 * Set the wheel force to apply on one of the wheels each time step
	 * @method setWheelForce
	 * @param  {number} value
	 * @param  {integer} wheelIndex
	 */
	RigidVehicle.prototype.setWheelForce = function(value, wheelIndex){
	    this.wheelForces[wheelIndex] = value;
	};

	/**
	 * Apply a torque on one of the wheels.
	 * @method applyWheelForce
	 * @param  {number} value
	 * @param  {integer} wheelIndex
	 */
	RigidVehicle.prototype.applyWheelForce = function(value, wheelIndex){
	    var axis = this.wheelAxes[wheelIndex];
	    var wheelBody = this.wheelBodies[wheelIndex];
	    var bodyTorque = wheelBody.torque;

	    axis.scale(value, torque);
	    wheelBody.vectorToWorldFrame(torque, torque);
	    bodyTorque.vadd(torque, bodyTorque);
	};

	/**
	 * Add the vehicle including its constraints to the world.
	 * @method addToWorld
	 * @param {World} world
	 */
	RigidVehicle.prototype.addToWorld = function(world){
	    var constraints = this.constraints;
	    var bodies = this.wheelBodies.concat([this.chassisBody]);

	    for (var i = 0; i < bodies.length; i++) {
	        world.add(bodies[i]);
	    }

	    for (var i = 0; i < constraints.length; i++) {
	        world.addConstraint(constraints[i]);
	    }

	    world.addEventListener('preStep', this._update.bind(this));
	};

	RigidVehicle.prototype._update = function(){
	    var wheelForces = this.wheelForces;
	    for (var i = 0; i < wheelForces.length; i++) {
	        this.applyWheelForce(wheelForces[i], i);
	    }
	};

	/**
	 * Remove the vehicle including its constraints from the world.
	 * @method removeFromWorld
	 * @param {World} world
	 */
	RigidVehicle.prototype.removeFromWorld = function(world){
	    var constraints = this.constraints;
	    var bodies = this.wheelBodies.concat([this.chassisBody]);

	    for (var i = 0; i < bodies.length; i++) {
	        world.remove(bodies[i]);
	    }

	    for (var i = 0; i < constraints.length; i++) {
	        world.removeConstraint(constraints[i]);
	    }
	};

	var worldAxis = new Vec3();

	/**
	 * Get current rotational velocity of a wheel
	 * @method getWheelSpeed
	 * @param {integer} wheelIndex
	 */
	RigidVehicle.prototype.getWheelSpeed = function(wheelIndex){
	    var axis = this.wheelAxes[wheelIndex];
	    var wheelBody = this.wheelBodies[wheelIndex];
	    var w = wheelBody.angularVelocity;
	    this.chassisBody.vectorToWorldFrame(axis, worldAxis);
	    return w.dot(worldAxis);
	};

	},{"../constraints/HingeConstraint":15,"../math/Vec3":30,"../shapes/Box":37,"../shapes/Sphere":44,"./Body":31}],34:[function(_dereq_,module,exports){
	module.exports = SPHSystem;

	var Shape = _dereq_('../shapes/Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Particle = _dereq_('../shapes/Particle');
	var Body = _dereq_('../objects/Body');
	var Material = _dereq_('../material/Material');

	/**
	 * Smoothed-particle hydrodynamics system
	 * @class SPHSystem
	 * @constructor
	 */
	function SPHSystem(){
	    this.particles = [];
		
	    /**
	     * Density of the system (kg/m3).
	     * @property {number} density
	     */
	    this.density = 1;
		
	    /**
	     * Distance below which two particles are considered to be neighbors.
	     * It should be adjusted so there are about 15-20 neighbor particles within this radius.
	     * @property {number} smoothingRadius
	     */
	    this.smoothingRadius = 1;
	    this.speedOfSound = 1;
		
	    /**
	     * Viscosity of the system.
	     * @property {number} viscosity
	     */
	    this.viscosity = 0.01;
	    this.eps = 0.000001;

	    // Stuff Computed per particle
	    this.pressures = [];
	    this.densities = [];
	    this.neighbors = [];
	}

	/**
	 * Add a particle to the system.
	 * @method add
	 * @param {Body} particle
	 */
	SPHSystem.prototype.add = function(particle){
	    this.particles.push(particle);
	    if(this.neighbors.length < this.particles.length){
	        this.neighbors.push([]);
	    }
	};

	/**
	 * Remove a particle from the system.
	 * @method remove
	 * @param {Body} particle
	 */
	SPHSystem.prototype.remove = function(particle){
	    var idx = this.particles.indexOf(particle);
	    if(idx !== -1){
	        this.particles.splice(idx,1);
	        if(this.neighbors.length > this.particles.length){
	            this.neighbors.pop();
	        }
	    }
	};

	/**
	 * Get neighbors within smoothing volume, save in the array neighbors
	 * @method getNeighbors
	 * @param {Body} particle
	 * @param {Array} neighbors
	 */
	var SPHSystem_getNeighbors_dist = new Vec3();
	SPHSystem.prototype.getNeighbors = function(particle,neighbors){
	    var N = this.particles.length,
	        id = particle.id,
	        R2 = this.smoothingRadius * this.smoothingRadius,
	        dist = SPHSystem_getNeighbors_dist;
	    for(var i=0; i!==N; i++){
	        var p = this.particles[i];
	        p.position.vsub(particle.position,dist);
	        if(id!==p.id && dist.norm2() < R2){
	            neighbors.push(p);
	        }
	    }
	};

	// Temp vectors for calculation
	var SPHSystem_update_dist = new Vec3(),
	    SPHSystem_update_a_pressure = new Vec3(),
	    SPHSystem_update_a_visc = new Vec3(),
	    SPHSystem_update_gradW = new Vec3(),
	    SPHSystem_update_r_vec = new Vec3(),
	    SPHSystem_update_u = new Vec3(); // Relative velocity
	SPHSystem.prototype.update = function(){
	    var N = this.particles.length,
	        dist = SPHSystem_update_dist,
	        cs = this.speedOfSound,
	        eps = this.eps;

	    for(var i=0; i!==N; i++){
	        var p = this.particles[i]; // Current particle
	        var neighbors = this.neighbors[i];

	        // Get neighbors
	        neighbors.length = 0;
	        this.getNeighbors(p,neighbors);
	        neighbors.push(this.particles[i]); // Add current too
	        var numNeighbors = neighbors.length;

	        // Accumulate density for the particle
	        var sum = 0.0;
	        for(var j=0; j!==numNeighbors; j++){

	            //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
	            p.position.vsub(neighbors[j].position, dist);
	            var len = dist.norm();

	            var weight = this.w(len);
	            sum += neighbors[j].mass * weight;
	        }

	        // Save
	        this.densities[i] = sum;
	        this.pressures[i] = cs * cs * (this.densities[i] - this.density);
	    }

	    // Add forces

	    // Sum to these accelerations
	    var a_pressure= SPHSystem_update_a_pressure;
	    var a_visc =    SPHSystem_update_a_visc;
	    var gradW =     SPHSystem_update_gradW;
	    var r_vec =     SPHSystem_update_r_vec;
	    var u =         SPHSystem_update_u;

	    for(var i=0; i!==N; i++){

	        var particle = this.particles[i];

	        a_pressure.set(0,0,0);
	        a_visc.set(0,0,0);

	        // Init vars
	        var Pij;
	        var nabla;
	        var Vij;

	        // Sum up for all other neighbors
	        var neighbors = this.neighbors[i];
	        var numNeighbors = neighbors.length;

	        //printf("Neighbors: ");
	        for(var j=0; j!==numNeighbors; j++){

	            var neighbor = neighbors[j];
	            //printf("%d ",nj);

	            // Get r once for all..
	            particle.position.vsub(neighbor.position,r_vec);
	            var r = r_vec.norm();

	            // Pressure contribution
	            Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i]*this.densities[i] + eps) + this.pressures[j] / (this.densities[j]*this.densities[j] + eps));
	            this.gradw(r_vec, gradW);
	            // Add to pressure acceleration
	            gradW.mult(Pij , gradW);
	            a_pressure.vadd(gradW, a_pressure);

	            // Viscosity contribution
	            neighbor.velocity.vsub(particle.velocity, u);
	            u.mult( 1.0 / (0.0001+this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass , u );
	            nabla = this.nablaw(r);
	            u.mult(nabla,u);
	            // Add to viscosity acceleration
	            a_visc.vadd( u, a_visc );
	        }

	        // Calculate force
	        a_visc.mult(particle.mass, a_visc);
	        a_pressure.mult(particle.mass, a_pressure);

	        // Add force to particles
	        particle.force.vadd(a_visc, particle.force);
	        particle.force.vadd(a_pressure, particle.force);
	    }
	};

	// Calculate the weight using the W(r) weightfunction
	SPHSystem.prototype.w = function(r){
	    // 315
	    var h = this.smoothingRadius;
	    return 315.0/(64.0*Math.PI*Math.pow(h,9)) * Math.pow(h*h-r*r,3);
	};

	// calculate gradient of the weight function
	SPHSystem.prototype.gradw = function(rVec,resultVec){
	    var r = rVec.norm(),
	        h = this.smoothingRadius;
	    rVec.mult(945.0/(32.0*Math.PI*Math.pow(h,9)) * Math.pow((h*h-r*r),2) , resultVec);
	};

	// Calculate nabla(W)
	SPHSystem.prototype.nablaw = function(r){
	    var h = this.smoothingRadius;
	    var nabla = 945.0/(32.0*Math.PI*Math.pow(h,9)) * (h*h-r*r)*(7*r*r - 3*h*h);
	    return nabla;
	};

	},{"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Particle":41,"../shapes/Shape":43}],35:[function(_dereq_,module,exports){
	var Vec3 = _dereq_('../math/Vec3');

	module.exports = Spring;

	/**
	 * A spring, connecting two bodies.
	 *
	 * @class Spring
	 * @constructor
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Object} [options]
	 * @param {number} [options.restLength]   A number > 0. Default: 1
	 * @param {number} [options.stiffness]    A number >= 0. Default: 100
	 * @param {number} [options.damping]      A number >= 0. Default: 1
	 * @param {Vec3}  [options.worldAnchorA] Where to hook the spring to body A, in world coordinates.
	 * @param {Vec3}  [options.worldAnchorB]
	 * @param {Vec3}  [options.localAnchorA] Where to hook the spring to body A, in local body coordinates.
	 * @param {Vec3}  [options.localAnchorB]
	 */
	function Spring(bodyA,bodyB,options){
	    options = options || {};

	    /**
	     * Rest length of the spring.
	     * @property restLength
	     * @type {number}
	     */
	    this.restLength = typeof(options.restLength) === "number" ? options.restLength : 1;

	    /**
	     * Stiffness of the spring.
	     * @property stiffness
	     * @type {number}
	     */
	    this.stiffness = options.stiffness || 100;

	    /**
	     * Damping of the spring.
	     * @property damping
	     * @type {number}
	     */
	    this.damping = options.damping || 1;

	    /**
	     * First connected body.
	     * @property bodyA
	     * @type {Body}
	     */
	    this.bodyA = bodyA;

	    /**
	     * Second connected body.
	     * @property bodyB
	     * @type {Body}
	     */
	    this.bodyB = bodyB;

	    /**
	     * Anchor for bodyA in local bodyA coordinates.
	     * @property localAnchorA
	     * @type {Vec3}
	     */
	    this.localAnchorA = new Vec3();

	    /**
	     * Anchor for bodyB in local bodyB coordinates.
	     * @property localAnchorB
	     * @type {Vec3}
	     */
	    this.localAnchorB = new Vec3();

	    if(options.localAnchorA){
	        this.localAnchorA.copy(options.localAnchorA);
	    }
	    if(options.localAnchorB){
	        this.localAnchorB.copy(options.localAnchorB);
	    }
	    if(options.worldAnchorA){
	        this.setWorldAnchorA(options.worldAnchorA);
	    }
	    if(options.worldAnchorB){
	        this.setWorldAnchorB(options.worldAnchorB);
	    }
	}

	/**
	 * Set the anchor point on body A, using world coordinates.
	 * @method setWorldAnchorA
	 * @param {Vec3} worldAnchorA
	 */
	Spring.prototype.setWorldAnchorA = function(worldAnchorA){
	    this.bodyA.pointToLocalFrame(worldAnchorA,this.localAnchorA);
	};

	/**
	 * Set the anchor point on body B, using world coordinates.
	 * @method setWorldAnchorB
	 * @param {Vec3} worldAnchorB
	 */
	Spring.prototype.setWorldAnchorB = function(worldAnchorB){
	    this.bodyB.pointToLocalFrame(worldAnchorB,this.localAnchorB);
	};

	/**
	 * Get the anchor point on body A, in world coordinates.
	 * @method getWorldAnchorA
	 * @param {Vec3} result The vector to store the result in.
	 */
	Spring.prototype.getWorldAnchorA = function(result){
	    this.bodyA.pointToWorldFrame(this.localAnchorA,result);
	};

	/**
	 * Get the anchor point on body B, in world coordinates.
	 * @method getWorldAnchorB
	 * @param {Vec3} result The vector to store the result in.
	 */
	Spring.prototype.getWorldAnchorB = function(result){
	    this.bodyB.pointToWorldFrame(this.localAnchorB,result);
	};

	var applyForce_r =              new Vec3(),
	    applyForce_r_unit =         new Vec3(),
	    applyForce_u =              new Vec3(),
	    applyForce_f =              new Vec3(),
	    applyForce_worldAnchorA =   new Vec3(),
	    applyForce_worldAnchorB =   new Vec3(),
	    applyForce_ri =             new Vec3(),
	    applyForce_rj =             new Vec3(),
	    applyForce_ri_x_f =         new Vec3(),
	    applyForce_rj_x_f =         new Vec3(),
	    applyForce_tmp =            new Vec3();

	/**
	 * Apply the spring force to the connected bodies.
	 * @method applyForce
	 */
	Spring.prototype.applyForce = function(){
	    var k = this.stiffness,
	        d = this.damping,
	        l = this.restLength,
	        bodyA = this.bodyA,
	        bodyB = this.bodyB,
	        r = applyForce_r,
	        r_unit = applyForce_r_unit,
	        u = applyForce_u,
	        f = applyForce_f,
	        tmp = applyForce_tmp;

	    var worldAnchorA = applyForce_worldAnchorA,
	        worldAnchorB = applyForce_worldAnchorB,
	        ri = applyForce_ri,
	        rj = applyForce_rj,
	        ri_x_f = applyForce_ri_x_f,
	        rj_x_f = applyForce_rj_x_f;

	    // Get world anchors
	    this.getWorldAnchorA(worldAnchorA);
	    this.getWorldAnchorB(worldAnchorB);

	    // Get offset points
	    worldAnchorA.vsub(bodyA.position,ri);
	    worldAnchorB.vsub(bodyB.position,rj);

	    // Compute distance vector between world anchor points
	    worldAnchorB.vsub(worldAnchorA,r);
	    var rlen = r.norm();
	    r_unit.copy(r);
	    r_unit.normalize();

	    // Compute relative velocity of the anchor points, u
	    bodyB.velocity.vsub(bodyA.velocity,u);
	    // Add rotational velocity

	    bodyB.angularVelocity.cross(rj,tmp);
	    u.vadd(tmp,u);
	    bodyA.angularVelocity.cross(ri,tmp);
	    u.vsub(tmp,u);

	    // F = - k * ( x - L ) - D * ( u )
	    r_unit.mult(-k*(rlen-l) - d*u.dot(r_unit), f);

	    // Add forces to bodies
	    bodyA.force.vsub(f,bodyA.force);
	    bodyB.force.vadd(f,bodyB.force);

	    // Angular force
	    ri.cross(f,ri_x_f);
	    rj.cross(f,rj_x_f);
	    bodyA.torque.vsub(ri_x_f,bodyA.torque);
	    bodyB.torque.vadd(rj_x_f,bodyB.torque);
	};

	},{"../math/Vec3":30}],36:[function(_dereq_,module,exports){
	var Vec3 = _dereq_('../math/Vec3');
	var Transform = _dereq_('../math/Transform');
	var RaycastResult = _dereq_('../collision/RaycastResult');
	var Utils = _dereq_('../utils/Utils');

	module.exports = WheelInfo;

	/**
	 * @class WheelInfo
	 * @constructor
	 * @param {Object} [options]
	 *
	 * @param {Vec3} [options.chassisConnectionPointLocal]
	 * @param {Vec3} [options.chassisConnectionPointWorld]
	 * @param {Vec3} [options.directionLocal]
	 * @param {Vec3} [options.directionWorld]
	 * @param {Vec3} [options.axleLocal]
	 * @param {Vec3} [options.axleWorld]
	 * @param {number} [options.suspensionRestLength=1]
	 * @param {number} [options.suspensionMaxLength=2]
	 * @param {number} [options.radius=1]
	 * @param {number} [options.suspensionStiffness=100]
	 * @param {number} [options.dampingCompression=10]
	 * @param {number} [options.dampingRelaxation=10]
	 * @param {number} [options.frictionSlip=10000]
	 * @param {number} [options.steering=0]
	 * @param {number} [options.rotation=0]
	 * @param {number} [options.deltaRotation=0]
	 * @param {number} [options.rollInfluence=0.01]
	 * @param {number} [options.maxSuspensionForce]
	 * @param {boolean} [options.isFrontWheel=true]
	 * @param {number} [options.clippedInvContactDotSuspension=1]
	 * @param {number} [options.suspensionRelativeVelocity=0]
	 * @param {number} [options.suspensionForce=0]
	 * @param {number} [options.skidInfo=0]
	 * @param {number} [options.suspensionLength=0]
	 * @param {number} [options.maxSuspensionTravel=1]
	 * @param {boolean} [options.useCustomSlidingRotationalSpeed=false]
	 * @param {number} [options.customSlidingRotationalSpeed=-0.1]
	 */
	function WheelInfo(options){
	    options = Utils.defaults(options, {
	        chassisConnectionPointLocal: new Vec3(),
	        chassisConnectionPointWorld: new Vec3(),
	        directionLocal: new Vec3(),
	        directionWorld: new Vec3(),
	        axleLocal: new Vec3(),
	        axleWorld: new Vec3(),
	        suspensionRestLength: 1,
	        suspensionMaxLength: 2,
	        radius: 1,
	        suspensionStiffness: 100,
	        dampingCompression: 10,
	        dampingRelaxation: 10,
	        frictionSlip: 10000,
	        steering: 0,
	        rotation: 0,
	        deltaRotation: 0,
	        rollInfluence: 0.01,
	        maxSuspensionForce: Number.MAX_VALUE,
	        isFrontWheel: true,
	        clippedInvContactDotSuspension: 1,
	        suspensionRelativeVelocity: 0,
	        suspensionForce: 0,
	        skidInfo: 0,
	        suspensionLength: 0,
	        maxSuspensionTravel: 1,
	        useCustomSlidingRotationalSpeed: false,
	        customSlidingRotationalSpeed: -0.1
	    });

	    /**
	     * Max travel distance of the suspension, in meters.
	     * @property {number} maxSuspensionTravel
	     */
	    this.maxSuspensionTravel = options.maxSuspensionTravel;

	    /**
	     * Speed to apply to the wheel rotation when the wheel is sliding.
	     * @property {number} customSlidingRotationalSpeed
	     */
	    this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;

	    /**
	     * If the customSlidingRotationalSpeed should be used.
	     * @property {Boolean} useCustomSlidingRotationalSpeed
	     */
	    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;

	    /**
	     * @property {Boolean} sliding
	     */
	    this.sliding = false;

	    /**
	     * Connection point, defined locally in the chassis body frame.
	     * @property {Vec3} chassisConnectionPointLocal
	     */
	    this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();

	    /**
	     * @property {Vec3} chassisConnectionPointWorld
	     */
	    this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();

	    /**
	     * @property {Vec3} directionLocal
	     */
	    this.directionLocal = options.directionLocal.clone();

	    /**
	     * @property {Vec3} directionWorld
	     */
	    this.directionWorld = options.directionWorld.clone();

	    /**
	     * @property {Vec3} axleLocal
	     */
	    this.axleLocal = options.axleLocal.clone();

	    /**
	     * @property {Vec3} axleWorld
	     */
	    this.axleWorld = options.axleWorld.clone();

	    /**
	     * @property {number} suspensionRestLength
	     */
	    this.suspensionRestLength = options.suspensionRestLength;

	    /**
	     * @property {number} suspensionMaxLength
	     */
	    this.suspensionMaxLength = options.suspensionMaxLength;

	    /**
	     * @property {number} radius
	     */
	    this.radius = options.radius;

	    /**
	     * @property {number} suspensionStiffness
	     */
	    this.suspensionStiffness = options.suspensionStiffness;

	    /**
	     * @property {number} dampingCompression
	     */
	    this.dampingCompression = options.dampingCompression;

	    /**
	     * @property {number} dampingRelaxation
	     */
	    this.dampingRelaxation = options.dampingRelaxation;

	    /**
	     * @property {number} frictionSlip
	     */
	    this.frictionSlip = options.frictionSlip;

	    /**
	     * @property {number} steering
	     */
	    this.steering = 0;

	    /**
	     * Rotation value, in radians.
	     * @property {number} rotation
	     */
	    this.rotation = 0;

	    /**
	     * @property {number} deltaRotation
	     */
	    this.deltaRotation = 0;

	    /**
	     * @property {number} rollInfluence
	     */
	    this.rollInfluence = options.rollInfluence;

	    /**
	     * @property {number} maxSuspensionForce
	     */
	    this.maxSuspensionForce = options.maxSuspensionForce;

	    /**
	     * @property {number} engineForce
	     */
	    this.engineForce = 0;

	    /**
	     * @property {number} brake
	     */
	    this.brake = 0;

	    /**
	     * @property {number} isFrontWheel
	     */
	    this.isFrontWheel = options.isFrontWheel;

	    /**
	     * @property {number} clippedInvContactDotSuspension
	     */
	    this.clippedInvContactDotSuspension = 1;

	    /**
	     * @property {number} suspensionRelativeVelocity
	     */
	    this.suspensionRelativeVelocity = 0;

	    /**
	     * @property {number} suspensionForce
	     */
	    this.suspensionForce = 0;

	    /**
	     * @property {number} skidInfo
	     */
	    this.skidInfo = 0;

	    /**
	     * @property {number} suspensionLength
	     */
	    this.suspensionLength = 0;

	    /**
	     * @property {number} sideImpulse
	     */
	    this.sideImpulse = 0;

	    /**
	     * @property {number} forwardImpulse
	     */
	    this.forwardImpulse = 0;

	    /**
	     * The result from raycasting
	     * @property {RaycastResult} raycastResult
	     */
	    this.raycastResult = new RaycastResult();

	    /**
	     * Wheel world transform
	     * @property {Transform} worldTransform
	     */
	    this.worldTransform = new Transform();

	    /**
	     * @property {boolean} isInContact
	     */
	    this.isInContact = false;
	}

	var chassis_velocity_at_contactPoint = new Vec3();
	var relpos = new Vec3();
	var chassis_velocity_at_contactPoint = new Vec3();
	WheelInfo.prototype.updateWheel = function(chassis){
	    var raycastResult = this.raycastResult;

	    if (this.isInContact){
	        var project= raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
	        raycastResult.hitPointWorld.vsub(chassis.position, relpos);
	        chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
	        var projVel = raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );
	        if (project >= -0.1) {
	            this.suspensionRelativeVelocity = 0.0;
	            this.clippedInvContactDotSuspension = 1.0 / 0.1;
	        } else {
	            var inv = -1 / project;
	            this.suspensionRelativeVelocity = projVel * inv;
	            this.clippedInvContactDotSuspension = inv;
	        }

	    } else {
	        // Not in contact : position wheel in a nice (rest length) position
	        raycastResult.suspensionLength = this.suspensionRestLength;
	        this.suspensionRelativeVelocity = 0.0;
	        raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
	        this.clippedInvContactDotSuspension = 1.0;
	    }
	};
	},{"../collision/RaycastResult":10,"../math/Transform":29,"../math/Vec3":30,"../utils/Utils":53}],37:[function(_dereq_,module,exports){
	module.exports = Box;

	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');

	/**
	 * A 3d box shape.
	 * @class Box
	 * @constructor
	 * @param {Vec3} halfExtents
	 * @author schteppe
	 * @extends Shape
	 */
	function Box(halfExtents){
	    Shape.call(this);

	    this.type = Shape.types.BOX;

	    /**
	     * @property halfExtents
	     * @type {Vec3}
	     */
	    this.halfExtents = halfExtents;

	    /**
	     * Used by the contact generator to make contacts with other convex polyhedra for example
	     * @property convexPolyhedronRepresentation
	     * @type {ConvexPolyhedron}
	     */
	    this.convexPolyhedronRepresentation = null;

	    this.updateConvexPolyhedronRepresentation();
	    this.updateBoundingSphereRadius();
	}
	Box.prototype = new Shape();
	Box.prototype.constructor = Box;

	/**
	 * Updates the local convex polyhedron representation used for some collisions.
	 * @method updateConvexPolyhedronRepresentation
	 */
	Box.prototype.updateConvexPolyhedronRepresentation = function(){
	    var sx = this.halfExtents.x;
	    var sy = this.halfExtents.y;
	    var sz = this.halfExtents.z;
	    var V = Vec3;

	    var vertices = [
	        new V(-sx,-sy,-sz),
	        new V( sx,-sy,-sz),
	        new V( sx, sy,-sz),
	        new V(-sx, sy,-sz),
	        new V(-sx,-sy, sz),
	        new V( sx,-sy, sz),
	        new V( sx, sy, sz),
	        new V(-sx, sy, sz)
	    ];

	    var indices = [
	        [3,2,1,0], // -z
	        [4,5,6,7], // +z
	        [5,4,0,1], // -y
	        [2,3,7,6], // +y
	        [0,4,7,3], // -x
	        [1,2,6,5], // +x
	    ];

	    var axes = [
	        new V(0, 0, 1),
	        new V(0, 1, 0),
	        new V(1, 0, 0)
	    ];

	    var h = new ConvexPolyhedron(vertices, indices);
	    this.convexPolyhedronRepresentation = h;
	    h.material = this.material;
	};

	/**
	 * @method calculateLocalInertia
	 * @param  {Number} mass
	 * @param  {Vec3} target
	 * @return {Vec3}
	 */
	Box.prototype.calculateLocalInertia = function(mass,target){
	    target = target || new Vec3();
	    Box.calculateInertia(this.halfExtents, mass, target);
	    return target;
	};

	Box.calculateInertia = function(halfExtents,mass,target){
	    var e = halfExtents;
	    target.x = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.z*2*e.z );
	    target.y = 1.0 / 12.0 * mass * (   2*e.x*2*e.x + 2*e.z*2*e.z );
	    target.z = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.x*2*e.x );
	};

	/**
	 * Get the box 6 side normals
	 * @method getSideNormals
	 * @param {array}      sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
	 * @param {Quaternion} quat             Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
	 * @return {array}
	 */
	Box.prototype.getSideNormals = function(sixTargetVectors,quat){
	    var sides = sixTargetVectors;
	    var ex = this.halfExtents;
	    sides[0].set(  ex.x,     0,     0);
	    sides[1].set(     0,  ex.y,     0);
	    sides[2].set(     0,     0,  ex.z);
	    sides[3].set( -ex.x,     0,     0);
	    sides[4].set(     0, -ex.y,     0);
	    sides[5].set(     0,     0, -ex.z);

	    if(quat!==undefined){
	        for(var i=0; i!==sides.length; i++){
	            quat.vmult(sides[i],sides[i]);
	        }
	    }

	    return sides;
	};

	Box.prototype.volume = function(){
	    return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
	};

	Box.prototype.updateBoundingSphereRadius = function(){
	    this.boundingSphereRadius = this.halfExtents.norm();
	};

	var worldCornerTempPos = new Vec3();
	var worldCornerTempNeg = new Vec3();
	Box.prototype.forEachWorldCorner = function(pos,quat,callback){

	    var e = this.halfExtents;
	    var corners = [[  e.x,  e.y,  e.z],
	                   [ -e.x,  e.y,  e.z],
	                   [ -e.x, -e.y,  e.z],
	                   [ -e.x, -e.y, -e.z],
	                   [  e.x, -e.y, -e.z],
	                   [  e.x,  e.y, -e.z],
	                   [ -e.x,  e.y, -e.z],
	                   [  e.x, -e.y,  e.z]];
	    for(var i=0; i<corners.length; i++){
	        worldCornerTempPos.set(corners[i][0],corners[i][1],corners[i][2]);
	        quat.vmult(worldCornerTempPos,worldCornerTempPos);
	        pos.vadd(worldCornerTempPos,worldCornerTempPos);
	        callback(worldCornerTempPos.x,
	                 worldCornerTempPos.y,
	                 worldCornerTempPos.z);
	    }
	};

	var worldCornersTemp = [
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3()
	];
	Box.prototype.calculateWorldAABB = function(pos,quat,min,max){

	    var e = this.halfExtents;
	    worldCornersTemp[0].set(e.x, e.y, e.z);
	    worldCornersTemp[1].set(-e.x,  e.y, e.z);
	    worldCornersTemp[2].set(-e.x, -e.y, e.z);
	    worldCornersTemp[3].set(-e.x, -e.y, -e.z);
	    worldCornersTemp[4].set(e.x, -e.y, -e.z);
	    worldCornersTemp[5].set(e.x,  e.y, -e.z);
	    worldCornersTemp[6].set(-e.x,  e.y, -e.z);
	    worldCornersTemp[7].set(e.x, -e.y,  e.z);

	    var wc = worldCornersTemp[0];
	    quat.vmult(wc, wc);
	    pos.vadd(wc, wc);
	    max.copy(wc);
	    min.copy(wc);
	    for(var i=1; i<8; i++){
	        var wc = worldCornersTemp[i];
	        quat.vmult(wc, wc);
	        pos.vadd(wc, wc);
	        var x = wc.x;
	        var y = wc.y;
	        var z = wc.z;
	        if(x > max.x){
	            max.x = x;
	        }
	        if(y > max.y){
	            max.y = y;
	        }
	        if(z > max.z){
	            max.z = z;
	        }

	        if(x < min.x){
	            min.x = x;
	        }
	        if(y < min.y){
	            min.y = y;
	        }
	        if(z < min.z){
	            min.z = z;
	        }
	    }

	    // Get each axis max
	    // min.set(Infinity,Infinity,Infinity);
	    // max.set(-Infinity,-Infinity,-Infinity);
	    // this.forEachWorldCorner(pos,quat,function(x,y,z){
	    //     if(x > max.x){
	    //         max.x = x;
	    //     }
	    //     if(y > max.y){
	    //         max.y = y;
	    //     }
	    //     if(z > max.z){
	    //         max.z = z;
	    //     }

	    //     if(x < min.x){
	    //         min.x = x;
	    //     }
	    //     if(y < min.y){
	    //         min.y = y;
	    //     }
	    //     if(z < min.z){
	    //         min.z = z;
	    //     }
	    // });
	};

	},{"../math/Vec3":30,"./ConvexPolyhedron":38,"./Shape":43}],38:[function(_dereq_,module,exports){
	module.exports = ConvexPolyhedron;

	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Transform = _dereq_('../math/Transform');

	/**
	 * A set of polygons describing a convex shape.
	 * @class ConvexPolyhedron
	 * @constructor
	 * @extends Shape
	 * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
	 * in the same 3D plane), instead these should be merged into one polygon.
	 *
	 * @param {array} points An array of Vec3's
	 * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.
	 *
	 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
	 * @author schteppe / https://github.com/schteppe
	 * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
	 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
	 *
	 * @todo Move the clipping functions to ContactGenerator?
	 * @todo Automatically merge coplanar polygons in constructor.
	 */
	function ConvexPolyhedron(points, faces, uniqueAxes) {
	    var that = this;
	    Shape.call(this);
	    this.type = Shape.types.CONVEXPOLYHEDRON;

	    /**
	     * Array of Vec3
	     * @property vertices
	     * @type {Array}
	     */
	    this.vertices = points||[];

	    this.worldVertices = []; // World transformed version of .vertices
	    this.worldVerticesNeedsUpdate = true;

	    /**
	     * Array of integer arrays, indicating which vertices each face consists of
	     * @property faces
	     * @type {Array}
	     */
	    this.faces = faces||[];

	    /**
	     * Array of Vec3
	     * @property faceNormals
	     * @type {Array}
	     */
	    this.faceNormals = [];
	    this.computeNormals();

	    this.worldFaceNormalsNeedsUpdate = true;
	    this.worldFaceNormals = []; // World transformed version of .faceNormals

	    /**
	     * Array of Vec3
	     * @property uniqueEdges
	     * @type {Array}
	     */
	    this.uniqueEdges = [];

	    /**
	     * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
	     * @property {Array} uniqueAxes
	     */
	    this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;

	    this.computeEdges();
	    this.updateBoundingSphereRadius();
	}
	ConvexPolyhedron.prototype = new Shape();
	ConvexPolyhedron.prototype.constructor = ConvexPolyhedron;

	var computeEdges_tmpEdge = new Vec3();
	/**
	 * Computes uniqueEdges
	 * @method computeEdges
	 */
	ConvexPolyhedron.prototype.computeEdges = function(){
	    var faces = this.faces;
	    var vertices = this.vertices;
	    var nv = vertices.length;
	    var edges = this.uniqueEdges;

	    edges.length = 0;

	    var edge = computeEdges_tmpEdge;

	    for(var i=0; i !== faces.length; i++){
	        var face = faces[i];
	        var numVertices = face.length;
	        for(var j = 0; j !== numVertices; j++){
	            var k = ( j+1 ) % numVertices;
	            vertices[face[j]].vsub(vertices[face[k]], edge);
	            edge.normalize();
	            var found = false;
	            for(var p=0; p !== edges.length; p++){
	                if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)){
	                    found = true;
	                    break;
	                }
	            }

	            if (!found){
	                edges.push(edge.clone());
	            }
	        }
	    }
	};

	/**
	 * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.
	 * @method computeNormals
	 */
	ConvexPolyhedron.prototype.computeNormals = function(){
	    this.faceNormals.length = this.faces.length;

	    // Generate normals
	    for(var i=0; i<this.faces.length; i++){

	        // Check so all vertices exists for this face
	        for(var j=0; j<this.faces[i].length; j++){
	            if(!this.vertices[this.faces[i][j]]){
	                throw new Error("Vertex "+this.faces[i][j]+" not found!");
	            }
	        }

	        var n = this.faceNormals[i] || new Vec3();
	        this.getFaceNormal(i,n);
	        n.negate(n);
	        this.faceNormals[i] = n;
	        var vertex = this.vertices[this.faces[i][0]];
	        if(n.dot(vertex) < 0){
	            console.error(".faceNormals[" + i + "] = Vec3("+n.toString()+") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");
	            for(var j=0; j<this.faces[i].length; j++){
	                console.warn(".vertices["+this.faces[i][j]+"] = Vec3("+this.vertices[this.faces[i][j]].toString()+")");
	            }
	        }
	    }
	};

	/**
	 * Get face normal given 3 vertices
	 * @static
	 * @method getFaceNormal
	 * @param {Vec3} va
	 * @param {Vec3} vb
	 * @param {Vec3} vc
	 * @param {Vec3} target
	 */
	var cb = new Vec3();
	var ab = new Vec3();
	ConvexPolyhedron.computeNormal = function ( va, vb, vc, target ) {
	    vb.vsub(va,ab);
	    vc.vsub(vb,cb);
	    cb.cross(ab,target);
	    if ( !target.isZero() ) {
	        target.normalize();
	    }
	};

	/**
	 * Compute the normal of a face from its vertices
	 * @method getFaceNormal
	 * @param  {Number} i
	 * @param  {Vec3} target
	 */
	ConvexPolyhedron.prototype.getFaceNormal = function(i,target){
	    var f = this.faces[i];
	    var va = this.vertices[f[0]];
	    var vb = this.vertices[f[1]];
	    var vc = this.vertices[f[2]];
	    return ConvexPolyhedron.computeNormal(va,vb,vc,target);
	};

	/**
	 * @method clipAgainstHull
	 * @param {Vec3} posA
	 * @param {Quaternion} quatA
	 * @param {ConvexPolyhedron} hullB
	 * @param {Vec3} posB
	 * @param {Quaternion} quatB
	 * @param {Vec3} separatingNormal
	 * @param {Number} minDist Clamp distance
	 * @param {Number} maxDist
	 * @param {array} result The an array of contact point objects, see clipFaceAgainstHull
	 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
	 */
	var cah_WorldNormal = new Vec3();
	ConvexPolyhedron.prototype.clipAgainstHull = function(posA,quatA,hullB,posB,quatB,separatingNormal,minDist,maxDist,result){
	    var WorldNormal = cah_WorldNormal;
	    var hullA = this;
	    var curMaxDist = maxDist;
	    var closestFaceB = -1;
	    var dmax = -Number.MAX_VALUE;
	    for(var face=0; face < hullB.faces.length; face++){
	        WorldNormal.copy(hullB.faceNormals[face]);
	        quatB.vmult(WorldNormal,WorldNormal);
	        //posB.vadd(WorldNormal,WorldNormal);
	        var d = WorldNormal.dot(separatingNormal);
	        if (d > dmax){
	            dmax = d;
	            closestFaceB = face;
	        }
	    }
	    var worldVertsB1 = [];
	    var polyB = hullB.faces[closestFaceB];
	    var numVertices = polyB.length;
	    for(var e0=0; e0<numVertices; e0++){
	        var b = hullB.vertices[polyB[e0]];
	        var worldb = new Vec3();
	        worldb.copy(b);
	        quatB.vmult(worldb,worldb);
	        posB.vadd(worldb,worldb);
	        worldVertsB1.push(worldb);
	    }

	    if (closestFaceB>=0){
	        this.clipFaceAgainstHull(separatingNormal,
	                                 posA,
	                                 quatA,
	                                 worldVertsB1,
	                                 minDist,
	                                 maxDist,
	                                 result);
	    }
	};

	/**
	 * Find the separating axis between this hull and another
	 * @method findSeparatingAxis
	 * @param {ConvexPolyhedron} hullB
	 * @param {Vec3} posA
	 * @param {Quaternion} quatA
	 * @param {Vec3} posB
	 * @param {Quaternion} quatB
	 * @param {Vec3} target The target vector to save the axis in
	 * @return {bool} Returns false if a separation is found, else true
	 */
	var fsa_faceANormalWS3 = new Vec3(),
	    fsa_Worldnormal1 = new Vec3(),
	    fsa_deltaC = new Vec3(),
	    fsa_worldEdge0 = new Vec3(),
	    fsa_worldEdge1 = new Vec3(),
	    fsa_Cross = new Vec3();
	ConvexPolyhedron.prototype.findSeparatingAxis = function(hullB,posA,quatA,posB,quatB,target, faceListA, faceListB){
	    var faceANormalWS3 = fsa_faceANormalWS3,
	        Worldnormal1 = fsa_Worldnormal1,
	        deltaC = fsa_deltaC,
	        worldEdge0 = fsa_worldEdge0,
	        worldEdge1 = fsa_worldEdge1,
	        Cross = fsa_Cross;

	    var dmin = Number.MAX_VALUE;
	    var hullA = this;
	    var curPlaneTests=0;

	    if(!hullA.uniqueAxes){

	        var numFacesA = faceListA ? faceListA.length : hullA.faces.length;

	        // Test face normals from hullA
	        for(var i=0; i<numFacesA; i++){
	            var fi = faceListA ? faceListA[i] : i;

	            // Get world face normal
	            faceANormalWS3.copy(hullA.faceNormals[fi]);
	            quatA.vmult(faceANormalWS3,faceANormalWS3);

	            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
	            if(d===false){
	                return false;
	            }

	            if(d<dmin){
	                dmin = d;
	                target.copy(faceANormalWS3);
	            }
	        }

	    } else {

	        // Test unique axes
	        for(var i = 0; i !== hullA.uniqueAxes.length; i++){

	            // Get world axis
	            quatA.vmult(hullA.uniqueAxes[i],faceANormalWS3);

	            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
	            if(d===false){
	                return false;
	            }

	            if(d<dmin){
	                dmin = d;
	                target.copy(faceANormalWS3);
	            }
	        }
	    }

	    if(!hullB.uniqueAxes){

	        // Test face normals from hullB
	        var numFacesB = faceListB ? faceListB.length : hullB.faces.length;
	        for(var i=0;i<numFacesB;i++){

	            var fi = faceListB ? faceListB[i] : i;

	            Worldnormal1.copy(hullB.faceNormals[fi]);
	            quatB.vmult(Worldnormal1,Worldnormal1);
	            curPlaneTests++;
	            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);
	            if(d===false){
	                return false;
	            }

	            if(d<dmin){
	                dmin = d;
	                target.copy(Worldnormal1);
	            }
	        }
	    } else {

	        // Test unique axes in B
	        for(var i = 0; i !== hullB.uniqueAxes.length; i++){
	            quatB.vmult(hullB.uniqueAxes[i],Worldnormal1);

	            curPlaneTests++;
	            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);
	            if(d===false){
	                return false;
	            }

	            if(d<dmin){
	                dmin = d;
	                target.copy(Worldnormal1);
	            }
	        }
	    }

	    // Test edges
	    for(var e0=0; e0 !== hullA.uniqueEdges.length; e0++){

	        // Get world edge
	        quatA.vmult(hullA.uniqueEdges[e0],worldEdge0);

	        for(var e1=0; e1 !== hullB.uniqueEdges.length; e1++){

	            // Get world edge 2
	            quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
	            worldEdge0.cross(worldEdge1,Cross);

	            if(!Cross.almostZero()){
	                Cross.normalize();
	                var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);
	                if(dist === false){
	                    return false;
	                }
	                if(dist < dmin){
	                    dmin = dist;
	                    target.copy(Cross);
	                }
	            }
	        }
	    }

	    posB.vsub(posA,deltaC);
	    if((deltaC.dot(target))>0.0){
	        target.negate(target);
	    }

	    return true;
	};

	var maxminA=[], maxminB=[];

	/**
	 * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
	 * @method testSepAxis
	 * @param {Vec3} axis
	 * @param {ConvexPolyhedron} hullB
	 * @param {Vec3} posA
	 * @param {Quaternion} quatA
	 * @param {Vec3} posB
	 * @param {Quaternion} quatB
	 * @return {number} The overlap depth, or FALSE if no penetration.
	 */
	ConvexPolyhedron.prototype.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB){
	    var hullA=this;
	    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
	    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
	    var maxA = maxminA[0];
	    var minA = maxminA[1];
	    var maxB = maxminB[0];
	    var minB = maxminB[1];
	    if(maxA<minB || maxB<minA){
	        return false; // Separated
	    }
	    var d0 = maxA - minB;
	    var d1 = maxB - minA;
	    var depth = d0<d1 ? d0:d1;
	    return depth;
	};

	var cli_aabbmin = new Vec3(),
	    cli_aabbmax = new Vec3();

	/**
	 * @method calculateLocalInertia
	 * @param  {Number} mass
	 * @param  {Vec3} target
	 */
	ConvexPolyhedron.prototype.calculateLocalInertia = function(mass,target){
	    // Approximate with box inertia
	    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
	    this.computeLocalAABB(cli_aabbmin,cli_aabbmax);
	    var x = cli_aabbmax.x - cli_aabbmin.x,
	        y = cli_aabbmax.y - cli_aabbmin.y,
	        z = cli_aabbmax.z - cli_aabbmin.z;
	    target.x = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z );
	    target.y = 1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z );
	    target.z = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x );
	};

	/**
	 * @method getPlaneConstantOfFace
	 * @param  {Number} face_i Index of the face
	 * @return {Number}
	 */
	ConvexPolyhedron.prototype.getPlaneConstantOfFace = function(face_i){
	    var f = this.faces[face_i];
	    var n = this.faceNormals[face_i];
	    var v = this.vertices[f[0]];
	    var c = -n.dot(v);
	    return c;
	};

	/**
	 * Clip a face against a hull.
	 * @method clipFaceAgainstHull
	 * @param {Vec3} separatingNormal
	 * @param {Vec3} posA
	 * @param {Quaternion} quatA
	 * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.
	 * @param {Number} minDist Distance clamping
	 * @param {Number} maxDist
	 * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
	 */
	var cfah_faceANormalWS = new Vec3(),
	    cfah_edge0 = new Vec3(),
	    cfah_WorldEdge0 = new Vec3(),
	    cfah_worldPlaneAnormal1 = new Vec3(),
	    cfah_planeNormalWS1 = new Vec3(),
	    cfah_worldA1 = new Vec3(),
	    cfah_localPlaneNormal = new Vec3(),
	    cfah_planeNormalWS = new Vec3();
	ConvexPolyhedron.prototype.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist,result){
	    var faceANormalWS = cfah_faceANormalWS,
	        edge0 = cfah_edge0,
	        WorldEdge0 = cfah_WorldEdge0,
	        worldPlaneAnormal1 = cfah_worldPlaneAnormal1,
	        planeNormalWS1 = cfah_planeNormalWS1,
	        worldA1 = cfah_worldA1,
	        localPlaneNormal = cfah_localPlaneNormal,
	        planeNormalWS = cfah_planeNormalWS;

	    var hullA = this;
	    var worldVertsB2 = [];
	    var pVtxIn = worldVertsB1;
	    var pVtxOut = worldVertsB2;
	    // Find the face with normal closest to the separating axis
	    var closestFaceA = -1;
	    var dmin = Number.MAX_VALUE;
	    for(var face=0; face<hullA.faces.length; face++){
	        faceANormalWS.copy(hullA.faceNormals[face]);
	        quatA.vmult(faceANormalWS,faceANormalWS);
	        //posA.vadd(faceANormalWS,faceANormalWS);
	        var d = faceANormalWS.dot(separatingNormal);
	        if (d < dmin){
	            dmin = d;
	            closestFaceA = face;
	        }
	    }
	    if (closestFaceA < 0){
	        // console.log("--- did not find any closest face... ---");
	        return;
	    }
	    //console.log("closest A: ",closestFaceA);
	    // Get the face and construct connected faces
	    var polyA = hullA.faces[closestFaceA];
	    polyA.connectedFaces = [];
	    for(var i=0; i<hullA.faces.length; i++){
	        for(var j=0; j<hullA.faces[i].length; j++){
	            if(polyA.indexOf(hullA.faces[i][j])!==-1 /* Sharing a vertex*/ && i!==closestFaceA /* Not the one we are looking for connections from */ && polyA.connectedFaces.indexOf(i)===-1 /* Not already added */ ){
	                polyA.connectedFaces.push(i);
	            }
	        }
	    }
	    // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face
	    var numContacts = pVtxIn.length;
	    var numVerticesA = polyA.length;
	    var res = [];
	    for(var e0=0; e0<numVerticesA; e0++){
	        var a = hullA.vertices[polyA[e0]];
	        var b = hullA.vertices[polyA[(e0+1)%numVerticesA]];
	        a.vsub(b,edge0);
	        WorldEdge0.copy(edge0);
	        quatA.vmult(WorldEdge0,WorldEdge0);
	        posA.vadd(WorldEdge0,WorldEdge0);
	        worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);//transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);
	        quatA.vmult(worldPlaneAnormal1,worldPlaneAnormal1);
	        posA.vadd(worldPlaneAnormal1,worldPlaneAnormal1);
	        WorldEdge0.cross(worldPlaneAnormal1,planeNormalWS1);
	        planeNormalWS1.negate(planeNormalWS1);
	        worldA1.copy(a);
	        quatA.vmult(worldA1,worldA1);
	        posA.vadd(worldA1,worldA1);
	        var planeEqWS1 = -worldA1.dot(planeNormalWS1);
	        var planeEqWS;
	        if(true){
	            var otherFace = polyA.connectedFaces[e0];
	            localPlaneNormal.copy(this.faceNormals[otherFace]);
	            var localPlaneEq = this.getPlaneConstantOfFace(otherFace);

	            planeNormalWS.copy(localPlaneNormal);
	            quatA.vmult(planeNormalWS,planeNormalWS);
	            //posA.vadd(planeNormalWS,planeNormalWS);
	            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
	        } else  {
	            planeNormalWS.copy(planeNormalWS1);
	            planeEqWS = planeEqWS1;
	        }

	        // Clip face against our constructed plane
	        this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);

	        // Throw away all clipped points, but save the reamining until next clip
	        while(pVtxIn.length){
	            pVtxIn.shift();
	        }
	        while(pVtxOut.length){
	            pVtxIn.push(pVtxOut.shift());
	        }
	    }

	    //console.log("Resulting points after clip:",pVtxIn);

	    // only keep contact points that are behind the witness face
	    localPlaneNormal.copy(this.faceNormals[closestFaceA]);

	    var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
	    planeNormalWS.copy(localPlaneNormal);
	    quatA.vmult(planeNormalWS,planeNormalWS);

	    var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
	    for (var i=0; i<pVtxIn.length; i++){
	        var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???
	        /*console.log("depth calc from normal=",planeNormalWS.toString()," and constant "+planeEqWS+" and vertex ",pVtxIn[i].toString()," gives "+depth);*/
	        if (depth <=minDist){
	            console.log("clamped: depth="+depth+" to minDist="+(minDist+""));
	            depth = minDist;
	        }

	        if (depth <=maxDist){
	            var point = pVtxIn[i];
	            if(depth<=0){
	                /*console.log("Got contact point ",point.toString(),
	                  ", depth=",depth,
	                  "contact normal=",separatingNormal.toString(),
	                  "plane",planeNormalWS.toString(),
	                  "planeConstant",planeEqWS);*/
	                var p = {
	                    point:point,
	                    normal:planeNormalWS,
	                    depth: depth,
	                };
	                result.push(p);
	            }
	        }
	    }
	};

	/**
	 * Clip a face in a hull against the back of a plane.
	 * @method clipFaceAgainstPlane
	 * @param {Array} inVertices
	 * @param {Array} outVertices
	 * @param {Vec3} planeNormal
	 * @param {Number} planeConstant The constant in the mathematical plane equation
	 */
	ConvexPolyhedron.prototype.clipFaceAgainstPlane = function(inVertices,outVertices, planeNormal, planeConstant){
	    var n_dot_first, n_dot_last;
	    var numVerts = inVertices.length;

	    if(numVerts < 2){
	        return outVertices;
	    }

	    var firstVertex = inVertices[inVertices.length-1],
	        lastVertex =   inVertices[0];

	    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

	    for(var vi = 0; vi < numVerts; vi++){
	        lastVertex = inVertices[vi];
	        n_dot_last = planeNormal.dot(lastVertex) + planeConstant;
	        if(n_dot_first < 0){
	            if(n_dot_last < 0){
	                // Start < 0, end < 0, so output lastVertex
	                var newv = new Vec3();
	                newv.copy(lastVertex);
	                outVertices.push(newv);
	            } else {
	                // Start < 0, end >= 0, so output intersection
	                var newv = new Vec3();
	                firstVertex.lerp(lastVertex,
	                                 n_dot_first / (n_dot_first - n_dot_last),
	                                 newv);
	                outVertices.push(newv);
	            }
	        } else {
	            if(n_dot_last<0){
	                // Start >= 0, end < 0 so output intersection and end
	                var newv = new Vec3();
	                firstVertex.lerp(lastVertex,
	                                 n_dot_first / (n_dot_first - n_dot_last),
	                                 newv);
	                outVertices.push(newv);
	                outVertices.push(lastVertex);
	            }
	        }
	        firstVertex = lastVertex;
	        n_dot_first = n_dot_last;
	    }
	    return outVertices;
	};

	// Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
	ConvexPolyhedron.prototype.computeWorldVertices = function(position,quat){
	    var N = this.vertices.length;
	    while(this.worldVertices.length < N){
	        this.worldVertices.push( new Vec3() );
	    }

	    var verts = this.vertices,
	        worldVerts = this.worldVertices;
	    for(var i=0; i!==N; i++){
	        quat.vmult( verts[i] , worldVerts[i] );
	        position.vadd( worldVerts[i] , worldVerts[i] );
	    }

	    this.worldVerticesNeedsUpdate = false;
	};

	var computeLocalAABB_worldVert = new Vec3();
	ConvexPolyhedron.prototype.computeLocalAABB = function(aabbmin,aabbmax){
	    var n = this.vertices.length,
	        vertices = this.vertices,
	        worldVert = computeLocalAABB_worldVert;

	    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
	    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

	    for(var i=0; i<n; i++){
	        var v = vertices[i];
	        if     (v.x < aabbmin.x){
	            aabbmin.x = v.x;
	        } else if(v.x > aabbmax.x){
	            aabbmax.x = v.x;
	        }
	        if     (v.y < aabbmin.y){
	            aabbmin.y = v.y;
	        } else if(v.y > aabbmax.y){
	            aabbmax.y = v.y;
	        }
	        if     (v.z < aabbmin.z){
	            aabbmin.z = v.z;
	        } else if(v.z > aabbmax.z){
	            aabbmax.z = v.z;
	        }
	    }
	};

	/**
	 * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
	 * @method computeWorldFaceNormals
	 * @param  {Quaternion} quat
	 */
	ConvexPolyhedron.prototype.computeWorldFaceNormals = function(quat){
	    var N = this.faceNormals.length;
	    while(this.worldFaceNormals.length < N){
	        this.worldFaceNormals.push( new Vec3() );
	    }

	    var normals = this.faceNormals,
	        worldNormals = this.worldFaceNormals;
	    for(var i=0; i!==N; i++){
	        quat.vmult( normals[i] , worldNormals[i] );
	    }

	    this.worldFaceNormalsNeedsUpdate = false;
	};

	/**
	 * @method updateBoundingSphereRadius
	 */
	ConvexPolyhedron.prototype.updateBoundingSphereRadius = function(){
	    // Assume points are distributed with local (0,0,0) as center
	    var max2 = 0;
	    var verts = this.vertices;
	    for(var i=0, N=verts.length; i!==N; i++) {
	        var norm2 = verts[i].norm2();
	        if(norm2 > max2){
	            max2 = norm2;
	        }
	    }
	    this.boundingSphereRadius = Math.sqrt(max2);
	};

	var tempWorldVertex = new Vec3();

	/**
	 * @method calculateWorldAABB
	 * @param {Vec3}        pos
	 * @param {Quaternion}  quat
	 * @param {Vec3}        min
	 * @param {Vec3}        max
	 */
	ConvexPolyhedron.prototype.calculateWorldAABB = function(pos,quat,min,max){
	    var n = this.vertices.length, verts = this.vertices;
	    var minx,miny,minz,maxx,maxy,maxz;
	    for(var i=0; i<n; i++){
	        tempWorldVertex.copy(verts[i]);
	        quat.vmult(tempWorldVertex,tempWorldVertex);
	        pos.vadd(tempWorldVertex,tempWorldVertex);
	        var v = tempWorldVertex;
	        if     (v.x < minx || minx===undefined){
	            minx = v.x;
	        } else if(v.x > maxx || maxx===undefined){
	            maxx = v.x;
	        }

	        if     (v.y < miny || miny===undefined){
	            miny = v.y;
	        } else if(v.y > maxy || maxy===undefined){
	            maxy = v.y;
	        }

	        if     (v.z < minz || minz===undefined){
	            minz = v.z;
	        } else if(v.z > maxz || maxz===undefined){
	            maxz = v.z;
	        }
	    }
	    min.set(minx,miny,minz);
	    max.set(maxx,maxy,maxz);
	};

	/**
	 * Get approximate convex volume
	 * @method volume
	 * @return {Number}
	 */
	ConvexPolyhedron.prototype.volume = function(){
	    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
	};

	/**
	 * Get an average of all the vertices positions
	 * @method getAveragePointLocal
	 * @param  {Vec3} target
	 * @return {Vec3}
	 */
	ConvexPolyhedron.prototype.getAveragePointLocal = function(target){
	    target = target || new Vec3();
	    var n = this.vertices.length,
	        verts = this.vertices;
	    for(var i=0; i<n; i++){
	        target.vadd(verts[i],target);
	    }
	    target.mult(1/n,target);
	    return target;
	};

	/**
	 * Transform all local points. Will change the .vertices
	 * @method transformAllPoints
	 * @param  {Vec3} offset
	 * @param  {Quaternion} quat
	 */
	ConvexPolyhedron.prototype.transformAllPoints = function(offset,quat){
	    var n = this.vertices.length,
	        verts = this.vertices;

	    // Apply rotation
	    if(quat){
	        // Rotate vertices
	        for(var i=0; i<n; i++){
	            var v = verts[i];
	            quat.vmult(v,v);
	        }
	        // Rotate face normals
	        for(var i=0; i<this.faceNormals.length; i++){
	            var v = this.faceNormals[i];
	            quat.vmult(v,v);
	        }
	        /*
	        // Rotate edges
	        for(var i=0; i<this.uniqueEdges.length; i++){
	            var v = this.uniqueEdges[i];
	            quat.vmult(v,v);
	        }*/
	    }

	    // Apply offset
	    if(offset){
	        for(var i=0; i<n; i++){
	            var v = verts[i];
	            v.vadd(offset,v);
	        }
	    }
	};

	/**
	 * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.
	 * @method pointIsInside
	 * @param  {Vec3} p      A point given in local coordinates
	 * @return {Boolean}
	 */
	var ConvexPolyhedron_pointIsInside = new Vec3();
	var ConvexPolyhedron_vToP = new Vec3();
	var ConvexPolyhedron_vToPointInside = new Vec3();
	ConvexPolyhedron.prototype.pointIsInside = function(p){
	    var n = this.vertices.length,
	        verts = this.vertices,
	        faces = this.faces,
	        normals = this.faceNormals;
	    var positiveResult = null;
	    var N = this.faces.length;
	    var pointInside = ConvexPolyhedron_pointIsInside;
	    this.getAveragePointLocal(pointInside);
	    for(var i=0; i<N; i++){
	        var numVertices = this.faces[i].length;
	        var n = normals[i];
	        var v = verts[faces[i][0]]; // We only need one point in the face

	        // This dot product determines which side of the edge the point is
	        var vToP = ConvexPolyhedron_vToP;
	        p.vsub(v,vToP);
	        var r1 = n.dot(vToP);

	        var vToPointInside = ConvexPolyhedron_vToPointInside;
	        pointInside.vsub(v,vToPointInside);
	        var r2 = n.dot(vToPointInside);

	        if((r1<0 && r2>0) || (r1>0 && r2<0)){
	            return false; // Encountered some other sign. Exit.
	        } else {
	        }
	    }

	    // If we got here, all dot products were of the same sign.
	    return positiveResult ? 1 : -1;
	};

	/**
	 * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.
	 * @static
	 * @method project
	 * @param {ConvexPolyhedron} hull
	 * @param {Vec3} axis
	 * @param {Vec3} pos
	 * @param {Quaternion} quat
	 * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.
	 */
	var project_worldVertex = new Vec3();
	var project_localAxis = new Vec3();
	var project_localOrigin = new Vec3();
	ConvexPolyhedron.project = function(hull, axis, pos, quat, result){
	    var n = hull.vertices.length,
	        worldVertex = project_worldVertex,
	        localAxis = project_localAxis,
	        max = 0,
	        min = 0,
	        localOrigin = project_localOrigin,
	        vs = hull.vertices;

	    localOrigin.setZero();

	    // Transform the axis to local
	    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
	    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
	    var add = localOrigin.dot(localAxis);

	    min = max = vs[0].dot(localAxis);

	    for(var i = 1; i < n; i++){
	        var val = vs[i].dot(localAxis);

	        if(val > max){
	            max = val;
	        }

	        if(val < min){
	            min = val;
	        }
	    }

	    min -= add;
	    max -= add;

	    if(min > max){
	        // Inconsistent - swap
	        var temp = min;
	        min = max;
	        max = temp;
	    }
	    // Output
	    result[0] = max;
	    result[1] = min;
	};

	},{"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"./Shape":43}],39:[function(_dereq_,module,exports){
	module.exports = Cylinder;

	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');

	/**
	 * @class Cylinder
	 * @constructor
	 * @extends ConvexPolyhedron
	 * @author schteppe / https://github.com/schteppe
	 * @param {Number} radiusTop
	 * @param {Number} radiusBottom
	 * @param {Number} height
	 * @param {Number} numSegments The number of segments to build the cylinder out of
	 */
	function Cylinder( radiusTop, radiusBottom, height , numSegments ) {
	    var N = numSegments,
	        verts = [],
	        axes = [],
	        faces = [],
	        bottomface = [],
	        topface = [],
	        cos = Math.cos,
	        sin = Math.sin;

	    // First bottom point
	    verts.push(new Vec3(radiusBottom*cos(0),
	                               radiusBottom*sin(0),
	                               -height*0.5));
	    bottomface.push(0);

	    // First top point
	    verts.push(new Vec3(radiusTop*cos(0),
	                               radiusTop*sin(0),
	                               height*0.5));
	    topface.push(1);

	    for(var i=0; i<N; i++){
	        var theta = 2*Math.PI/N * (i+1);
	        var thetaN = 2*Math.PI/N * (i+0.5);
	        if(i<N-1){
	            // Bottom
	            verts.push(new Vec3(radiusBottom*cos(theta),
	                                       radiusBottom*sin(theta),
	                                       -height*0.5));
	            bottomface.push(2*i+2);
	            // Top
	            verts.push(new Vec3(radiusTop*cos(theta),
	                                       radiusTop*sin(theta),
	                                       height*0.5));
	            topface.push(2*i+3);

	            // Face
	            faces.push([2*i+2, 2*i+3, 2*i+1,2*i]);
	        } else {
	            faces.push([0,1, 2*i+1, 2*i]); // Connect
	        }

	        // Axis: we can cut off half of them if we have even number of segments
	        if(N % 2 === 1 || i < N / 2){
	            axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));
	        }
	    }
	    faces.push(topface);
	    axes.push(new Vec3(0,0,1));

	    // Reorder bottom face
	    var temp = [];
	    for(var i=0; i<bottomface.length; i++){
	        temp.push(bottomface[bottomface.length - i - 1]);
	    }
	    faces.push(temp);

	    this.type = Shape.types.CONVEXPOLYHEDRON;
	    ConvexPolyhedron.call( this, verts, faces, axes );
	}

	Cylinder.prototype = new ConvexPolyhedron();

	},{"../math/Quaternion":28,"../math/Vec3":30,"./ConvexPolyhedron":38,"./Shape":43}],40:[function(_dereq_,module,exports){
	var Shape = _dereq_('./Shape');
	var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');
	var Vec3 = _dereq_('../math/Vec3');
	var Utils = _dereq_('../utils/Utils');

	module.exports = Heightfield;

	/**
	 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
	 * @class Heightfield
	 * @extends Shape
	 * @constructor
	 * @param {Array} data An array of Y values that will be used to construct the terrain.
	 * @param {object} options
	 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
	 * @param {Number} [options.maxValue] Maximum value.
	 * @param {Number} [options.elementSize=0.1] World spacing between the data points in X direction.
	 * @todo Should be possible to use along all axes, not just y
	 *
	 * @example
	 *     // Generate some height data (y-values).
	 *     var data = [];
	 *     for(var i = 0; i < 1000; i++){
	 *         var y = 0.5 * Math.cos(0.2 * i);
	 *         data.push(y);
	 *     }
	 *
	 *     // Create the heightfield shape
	 *     var heightfieldShape = new Heightfield(data, {
	 *         elementSize: 1 // Distance between the data points in X and Y directions
	 *     });
	 *     var heightfieldBody = new Body();
	 *     heightfieldBody.addShape(heightfieldShape);
	 *     world.addBody(heightfieldBody);
	 */
	function Heightfield(data, options){
	    options = Utils.defaults(options, {
	        maxValue : null,
	        minValue : null,
	        elementSize : 1
	    });

	    /**
	     * An array of numbers, or height values, that are spread out along the x axis.
	     * @property {array} data
	     */
	    this.data = data;

	    /**
	     * Max value of the data
	     * @property {number} maxValue
	     */
	    this.maxValue = options.maxValue;

	    /**
	     * Max value of the data
	     * @property {number} minValue
	     */
	    this.minValue = options.minValue;

	    /**
	     * The width of each element
	     * @property {number} elementSize
	     * @todo elementSizeX and Y
	     */
	    this.elementSize = options.elementSize;

	    if(options.minValue === null){
	        this.updateMinValue();
	    }
	    if(options.maxValue === null){
	        this.updateMaxValue();
	    }

	    this.cacheEnabled = true;

	    Shape.call(this);

	    this.pillarConvex = new ConvexPolyhedron();
	    this.pillarOffset = new Vec3();

	    this.type = Shape.types.HEIGHTFIELD;
	    this.updateBoundingSphereRadius();

	    // "i_j_isUpper" => { convex: ..., offset: ... }
	    // for example:
	    // _cachedPillars["0_2_1"]
	    this._cachedPillars = {};
	}
	Heightfield.prototype = new Shape();

	/**
	 * Call whenever you change the data array.
	 * @method update
	 */
	Heightfield.prototype.update = function(){
	    this._cachedPillars = {};
	};

	/**
	 * Update the .minValue property
	 * @method updateMinValue
	 */
	Heightfield.prototype.updateMinValue = function(){
	    var data = this.data;
	    var minValue = data[0][0];
	    for(var i=0; i !== data.length; i++){
	        for(var j=0; j !== data[i].length; j++){
	            var v = data[i][j];
	            if(v < minValue){
	                minValue = v;
	            }
	        }
	    }
	    this.minValue = minValue;
	};

	/**
	 * Update the .maxValue property
	 * @method updateMaxValue
	 */
	Heightfield.prototype.updateMaxValue = function(){
	    var data = this.data;
	    var maxValue = data[0][0];
	    for(var i=0; i !== data.length; i++){
	        for(var j=0; j !== data[i].length; j++){
	            var v = data[i][j];
	            if(v > maxValue){
	                maxValue = v;
	            }
	        }
	    }
	    this.maxValue = maxValue;
	};

	/**
	 * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
	 * @method setHeightValueAtIndex
	 * @param {integer} xi
	 * @param {integer} yi
	 * @param {number} value
	 */
	Heightfield.prototype.setHeightValueAtIndex = function(xi, yi, value){
	    var data = this.data;
	    data[xi][yi] = value;

	    // Invalidate cache
	    this.clearCachedConvexTrianglePillar(xi, yi, false);
	    if(xi > 0){
	        this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
	        this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
	    }
	    if(yi > 0){
	        this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
	        this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
	    }
	    if(yi > 0 && xi > 0){
	        this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
	    }
	};

	/**
	 * Get max/min in a rectangle in the matrix data
	 * @method getRectMinMax
	 * @param  {integer} iMinX
	 * @param  {integer} iMinY
	 * @param  {integer} iMaxX
	 * @param  {integer} iMaxY
	 * @param  {array} [result] An array to store the results in.
	 * @return {array} The result array, if it was passed in. Minimum will be at position 0 and max at 1.
	 */
	Heightfield.prototype.getRectMinMax = function (iMinX, iMinY, iMaxX, iMaxY, result) {
	    result = result || [];

	    // Get max and min of the data
	    var data = this.data,
	        max = this.minValue; // Set first value
	    for(var i = iMinX; i <= iMaxX; i++){
	        for(var j = iMinY; j <= iMaxY; j++){
	            var height = data[i][j];
	            if(height > max){
	                max = height;
	            }
	        }
	    }

	    result[0] = this.minValue;
	    result[1] = max;
	};

	/**
	 * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
	 * @method getIndexOfPosition
	 * @param  {number} x
	 * @param  {number} y
	 * @param  {array} result Two-element array
	 * @param  {boolean} clamp If the position should be clamped to the heightfield edge.
	 * @return {boolean}
	 */
	Heightfield.prototype.getIndexOfPosition = function (x, y, result, clamp) {

	    // Get the index of the data points to test against
	    var w = this.elementSize;
	    var data = this.data;
	    var xi = Math.floor(x / w);
	    var yi = Math.floor(y / w);

	    result[0] = xi;
	    result[1] = yi;

	    if(clamp){
	        // Clamp index to edges
	        if(xi < 0){ xi = 0; }
	        if(yi < 0){ yi = 0; }
	        if(xi >= data.length - 1){ xi = data.length - 1; }
	        if(yi >= data[0].length - 1){ yi = data[0].length - 1; }
	    }

	    // Bail out if we are out of the terrain
	    if(xi < 0 || yi < 0 || xi >= data.length-1 || yi >= data[0].length-1){
	        return false;
	    }

	    return true;
	};

	Heightfield.prototype.getHeightAt = function(x, y, edgeClamp){
	    var idx = [];
	    this.getIndexOfPosition(x, y, idx, edgeClamp);

	    // TODO: get upper or lower triangle, then use barycentric interpolation to get the height in the triangle.
	    var minmax = [];
	    this.getRectMinMax(idx[0], idx[1] + 1, idx[0], idx[1] + 1, minmax);

	    return (minmax[0] + minmax[1]) / 2; // average
	};

	Heightfield.prototype.getCacheConvexTrianglePillarKey = function(xi, yi, getUpperTriangle){
	    return xi + '_' + yi + '_' + (getUpperTriangle ? 1 : 0);
	};

	Heightfield.prototype.getCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){
	    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
	};

	Heightfield.prototype.setCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle, convex, offset){
	    this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
	        convex: convex,
	        offset: offset
	    };
	};

	Heightfield.prototype.clearCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){
	    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
	};

	/**
	 * Get a triangle in the terrain in the form of a triangular convex shape.
	 * @method getConvexTrianglePillar
	 * @param  {integer} i
	 * @param  {integer} j
	 * @param  {boolean} getUpperTriangle
	 */
	Heightfield.prototype.getConvexTrianglePillar = function(xi, yi, getUpperTriangle){
	    var result = this.pillarConvex;
	    var offsetResult = this.pillarOffset;

	    if(this.cacheEnabled){
	        var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);
	        if(data){
	            this.pillarConvex = data.convex;
	            this.pillarOffset = data.offset;
	            return;
	        }

	        result = new ConvexPolyhedron();
	        offsetResult = new Vec3();

	        this.pillarConvex = result;
	        this.pillarOffset = offsetResult;
	    }

	    var data = this.data;
	    var elementSize = this.elementSize;
	    var faces = result.faces;

	    // Reuse verts if possible
	    result.vertices.length = 6;
	    for (var i = 0; i < 6; i++) {
	        if(!result.vertices[i]){
	            result.vertices[i] = new Vec3();
	        }
	    }

	    // Reuse faces if possible
	    faces.length = 5;
	    for (var i = 0; i < 5; i++) {
	        if(!faces[i]){
	            faces[i] = [];
	        }
	    }

	    var verts = result.vertices;

	    var h = (Math.min(
	        data[xi][yi],
	        data[xi+1][yi],
	        data[xi][yi+1],
	        data[xi+1][yi+1]
	    ) - this.minValue ) / 2 + this.minValue;

	    if (!getUpperTriangle) {

	        // Center of the triangle pillar - all polygons are given relative to this one
	        offsetResult.set(
	            (xi + 0.25) * elementSize, // sort of center of a triangle
	            (yi + 0.25) * elementSize,
	            h // vertical center
	        );

	        // Top triangle verts
	        verts[0].set(
	            -0.25 * elementSize,
	            -0.25 * elementSize,
	            data[xi][yi] - h
	        );
	        verts[1].set(
	            0.75 * elementSize,
	            -0.25 * elementSize,
	            data[xi + 1][yi] - h
	        );
	        verts[2].set(
	            -0.25 * elementSize,
	            0.75 * elementSize,
	            data[xi][yi + 1] - h
	        );

	        // bottom triangle verts
	        verts[3].set(
	            -0.25 * elementSize,
	            -0.25 * elementSize,
	            -h-1
	        );
	        verts[4].set(
	            0.75 * elementSize,
	            -0.25 * elementSize,
	            -h-1
	        );
	        verts[5].set(
	            -0.25 * elementSize,
	            0.75  * elementSize,
	            -h-1
	        );

	        // top triangle
	        faces[0][0] = 0;
	        faces[0][1] = 1;
	        faces[0][2] = 2;

	        // bottom triangle
	        faces[1][0] = 5;
	        faces[1][1] = 4;
	        faces[1][2] = 3;

	        // -x facing quad
	        faces[2][0] = 0;
	        faces[2][1] = 2;
	        faces[2][2] = 5;
	        faces[2][3] = 3;

	        // -y facing quad
	        faces[3][0] = 1;
	        faces[3][1] = 0;
	        faces[3][2] = 3;
	        faces[3][3] = 4;

	        // +xy facing quad
	        faces[4][0] = 4;
	        faces[4][1] = 5;
	        faces[4][2] = 2;
	        faces[4][3] = 1;


	    } else {

	        // Center of the triangle pillar - all polygons are given relative to this one
	        offsetResult.set(
	            (xi + 0.75) * elementSize, // sort of center of a triangle
	            (yi + 0.75) * elementSize,
	            h // vertical center
	        );

	        // Top triangle verts
	        verts[0].set(
	            0.25 * elementSize,
	            0.25 * elementSize,
	            data[xi + 1][yi + 1] - h
	        );
	        verts[1].set(
	            -0.75 * elementSize,
	            0.25 * elementSize,
	            data[xi][yi + 1] - h
	        );
	        verts[2].set(
	            0.25 * elementSize,
	            -0.75 * elementSize,
	            data[xi + 1][yi] - h
	        );

	        // bottom triangle verts
	        verts[3].set(
	            0.25 * elementSize,
	            0.25 * elementSize,
	            - h-1
	        );
	        verts[4].set(
	            -0.75 * elementSize,
	            0.25 * elementSize,
	            - h-1
	        );
	        verts[5].set(
	            0.25 * elementSize,
	            -0.75 * elementSize,
	            - h-1
	        );

	        // Top triangle
	        faces[0][0] = 0;
	        faces[0][1] = 1;
	        faces[0][2] = 2;

	        // bottom triangle
	        faces[1][0] = 5;
	        faces[1][1] = 4;
	        faces[1][2] = 3;

	        // +x facing quad
	        faces[2][0] = 2;
	        faces[2][1] = 5;
	        faces[2][2] = 3;
	        faces[2][3] = 0;

	        // +y facing quad
	        faces[3][0] = 3;
	        faces[3][1] = 4;
	        faces[3][2] = 1;
	        faces[3][3] = 0;

	        // -xy facing quad
	        faces[4][0] = 1;
	        faces[4][1] = 4;
	        faces[4][2] = 5;
	        faces[4][3] = 2;
	    }

	    result.computeNormals();
	    result.computeEdges();
	    result.updateBoundingSphereRadius();

	    this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
	};

	Heightfield.prototype.calculateLocalInertia = function(mass, target){
	    target = target || new Vec3();
	    target.set(0, 0, 0);
	    return target;
	};

	Heightfield.prototype.volume = function(){
	    return Number.MAX_VALUE; // The terrain is infinite
	};

	Heightfield.prototype.calculateWorldAABB = function(pos, quat, min, max){
	    // TODO: do it properly
	    min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
	    max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
	};

	Heightfield.prototype.updateBoundingSphereRadius = function(){
	    // Use the bounding box of the min/max values
	    var data = this.data,
	        s = this.elementSize;
	    this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
	};

	},{"../math/Vec3":30,"../utils/Utils":53,"./ConvexPolyhedron":38,"./Shape":43}],41:[function(_dereq_,module,exports){
	module.exports = Particle;

	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');

	/**
	 * Particle shape.
	 * @class Particle
	 * @constructor
	 * @author schteppe
	 * @extends Shape
	 */
	function Particle(){
	    Shape.call(this);

	    this.type = Shape.types.PARTICLE;
	}
	Particle.prototype = new Shape();
	Particle.prototype.constructor = Particle;

	/**
	 * @method calculateLocalInertia
	 * @param  {Number} mass
	 * @param  {Vec3} target
	 * @return {Vec3}
	 */
	Particle.prototype.calculateLocalInertia = function(mass,target){
	    target = target || new Vec3();
	    target.set(0, 0, 0);
	    return target;
	};

	Particle.prototype.volume = function(){
	    return 0;
	};

	Particle.prototype.updateBoundingSphereRadius = function(){
	    this.boundingSphereRadius = 0;
	};

	Particle.prototype.calculateWorldAABB = function(pos,quat,min,max){
	    // Get each axis max
	    min.copy(pos);
	    max.copy(pos);
	};

	},{"../math/Vec3":30,"./Shape":43}],42:[function(_dereq_,module,exports){
	module.exports = Plane;

	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');

	/**
	 * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a RigidBody and rotate that body. See the demos.
	 * @class Plane
	 * @constructor
	 * @extends Shape
	 * @author schteppe
	 */
	function Plane(){
	    Shape.call(this);
	    this.type = Shape.types.PLANE;

	    // World oriented normal
	    this.worldNormal = new Vec3();
	    this.worldNormalNeedsUpdate = true;

	    this.boundingSphereRadius = Number.MAX_VALUE;
	}
	Plane.prototype = new Shape();
	Plane.prototype.constructor = Plane;

	Plane.prototype.computeWorldNormal = function(quat){
	    var n = this.worldNormal;
	    n.set(0,0,1);
	    quat.vmult(n,n);
	    this.worldNormalNeedsUpdate = false;
	};

	Plane.prototype.calculateLocalInertia = function(mass,target){
	    target = target || new Vec3();
	    return target;
	};

	Plane.prototype.volume = function(){
	    return Number.MAX_VALUE; // The plane is infinite...
	};

	var tempNormal = new Vec3();
	Plane.prototype.calculateWorldAABB = function(pos, quat, min, max){
	    // The plane AABB is infinite, except if the normal is pointing along any axis
	    tempNormal.set(0,0,1); // Default plane normal is z
	    quat.vmult(tempNormal,tempNormal);
	    var maxVal = Number.MAX_VALUE;
	    min.set(-maxVal, -maxVal, -maxVal);
	    max.set(maxVal, maxVal, maxVal);

	    if(tempNormal.x === 1){ max.x = pos.x; }
	    if(tempNormal.y === 1){ max.y = pos.y; }
	    if(tempNormal.z === 1){ max.z = pos.z; }

	    if(tempNormal.x === -1){ min.x = pos.x; }
	    if(tempNormal.y === -1){ min.y = pos.y; }
	    if(tempNormal.z === -1){ min.z = pos.z; }
	};

	Plane.prototype.updateBoundingSphereRadius = function(){
	    this.boundingSphereRadius = Number.MAX_VALUE;
	};
	},{"../math/Vec3":30,"./Shape":43}],43:[function(_dereq_,module,exports){
	module.exports = Shape;

	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Material = _dereq_('../material/Material');

	/**
	 * Base class for shapes
	 * @class Shape
	 * @constructor
	 * @author schteppe
	 * @todo Should have a mechanism for caching bounding sphere radius instead of calculating it each time
	 */
	function Shape(){

	    /**
	     * Identifyer of the Shape.
	     * @property {number} id
	     */
	    this.id = Shape.idCounter++;

	    /**
	     * The type of this shape. Must be set to an int > 0 by subclasses.
	     * @property type
	     * @type {Number}
	     * @see Shape.types
	     */
	    this.type = 0;

	    /**
	     * The local bounding sphere radius of this shape.
	     * @property {Number} boundingSphereRadius
	     */
	    this.boundingSphereRadius = 0;

	    /**
	     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
	     * @property {boolean} collisionResponse
	     */
	    this.collisionResponse = true;

	    /**
	     * @property {Material} material
	     */
	    this.material = null;
	}
	Shape.prototype.constructor = Shape;

	/**
	 * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius
	 * @method updateBoundingSphereRadius
	 * @return {Number}
	 */
	Shape.prototype.updateBoundingSphereRadius = function(){
	    throw "computeBoundingSphereRadius() not implemented for shape type "+this.type;
	};

	/**
	 * Get the volume of this shape
	 * @method volume
	 * @return {Number}
	 */
	Shape.prototype.volume = function(){
	    throw "volume() not implemented for shape type "+this.type;
	};

	/**
	 * Calculates the inertia in the local frame for this shape.
	 * @method calculateLocalInertia
	 * @return {Vec3}
	 * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
	 */
	Shape.prototype.calculateLocalInertia = function(mass,target){
	    throw "calculateLocalInertia() not implemented for shape type "+this.type;
	};

	Shape.idCounter = 0;

	/**
	 * The available shape types.
	 * @static
	 * @property types
	 * @type {Object}
	 */
	Shape.types = {
	    SPHERE:1,
	    PLANE:2,
	    BOX:4,
	    COMPOUND:8,
	    CONVEXPOLYHEDRON:16,
	    HEIGHTFIELD:32,
	    PARTICLE:64,
	    CYLINDER:128,
	    TRIMESH:256
	};


	},{"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"./Shape":43}],44:[function(_dereq_,module,exports){
	module.exports = Sphere;

	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');

	/**
	 * Spherical shape
	 * @class Sphere
	 * @constructor
	 * @extends Shape
	 * @param {Number} radius The radius of the sphere, a non-negative number.
	 * @author schteppe / http://github.com/schteppe
	 */
	function Sphere(radius){
	    Shape.call(this);

	    /**
	     * @property {Number} radius
	     */
	    this.radius = radius!==undefined ? Number(radius) : 1.0;
	    this.type = Shape.types.SPHERE;

	    if(this.radius < 0){
	        throw new Error('The sphere radius cannot be negative.');
	    }

	    this.updateBoundingSphereRadius();
	}
	Sphere.prototype = new Shape();
	Sphere.prototype.constructor = Sphere;

	Sphere.prototype.calculateLocalInertia = function(mass,target){
	    target = target || new Vec3();
	    var I = 2.0*mass*this.radius*this.radius/5.0;
	    target.x = I;
	    target.y = I;
	    target.z = I;
	    return target;
	};

	Sphere.prototype.volume = function(){
	    return 4.0 * Math.PI * this.radius / 3.0;
	};

	Sphere.prototype.updateBoundingSphereRadius = function(){
	    this.boundingSphereRadius = this.radius;
	};

	Sphere.prototype.calculateWorldAABB = function(pos,quat,min,max){
	    var r = this.radius;
	    var axes = ['x','y','z'];
	    for(var i=0; i<axes.length; i++){
	        var ax = axes[i];
	        min[ax] = pos[ax] - r;
	        max[ax] = pos[ax] + r;
	    }
	};

	},{"../math/Vec3":30,"./Shape":43}],45:[function(_dereq_,module,exports){
	module.exports = Trimesh;

	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Transform = _dereq_('../math/Transform');
	var AABB = _dereq_('../collision/AABB');
	var Octree = _dereq_('../utils/Octree');

	/**
	 * @class Trimesh
	 * @constructor
	 * @param {array} vertices
	 * @param {array} indices
	 * @extends Shape
	 * @example
	 *     // How to make a mesh with a single triangle
	 *     var vertices = [
	 *         0, 0, 0, // vertex 0
	 *         1, 0, 0, // vertex 1
	 *         0, 1, 0  // vertex 2
	 *     ];
	 *     var indices = [
	 *         0, 1, 2  // triangle 0
	 *     ];
	 *     var trimeshShape = new Trimesh(vertices, indices);
	 */
	function Trimesh(vertices, indices) {
	    Shape.call(this);
	    this.type = Shape.types.TRIMESH;

	    /**
	     * @property vertices
	     * @type {Array}
	     */
	    this.vertices = new Float32Array(vertices);

	    /**
	     * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
	     * @property indices
	     * @type {Array}
	     */
	    this.indices = new Int16Array(indices);

	    /**
	     * The normals data.
	     * @property normals
	     * @type {Array}
	     */
	    this.normals = new Float32Array(indices.length);

	    /**
	     * The local AABB of the mesh.
	     * @property aabb
	     * @type {Array}
	     */
	    this.aabb = new AABB();

	    /**
	     * References to vertex pairs, making up all unique edges in the trimesh.
	     * @property {array} edges
	     */
	    this.edges = null;

	    /**
	     * Local scaling of the mesh. Use .setScale() to set it.
	     * @property {Vec3} scale
	     */
	    this.scale = new Vec3(1, 1, 1);

	    /**
	     * The indexed triangles. Use .updateTree() to update it.
	     * @property {Octree} tree
	     */
	    this.tree = new Octree();

	    this.updateEdges();
	    this.updateNormals();
	    this.updateAABB();
	    this.updateBoundingSphereRadius();
	    this.updateTree();
	}
	Trimesh.prototype = new Shape();
	Trimesh.prototype.constructor = Trimesh;

	var computeNormals_n = new Vec3();

	/**
	 * @method updateTree
	 */
	Trimesh.prototype.updateTree = function(){
	    var tree = this.tree;

	    tree.reset();
	    tree.aabb.copy(this.aabb);
	    var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled
	    tree.aabb.lowerBound.x *= 1 / scale.x;
	    tree.aabb.lowerBound.y *= 1 / scale.y;
	    tree.aabb.lowerBound.z *= 1 / scale.z;
	    tree.aabb.upperBound.x *= 1 / scale.x;
	    tree.aabb.upperBound.y *= 1 / scale.y;
	    tree.aabb.upperBound.z *= 1 / scale.z;

	    // Insert all triangles
	    var triangleAABB = new AABB();
	    var a = new Vec3();
	    var b = new Vec3();
	    var c = new Vec3();
	    var points = [a, b, c];
	    for (var i = 0; i < this.indices.length / 3; i++) {
	        //this.getTriangleVertices(i, a, b, c);

	        // Get unscaled triangle verts
	        var i3 = i * 3;
	        this._getUnscaledVertex(this.indices[i3], a);
	        this._getUnscaledVertex(this.indices[i3 + 1], b);
	        this._getUnscaledVertex(this.indices[i3 + 2], c);

	        triangleAABB.setFromPoints(points);
	        tree.insert(triangleAABB, i);
	    }
	    tree.removeEmptyNodes();
	};

	var unscaledAABB = new AABB();

	/**
	 * Get triangles in a local AABB from the trimesh.
	 * @method getTrianglesInAABB
	 * @param  {AABB} aabb
	 * @param  {array} result An array of integers, referencing the queried triangles.
	 */
	Trimesh.prototype.getTrianglesInAABB = function(aabb, result){
	    unscaledAABB.copy(aabb);

	    // Scale it to local
	    var scale = this.scale;
	    var isx = scale.x;
	    var isy = scale.y;
	    var isz = scale.z;
	    var l = unscaledAABB.lowerBound;
	    var u = unscaledAABB.upperBound;
	    l.x /= isx;
	    l.y /= isy;
	    l.z /= isz;
	    u.x /= isx;
	    u.y /= isy;
	    u.z /= isz;

	    return this.tree.aabbQuery(unscaledAABB, result);
	};

	/**
	 * @method setScale
	 * @param {Vec3} scale
	 */
	Trimesh.prototype.setScale = function(scale){
	    var wasUniform = this.scale.x === this.scale.y === this.scale.z;
	    var isUniform = scale.x === scale.y === scale.z;

	    if(!(wasUniform && isUniform)){
	        // Non-uniform scaling. Need to update normals.
	        this.updateNormals();
	    }
	    this.scale.copy(scale);
	    this.updateAABB();
	    this.updateBoundingSphereRadius();
	};

	/**
	 * Compute the normals of the faces. Will save in the .normals array.
	 * @method updateNormals
	 */
	Trimesh.prototype.updateNormals = function(){
	    var n = computeNormals_n;

	    // Generate normals
	    var normals = this.normals;
	    for(var i=0; i < this.indices.length / 3; i++){
	        var i3 = i * 3;

	        var a = this.indices[i3],
	            b = this.indices[i3 + 1],
	            c = this.indices[i3 + 2];

	        this.getVertex(a, va);
	        this.getVertex(b, vb);
	        this.getVertex(c, vc);

	        Trimesh.computeNormal(vb, va, vc, n);

	        normals[i3] = n.x;
	        normals[i3 + 1] = n.y;
	        normals[i3 + 2] = n.z;
	    }
	};

	/**
	 * Update the .edges property
	 * @method updateEdges
	 */
	Trimesh.prototype.updateEdges = function(){
	    var edges = {};
	    var add = function(indexA, indexB){
	        var key = a < b ? a + '_' + b : b + '_' + a;
	        edges[key] = true;
	    };
	    for(var i=0; i < this.indices.length / 3; i++){
	        var i3 = i * 3;
	        var a = this.indices[i3],
	            b = this.indices[i3 + 1],
	            c = this.indices[i3 + 2];
	        add(a,b);
	        add(b,c);
	        add(c,a);
	    }
	    var keys = Object.keys(edges);
	    this.edges = new Int16Array(keys.length * 2);
	    for (var i = 0; i < keys.length; i++) {
	        var indices = keys[i].split('_');
	        this.edges[2 * i] = parseInt(indices[0], 10);
	        this.edges[2 * i + 1] = parseInt(indices[1], 10);
	    }
	};

	/**
	 * Get an edge vertex
	 * @method getEdgeVertex
	 * @param  {number} edgeIndex
	 * @param  {number} firstOrSecond 0 or 1, depending on which one of the vertices you need.
	 * @param  {Vec3} vertexStore Where to store the result
	 */
	Trimesh.prototype.getEdgeVertex = function(edgeIndex, firstOrSecond, vertexStore){
	    var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
	    this.getVertex(vertexIndex, vertexStore);
	};

	var getEdgeVector_va = new Vec3();
	var getEdgeVector_vb = new Vec3();

	/**
	 * Get a vector along an edge.
	 * @method getEdgeVector
	 * @param  {number} edgeIndex
	 * @param  {Vec3} vectorStore
	 */
	Trimesh.prototype.getEdgeVector = function(edgeIndex, vectorStore){
	    var va = getEdgeVector_va;
	    var vb = getEdgeVector_vb;
	    this.getEdgeVertex(edgeIndex, 0, va);
	    this.getEdgeVertex(edgeIndex, 1, vb);
	    vb.vsub(va, vectorStore);
	};

	/**
	 * Get face normal given 3 vertices
	 * @static
	 * @method computeNormal
	 * @param {Vec3} va
	 * @param {Vec3} vb
	 * @param {Vec3} vc
	 * @param {Vec3} target
	 */
	var cb = new Vec3();
	var ab = new Vec3();
	Trimesh.computeNormal = function ( va, vb, vc, target ) {
	    vb.vsub(va,ab);
	    vc.vsub(vb,cb);
	    cb.cross(ab,target);
	    if ( !target.isZero() ) {
	        target.normalize();
	    }
	};

	var va = new Vec3();
	var vb = new Vec3();
	var vc = new Vec3();

	/**
	 * Get vertex i.
	 * @method getVertex
	 * @param  {number} i
	 * @param  {Vec3} out
	 * @return {Vec3} The "out" vector object
	 */
	Trimesh.prototype.getVertex = function(i, out){
	    var scale = this.scale;
	    this._getUnscaledVertex(i, out);
	    out.x *= scale.x;
	    out.y *= scale.y;
	    out.z *= scale.z;
	    return out;
	};

	/**
	 * Get raw vertex i
	 * @private
	 * @method _getUnscaledVertex
	 * @param  {number} i
	 * @param  {Vec3} out
	 * @return {Vec3} The "out" vector object
	 */
	Trimesh.prototype._getUnscaledVertex = function(i, out){
	    var i3 = i * 3;
	    var vertices = this.vertices;
	    return out.set(
	        vertices[i3],
	        vertices[i3 + 1],
	        vertices[i3 + 2]
	    );
	};

	/**
	 * Get a vertex from the trimesh,transformed by the given position and quaternion.
	 * @method getWorldVertex
	 * @param  {number} i
	 * @param  {Vec3} pos
	 * @param  {Quaternion} quat
	 * @param  {Vec3} out
	 * @return {Vec3} The "out" vector object
	 */
	Trimesh.prototype.getWorldVertex = function(i, pos, quat, out){
	    this.getVertex(i, out);
	    Transform.pointToWorldFrame(pos, quat, out, out);
	    return out;
	};

	/**
	 * Get the three vertices for triangle i.
	 * @method getTriangleVertices
	 * @param  {number} i
	 * @param  {Vec3} a
	 * @param  {Vec3} b
	 * @param  {Vec3} c
	 */
	Trimesh.prototype.getTriangleVertices = function(i, a, b, c){
	    var i3 = i * 3;
	    this.getVertex(this.indices[i3], a);
	    this.getVertex(this.indices[i3 + 1], b);
	    this.getVertex(this.indices[i3 + 2], c);
	};

	/**
	 * Compute the normal of triangle i.
	 * @method getNormal
	 * @param  {Number} i
	 * @param  {Vec3} target
	 * @return {Vec3} The "target" vector object
	 */
	Trimesh.prototype.getNormal = function(i, target){
	    var i3 = i * 3;
	    return target.set(
	        this.normals[i3],
	        this.normals[i3 + 1],
	        this.normals[i3 + 2]
	    );
	};

	var cli_aabb = new AABB();

	/**
	 * @method calculateLocalInertia
	 * @param  {Number} mass
	 * @param  {Vec3} target
	 * @return {Vec3} The "target" vector object
	 */
	Trimesh.prototype.calculateLocalInertia = function(mass,target){
	    // Approximate with box inertia
	    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
	    this.computeLocalAABB(cli_aabb);
	    var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x,
	        y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y,
	        z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
	    return target.set(
	        1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z ),
	        1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z ),
	        1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x )
	    );
	};

	var computeLocalAABB_worldVert = new Vec3();

	/**
	 * Compute the local AABB for the trimesh
	 * @method computeLocalAABB
	 * @param  {AABB} aabb
	 */
	Trimesh.prototype.computeLocalAABB = function(aabb){
	    var l = aabb.lowerBound,
	        u = aabb.upperBound,
	        n = this.vertices.length,
	        vertices = this.vertices,
	        v = computeLocalAABB_worldVert;

	    this.getVertex(0, v);
	    l.copy(v);
	    u.copy(v);

	    for(var i=0; i !== n; i++){
	        this.getVertex(i, v);

	        if(v.x < l.x){
	            l.x = v.x;
	        } else if(v.x > u.x){
	            u.x = v.x;
	        }

	        if(v.y < l.y){
	            l.y = v.y;
	        } else if(v.y > u.y){
	            u.y = v.y;
	        }

	        if(v.z < l.z){
	            l.z = v.z;
	        } else if(v.z > u.z){
	            u.z = v.z;
	        }
	    }
	};


	/**
	 * Update the .aabb property
	 * @method updateAABB
	 */
	Trimesh.prototype.updateAABB = function(){
	    this.computeLocalAABB(this.aabb);
	};

	/**
	 * Will update the .boundingSphereRadius property
	 * @method updateBoundingSphereRadius
	 */
	Trimesh.prototype.updateBoundingSphereRadius = function(){
	    // Assume points are distributed with local (0,0,0) as center
	    var max2 = 0;
	    var vertices = this.vertices;
	    var v = new Vec3();
	    for(var i=0, N=vertices.length / 3; i !== N; i++) {
	        this.getVertex(i, v);
	        var norm2 = v.norm2();
	        if(norm2 > max2){
	            max2 = norm2;
	        }
	    }
	    this.boundingSphereRadius = Math.sqrt(max2);
	};

	var tempWorldVertex = new Vec3();
	var calculateWorldAABB_frame = new Transform();
	var calculateWorldAABB_aabb = new AABB();

	/**
	 * @method calculateWorldAABB
	 * @param {Vec3}        pos
	 * @param {Quaternion}  quat
	 * @param {Vec3}        min
	 * @param {Vec3}        max
	 */
	Trimesh.prototype.calculateWorldAABB = function(pos,quat,min,max){
	    /*
	    var n = this.vertices.length / 3,
	        verts = this.vertices;
	    var minx,miny,minz,maxx,maxy,maxz;

	    var v = tempWorldVertex;
	    for(var i=0; i<n; i++){
	        this.getVertex(i, v);
	        quat.vmult(v, v);
	        pos.vadd(v, v);
	        if (v.x < minx || minx===undefined){
	            minx = v.x;
	        } else if(v.x > maxx || maxx===undefined){
	            maxx = v.x;
	        }

	        if (v.y < miny || miny===undefined){
	            miny = v.y;
	        } else if(v.y > maxy || maxy===undefined){
	            maxy = v.y;
	        }

	        if (v.z < minz || minz===undefined){
	            minz = v.z;
	        } else if(v.z > maxz || maxz===undefined){
	            maxz = v.z;
	        }
	    }
	    min.set(minx,miny,minz);
	    max.set(maxx,maxy,maxz);
	    */

	    // Faster approximation using local AABB
	    var frame = calculateWorldAABB_frame;
	    var result = calculateWorldAABB_aabb;
	    frame.position = pos;
	    frame.quaternion = quat;
	    this.aabb.toWorldFrame(frame, result);
	    min.copy(result.lowerBound);
	    max.copy(result.upperBound);
	};

	/**
	 * Get approximate volume
	 * @method volume
	 * @return {Number}
	 */
	Trimesh.prototype.volume = function(){
	    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
	};

	/**
	 * Create a Trimesh instance, shaped as a torus.
	 * @static
	 * @method createTorus
	 * @param  {number} [radius=1]
	 * @param  {number} [tube=0.5]
	 * @param  {number} [radialSegments=8]
	 * @param  {number} [tubularSegments=6]
	 * @param  {number} [arc=6.283185307179586]
	 * @return {Trimesh} A torus
	 */
	Trimesh.createTorus = function (radius, tube, radialSegments, tubularSegments, arc) {
	    radius = radius || 1;
	    tube = tube || 0.5;
	    radialSegments = radialSegments || 8;
	    tubularSegments = tubularSegments || 6;
	    arc = arc || Math.PI * 2;

	    var vertices = [];
	    var indices = [];

	    for ( var j = 0; j <= radialSegments; j ++ ) {
	        for ( var i = 0; i <= tubularSegments; i ++ ) {
	            var u = i / tubularSegments * arc;
	            var v = j / radialSegments * Math.PI * 2;

	            var x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
	            var y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
	            var z = tube * Math.sin( v );

	            vertices.push( x, y, z );
	        }
	    }

	    for ( var j = 1; j <= radialSegments; j ++ ) {
	        for ( var i = 1; i <= tubularSegments; i ++ ) {
	            var a = ( tubularSegments + 1 ) * j + i - 1;
	            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
	            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
	            var d = ( tubularSegments + 1 ) * j + i;

	            indices.push(a, b, d);
	            indices.push(b, c, d);
	        }
	    }

	    return new Trimesh(vertices, indices);
	};

	},{"../collision/AABB":3,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../utils/Octree":50,"./Shape":43}],46:[function(_dereq_,module,exports){
	module.exports = GSSolver;

	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Solver = _dereq_('./Solver');

	/**
	 * Constraint equation Gauss-Seidel solver.
	 * @class GSSolver
	 * @constructor
	 * @todo The spook parameters should be specified for each constraint, not globally.
	 * @author schteppe / https://github.com/schteppe
	 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
	 * @extends Solver
	 */
	function GSSolver(){
	    Solver.call(this);

	    /**
	     * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
	     * @property iterations
	     * @type {Number}
	     * @todo write more about solver and iterations in the wiki
	     */
	    this.iterations = 10;

	    /**
	     * When tolerance is reached, the system is assumed to be converged.
	     * @property tolerance
	     * @type {Number}
	     */
	    this.tolerance = 1e-7;
	}
	GSSolver.prototype = new Solver();

	var GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.
	var GSSolver_solve_invCs = [];
	var GSSolver_solve_Bs = [];
	GSSolver.prototype.solve = function(dt,world){
	    var iter = 0,
	        maxIter = this.iterations,
	        tolSquared = this.tolerance*this.tolerance,
	        equations = this.equations,
	        Neq = equations.length,
	        bodies = world.bodies,
	        Nbodies = bodies.length,
	        h = dt,
	        q, B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj;

	    // Update solve mass
	    if(Neq !== 0){
	        for(var i=0; i!==Nbodies; i++){
	            bodies[i].updateSolveMassProperties();
	        }
	    }

	    // Things that does not change during iteration can be computed once
	    var invCs = GSSolver_solve_invCs,
	        Bs = GSSolver_solve_Bs,
	        lambda = GSSolver_solve_lambda;
	    invCs.length = Neq;
	    Bs.length = Neq;
	    lambda.length = Neq;
	    for(var i=0; i!==Neq; i++){
	        var c = equations[i];
	        lambda[i] = 0.0;
	        Bs[i] = c.computeB(h);
	        invCs[i] = 1.0 / c.computeC();
	    }

	    if(Neq !== 0){

	        // Reset vlambda
	        for(var i=0; i!==Nbodies; i++){
	            var b=bodies[i],
	                vlambda=b.vlambda,
	                wlambda=b.wlambda;
	            vlambda.set(0,0,0);
	            if(wlambda){
	                wlambda.set(0,0,0);
	            }
	        }

	        // Iterate over equations
	        for(iter=0; iter!==maxIter; iter++){

	            // Accumulate the total error for each iteration.
	            deltalambdaTot = 0.0;

	            for(var j=0; j!==Neq; j++){

	                var c = equations[j];

	                // Compute iteration
	                B = Bs[j];
	                invC = invCs[j];
	                lambdaj = lambda[j];
	                GWlambda = c.computeGWlambda();
	                deltalambda = invC * ( B - GWlambda - c.eps * lambdaj );

	                // Clamp if we are not within the min/max interval
	                if(lambdaj + deltalambda < c.minForce){
	                    deltalambda = c.minForce - lambdaj;
	                } else if(lambdaj + deltalambda > c.maxForce){
	                    deltalambda = c.maxForce - lambdaj;
	                }
	                lambda[j] += deltalambda;

	                deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

	                c.addToWlambda(deltalambda);
	            }

	            // If the total error is small enough - stop iterate
	            if(deltalambdaTot*deltalambdaTot < tolSquared){
	                break;
	            }
	        }

	        // Add result to velocity
	        for(var i=0; i!==Nbodies; i++){
	            var b=bodies[i],
	                v=b.velocity,
	                w=b.angularVelocity;
	            v.vadd(b.vlambda, v);
	            if(w){
	                w.vadd(b.wlambda, w);
	            }
	        }
	    }

	    return iter;
	};

	},{"../math/Quaternion":28,"../math/Vec3":30,"./Solver":47}],47:[function(_dereq_,module,exports){
	module.exports = Solver;

	/**
	 * Constraint equation solver base class.
	 * @class Solver
	 * @constructor
	 * @author schteppe / https://github.com/schteppe
	 */
	function Solver(){
	    /**
	     * All equations to be solved
	     * @property {Array} equations
	     */
	    this.equations = [];
	}

	/**
	 * Should be implemented in subclasses!
	 * @method solve
	 * @param  {Number} dt
	 * @param  {World} world
	 */
	Solver.prototype.solve = function(dt,world){
	    // Should return the number of iterations done!
	    return 0;
	};

	/**
	 * Add an equation
	 * @method addEquation
	 * @param {Equation} eq
	 */
	Solver.prototype.addEquation = function(eq){
	    if (eq.enabled) {
	        this.equations.push(eq);
	    }
	};

	/**
	 * Remove an equation
	 * @method removeEquation
	 * @param {Equation} eq
	 */
	Solver.prototype.removeEquation = function(eq){
	    var eqs = this.equations;
	    var i = eqs.indexOf(eq);
	    if(i !== -1){
	        eqs.splice(i,1);
	    }
	};

	/**
	 * Add all equations
	 * @method removeAllEquations
	 */
	Solver.prototype.removeAllEquations = function(){
	    this.equations.length = 0;
	};


	},{}],48:[function(_dereq_,module,exports){
	module.exports = SplitSolver;

	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Solver = _dereq_('./Solver');
	var Body = _dereq_('../objects/Body');

	/**
	 * Splits the equations into islands and solves them independently. Can improve performance.
	 * @class SplitSolver
	 * @constructor
	 * @extends Solver
	 * @param {Solver} subsolver
	 */
	function SplitSolver(subsolver){
	    Solver.call(this);
	    this.iterations = 10;
	    this.tolerance = 1e-7;
	    this.subsolver = subsolver;
	    this.nodes = [];
	    this.nodePool = [];

	    // Create needed nodes, reuse if possible
	    while(this.nodePool.length < 128){
	        this.nodePool.push(this.createNode());
	    }
	}
	SplitSolver.prototype = new Solver();

	// Returns the number of subsystems
	var SplitSolver_solve_nodes = []; // All allocated node objects
	var SplitSolver_solve_nodePool = []; // All allocated node objects
	var SplitSolver_solve_eqs = [];   // Temp array
	var SplitSolver_solve_bds = [];   // Temp array
	var SplitSolver_solve_dummyWorld = {bodies:[]}; // Temp object

	var STATIC = Body.STATIC;
	function getUnvisitedNode(nodes){
	    var Nnodes = nodes.length;
	    for(var i=0; i!==Nnodes; i++){
	        var node = nodes[i];
	        if(!node.visited && !(node.body.type & STATIC)){
	            return node;
	        }
	    }
	    return false;
	}

	var queue = [];
	function bfs(root,visitFunc,bds,eqs){
	    queue.push(root);
	    root.visited = true;
	    visitFunc(root,bds,eqs);
	    while(queue.length) {
	        var node = queue.pop();
	        // Loop over unvisited child nodes
	        var child;
	        while((child = getUnvisitedNode(node.children))) {
	            child.visited = true;
	            visitFunc(child,bds,eqs);
	            queue.push(child);
	        }
	    }
	}

	function visitFunc(node,bds,eqs){
	    bds.push(node.body);
	    var Neqs = node.eqs.length;
	    for(var i=0; i!==Neqs; i++){
	        var eq = node.eqs[i];
	        if(eqs.indexOf(eq) === -1){
	            eqs.push(eq);
	        }
	    }
	}

	SplitSolver.prototype.createNode = function(){
	    return { body:null, children:[], eqs:[], visited:false };
	};

	/**
	 * Solve the subsystems
	 * @method solve
	 * @param  {Number} dt
	 * @param  {World} world
	 */
	SplitSolver.prototype.solve = function(dt,world){
	    var nodes=SplitSolver_solve_nodes,
	        nodePool=this.nodePool,
	        bodies=world.bodies,
	        equations=this.equations,
	        Neq=equations.length,
	        Nbodies=bodies.length,
	        subsolver=this.subsolver;

	    // Create needed nodes, reuse if possible
	    while(nodePool.length < Nbodies){
	        nodePool.push(this.createNode());
	    }
	    nodes.length = Nbodies;
	    for (var i = 0; i < Nbodies; i++) {
	        nodes[i] = nodePool[i];
	    }

	    // Reset node values
	    for(var i=0; i!==Nbodies; i++){
	        var node = nodes[i];
	        node.body = bodies[i];
	        node.children.length = 0;
	        node.eqs.length = 0;
	        node.visited = false;
	    }
	    for(var k=0; k!==Neq; k++){
	        var eq=equations[k],
	            i=bodies.indexOf(eq.bi),
	            j=bodies.indexOf(eq.bj),
	            ni=nodes[i],
	            nj=nodes[j];
	        ni.children.push(nj);
	        ni.eqs.push(eq);
	        nj.children.push(ni);
	        nj.eqs.push(eq);
	    }

	    var child, n=0, eqs=SplitSolver_solve_eqs;

	    subsolver.tolerance = this.tolerance;
	    subsolver.iterations = this.iterations;

	    var dummyWorld = SplitSolver_solve_dummyWorld;
	    while((child = getUnvisitedNode(nodes))){
	        eqs.length = 0;
	        dummyWorld.bodies.length = 0;
	        bfs(child, visitFunc, dummyWorld.bodies, eqs);

	        var Neqs = eqs.length;

	        eqs = eqs.sort(sortById);

	        for(var i=0; i!==Neqs; i++){
	            subsolver.addEquation(eqs[i]);
	        }

	        var iter = subsolver.solve(dt,dummyWorld);
	        subsolver.removeAllEquations();
	        n++;
	    }

	    return n;
	};

	function sortById(a, b){
	    return b.id - a.id;
	}
	},{"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"./Solver":47}],49:[function(_dereq_,module,exports){
	/**
	 * Base class for objects that dispatches events.
	 * @class EventTarget
	 * @constructor
	 */
	var EventTarget = function () {

	};

	module.exports = EventTarget;

	EventTarget.prototype = {
	    constructor: EventTarget,

	    /**
	     * Add an event listener
	     * @method addEventListener
	     * @param  {String} type
	     * @param  {Function} listener
	     * @return {EventTarget} The self object, for chainability.
	     */
	    addEventListener: function ( type, listener ) {
	        if ( this._listeners === undefined ){ this._listeners = {}; }
	        var listeners = this._listeners;
	        if ( listeners[ type ] === undefined ) {
	            listeners[ type ] = [];
	        }
	        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	            listeners[ type ].push( listener );
	        }
	        return this;
	    },

	    /**
	     * Check if an event listener is added
	     * @method hasEventListener
	     * @param  {String} type
	     * @param  {Function} listener
	     * @return {Boolean}
	     */
	    hasEventListener: function ( type, listener ) {
	        if ( this._listeners === undefined ){ return false; }
	        var listeners = this._listeners;
	        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
	            return true;
	        }
	        return false;
	    },

	    /**
	     * Remove an event listener
	     * @method removeEventListener
	     * @param  {String} type
	     * @param  {Function} listener
	     * @return {EventTarget} The self object, for chainability.
	     */
	    removeEventListener: function ( type, listener ) {
	        if ( this._listeners === undefined ){ return this; }
	        var listeners = this._listeners;
	        if ( listeners[type] === undefined ){ return this; }
	        var index = listeners[ type ].indexOf( listener );
	        if ( index !== - 1 ) {
	            listeners[ type ].splice( index, 1 );
	        }
	        return this;
	    },

	    /**
	     * Emit an event.
	     * @method dispatchEvent
	     * @param  {Object} event
	     * @param  {String} event.type
	     * @return {EventTarget} The self object, for chainability.
	     */
	    dispatchEvent: function ( event ) {
	        if ( this._listeners === undefined ){ return this; }
	        var listeners = this._listeners;
	        var listenerArray = listeners[ event.type ];
	        if ( listenerArray !== undefined ) {
	            event.target = this;
	            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
	                listenerArray[ i ].call( this, event );
	            }
	        }
	        return this;
	    }
	};

	},{}],50:[function(_dereq_,module,exports){
	var AABB = _dereq_('../collision/AABB');
	var Vec3 = _dereq_('../math/Vec3');

	module.exports = Octree;

	/**
	 * @class OctreeNode
	 * @param {object} [options]
	 * @param {Octree} [options.root]
	 * @param {AABB} [options.aabb]
	 */
	function OctreeNode(options){
	    options = options || {};

	    /**
	     * The root node
	     * @property {OctreeNode} root
	     */
	    this.root = options.root || null;

	    /**
	     * Boundary of this node
	     * @property {AABB} aabb
	     */
	    this.aabb = options.aabb ? options.aabb.clone() : new AABB();

	    /**
	     * Contained data at the current node level.
	     * @property {Array} data
	     */
	    this.data = [];

	    /**
	     * Children to this node
	     * @property {Array} children
	     */
	    this.children = [];
	}

	/**
	 * @class Octree
	 * @param {AABB} aabb The total AABB of the tree
	 * @param {object} [options]
	 * @param {number} [options.maxDepth=8]
	 * @extends OctreeNode
	 */
	function Octree(aabb, options){
	    options = options || {};
	    options.root = null;
	    options.aabb = aabb;
	    OctreeNode.call(this, options);

	    /**
	     * Maximum subdivision depth
	     * @property {number} maxDepth
	     */
	    this.maxDepth = typeof(options.maxDepth) !== 'undefined' ? options.maxDepth : 8;
	}
	Octree.prototype = new OctreeNode();

	OctreeNode.prototype.reset = function(aabb, options){
	    this.children.length = this.data.length = 0;
	};

	/**
	 * Insert data into this node
	 * @method insert
	 * @param  {AABB} aabb
	 * @param  {object} elementData
	 * @return {boolean} True if successful, otherwise false
	 */
	OctreeNode.prototype.insert = function(aabb, elementData, level){
	    var nodeData = this.data;
	    level = level || 0;

	    // Ignore objects that do not belong in this node
	    if (!this.aabb.contains(aabb)){
	        return false; // object cannot be added
	    }

	    var children = this.children;

	    if(level < (this.maxDepth || this.root.maxDepth)){
	        // Subdivide if there are no children yet
	        var subdivided = false;
	        if (!children.length){
	            this.subdivide();
	            subdivided = true;
	        }

	        // add to whichever node will accept it
	        for (var i = 0; i !== 8; i++) {
	            if (children[i].insert(aabb, elementData, level + 1)){
	                return true;
	            }
	        }

	        if(subdivided){
	            // No children accepted! Might as well just remove em since they contain none
	            children.length = 0;
	        }
	    }

	    // Too deep, or children didnt want it. add it in current node
	    nodeData.push(elementData);

	    return true;
	};

	var halfDiagonal = new Vec3();

	/**
	 * Create 8 equally sized children nodes and put them in the .children array.
	 * @method subdivide
	 */
	OctreeNode.prototype.subdivide = function() {
	    var aabb = this.aabb;
	    var l = aabb.lowerBound;
	    var u = aabb.upperBound;

	    var children = this.children;

	    children.push(
	        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,0) }) }),
	        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,0) }) }),
	        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,0) }) }),
	        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,1) }) }),
	        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,1) }) }),
	        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,1) }) }),
	        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,1) }) }),
	        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,0) }) })
	    );

	    u.vsub(l, halfDiagonal);
	    halfDiagonal.scale(0.5, halfDiagonal);

	    var root = this.root || this;

	    for (var i = 0; i !== 8; i++) {
	        var child = children[i];

	        // Set current node as root
	        child.root = root;

	        // Compute bounds
	        var lowerBound = child.aabb.lowerBound;
	        lowerBound.x *= halfDiagonal.x;
	        lowerBound.y *= halfDiagonal.y;
	        lowerBound.z *= halfDiagonal.z;

	        lowerBound.vadd(l, lowerBound);

	        // Upper bound is always lower bound + halfDiagonal
	        lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
	    }
	};

	/**
	 * Get all data, potentially within an AABB
	 * @method aabbQuery
	 * @param  {AABB} aabb
	 * @param  {array} result
	 * @return {array} The "result" object
	 */
	OctreeNode.prototype.aabbQuery = function(aabb, result) {

	    var nodeData = this.data;

	    // abort if the range does not intersect this node
	    // if (!this.aabb.overlaps(aabb)){
	    //     return result;
	    // }

	    // Add objects at this level
	    // Array.prototype.push.apply(result, nodeData);

	    // Add child data
	    // @todo unwrap recursion into a queue / loop, that's faster in JS
	    var children = this.children;


	    // for (var i = 0, N = this.children.length; i !== N; i++) {
	    //     children[i].aabbQuery(aabb, result);
	    // }

	    var queue = [this];
	    while (queue.length) {
	        var node = queue.pop();
	        if (node.aabb.overlaps(aabb)){
	            Array.prototype.push.apply(result, node.data);
	        }
	        Array.prototype.push.apply(queue, node.children);
	    }

	    return result;
	};

	var tmpAABB = new AABB();

	/**
	 * Get all data, potentially intersected by a ray.
	 * @method rayQuery
	 * @param  {Ray} ray
	 * @param  {Transform} treeTransform
	 * @param  {array} result
	 * @return {array} The "result" object
	 */
	OctreeNode.prototype.rayQuery = function(ray, treeTransform, result) {

	    // Use aabb query for now.
	    // @todo implement real ray query which needs less lookups
	    ray.getAABB(tmpAABB);
	    tmpAABB.toLocalFrame(treeTransform, tmpAABB);
	    this.aabbQuery(tmpAABB, result);

	    return result;
	};

	/**
	 * @method removeEmptyNodes
	 */
	OctreeNode.prototype.removeEmptyNodes = function() {
	    var queue = [this];
	    while (queue.length) {
	        var node = queue.pop();
	        for (var i = node.children.length - 1; i >= 0; i--) {
	            if(!node.children[i].data.length){
	                node.children.splice(i, 1);
	            }
	        }
	        Array.prototype.push.apply(queue, node.children);
	    }
	};

	},{"../collision/AABB":3,"../math/Vec3":30}],51:[function(_dereq_,module,exports){
	module.exports = Pool;

	/**
	 * For pooling objects that can be reused.
	 * @class Pool
	 * @constructor
	 */
	function Pool(){
	    /**
	     * The pooled objects
	     * @property {Array} objects
	     */
	    this.objects = [];

	    /**
	     * Constructor of the objects
	     * @property {mixed} type
	     */
	    this.type = Object;
	}

	/**
	 * Release an object after use
	 * @method release
	 * @param {Object} obj
	 */
	Pool.prototype.release = function(){
	    var Nargs = arguments.length;
	    for(var i=0; i!==Nargs; i++){
	        this.objects.push(arguments[i]);
	    }
	};

	/**
	 * Get an object
	 * @method get
	 * @return {mixed}
	 */
	Pool.prototype.get = function(){
	    if(this.objects.length===0){
	        return this.constructObject();
	    } else {
	        return this.objects.pop();
	    }
	};

	/**
	 * Construct an object. Should be implmented in each subclass.
	 * @method constructObject
	 * @return {mixed}
	 */
	Pool.prototype.constructObject = function(){
	    throw new Error("constructObject() not implemented in this Pool subclass yet!");
	};

	},{}],52:[function(_dereq_,module,exports){
	module.exports = TupleDictionary;

	/**
	 * @class TupleDictionary
	 * @constructor
	 */
	function TupleDictionary() {

	    /**
	     * The data storage
	     * @property data
	     * @type {Object}
	     */
	    this.data = { keys:[] };
	}

	/**
	 * @method get
	 * @param  {Number} i
	 * @param  {Number} j
	 * @return {Number}
	 */
	TupleDictionary.prototype.get = function(i, j) {
	    if (i > j) {
	        // swap
	        var temp = j;
	        j = i;
	        i = temp;
	    }
	    return this.data[i+'-'+j];
	};

	/**
	 * @method set
	 * @param  {Number} i
	 * @param  {Number} j
	 * @param {Number} value
	 */
	TupleDictionary.prototype.set = function(i, j, value) {
	    if (i > j) {
	        var temp = j;
	        j = i;
	        i = temp;
	    }
	    var key = i+'-'+j;

	    // Check if key already exists
	    if(!this.get(i,j)){
	        this.data.keys.push(key);
	    }

	    this.data[key] = value;
	};

	/**
	 * @method reset
	 */
	TupleDictionary.prototype.reset = function() {
	    var data = this.data,
	        keys = data.keys;
	    while(keys.length > 0){
	        var key = keys.pop();
	        delete data[key];
	    }
	};

	},{}],53:[function(_dereq_,module,exports){
	function Utils(){}

	module.exports = Utils;

	/**
	 * Extend an options object with default values.
	 * @static
	 * @method defaults
	 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
	 * @param  {object} defaults An object containing default values.
	 * @return {object} The modified options object.
	 */
	Utils.defaults = function(options, defaults){
	    options = options || {};

	    for(var key in defaults){
	        if(!(key in options)){
	            options[key] = defaults[key];
	        }
	    }

	    return options;
	};

	},{}],54:[function(_dereq_,module,exports){
	module.exports = Vec3Pool;

	var Vec3 = _dereq_('../math/Vec3');
	var Pool = _dereq_('./Pool');

	/**
	 * @class Vec3Pool
	 * @constructor
	 * @extends Pool
	 */
	function Vec3Pool(){
	    Pool.call(this);
	    this.type = Vec3;
	}
	Vec3Pool.prototype = new Pool();

	/**
	 * Construct a vector
	 * @method constructObject
	 * @return {Vec3}
	 */
	Vec3Pool.prototype.constructObject = function(){
	    return new Vec3();
	};

	},{"../math/Vec3":30,"./Pool":51}],55:[function(_dereq_,module,exports){
	module.exports = Narrowphase;

	var AABB = _dereq_('../collision/AABB');
	var Shape = _dereq_('../shapes/Shape');
	var Ray = _dereq_('../collision/Ray');
	var Vec3 = _dereq_('../math/Vec3');
	var Transform = _dereq_('../math/Transform');
	var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');
	var Quaternion = _dereq_('../math/Quaternion');
	var Solver = _dereq_('../solver/Solver');
	var Vec3Pool = _dereq_('../utils/Vec3Pool');
	var ContactEquation = _dereq_('../equations/ContactEquation');
	var FrictionEquation = _dereq_('../equations/FrictionEquation');

	/**
	 * Helper class for the World. Generates ContactEquations.
	 * @class Narrowphase
	 * @constructor
	 * @todo Sphere-ConvexPolyhedron contacts
	 * @todo Contact reduction
	 * @todo  should move methods to prototype
	 */
	function Narrowphase(world){

	    /**
	     * Internal storage of pooled contact points.
	     * @property {Array} contactPointPool
	     */
	    this.contactPointPool = [];

	    this.frictionEquationPool = [];

	    this.result = [];
	    this.frictionResult = [];

	    /**
	     * Pooled vectors.
	     * @property {Vec3Pool} v3pool
	     */
	    this.v3pool = new Vec3Pool();

	    this.world = world;
	    this.currentContactMaterial = null;

	    /**
	     * @property {Boolean} enableFrictionReduction
	     */
	    this.enableFrictionReduction = false;
	}

	/**
	 * Make a contact object, by using the internal pool or creating a new one.
	 * @method createContactEquation
	 * @return {ContactEquation}
	 */
	Narrowphase.prototype.createContactEquation = function(bi, bj, si, sj, rsi, rsj){
	    var c;
	    if(this.contactPointPool.length){
	        c = this.contactPointPool.pop();
	        c.bi = bi;
	        c.bj = bj;
	    } else {
	        c = new ContactEquation(bi, bj);
	    }

	    c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

	    var cm = this.currentContactMaterial;

	    c.restitution = cm.restitution;

	    c.setSpookParams(
	        cm.contactEquationStiffness,
	        cm.contactEquationRelaxation,
	        this.world.dt
	    );

	    var matA = si.material || bi.material;
	    var matB = sj.material || bj.material;
	    if(matA && matB && matA.restitution >= 0 && matB.restitution >= 0){
	        c.restitution = matA.restitution * matB.restitution;
	    }

	    c.si = rsi || si;
	    c.sj = rsj || sj;

	    return c;
	};

	Narrowphase.prototype.createFrictionEquationsFromContact = function(contactEquation, outArray){
	    var bodyA = contactEquation.bi;
	    var bodyB = contactEquation.bj;
	    var shapeA = contactEquation.si;
	    var shapeB = contactEquation.sj;

	    var world = this.world;
	    var cm = this.currentContactMaterial;

	    // If friction or restitution were specified in the material, use them
	    var friction = cm.friction;
	    var matA = shapeA.material || bodyA.material;
	    var matB = shapeB.material || bodyB.material;
	    if(matA && matB && matA.friction >= 0 && matB.friction >= 0){
	        friction = matA.friction * matB.friction;
	    }

	    if(friction > 0){

	        // Create 2 tangent equations
	        var mug = friction * world.gravity.length();
	        var reducedMass = (bodyA.invMass + bodyB.invMass);
	        if(reducedMass > 0){
	            reducedMass = 1/reducedMass;
	        }
	        var pool = this.frictionEquationPool;
	        var c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);
	        var c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);

	        c1.bi = c2.bi = bodyA;
	        c1.bj = c2.bj = bodyB;
	        c1.minForce = c2.minForce = -mug*reducedMass;
	        c1.maxForce = c2.maxForce = mug*reducedMass;

	        // Copy over the relative vectors
	        c1.ri.copy(contactEquation.ri);
	        c1.rj.copy(contactEquation.rj);
	        c2.ri.copy(contactEquation.ri);
	        c2.rj.copy(contactEquation.rj);

	        // Construct tangents
	        contactEquation.ni.tangents(c1.t, c2.t);

	        // Set spook params
	        c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
	        c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);

	        c1.enabled = c2.enabled = contactEquation.enabled;

	        outArray.push(c1, c2);

	        return true;
	    }

	    return false;
	};

	var averageNormal = new Vec3();
	var averageContactPointA = new Vec3();
	var averageContactPointB = new Vec3();

	// Take the average N latest contact point on the plane.
	Narrowphase.prototype.createFrictionFromAverage = function(numContacts){
	    // The last contactEquation
	    var c = this.result[this.result.length - 1];

	    // Create the result: two "average" friction equations
	    if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
	        return;
	    }

	    var f1 = this.frictionResult[this.frictionResult.length - 2];
	    var f2 = this.frictionResult[this.frictionResult.length - 1];

	    averageNormal.setZero();
	    averageContactPointA.setZero();
	    averageContactPointB.setZero();

	    var bodyA = c.bi;
	    var bodyB = c.bj;
	    for(var i=0; i!==numContacts; i++){
	        c = this.result[this.result.length - 1 - i];
	        if(c.bodyA !== bodyA){
	            averageNormal.vadd(c.ni, averageNormal); // vec2.add(eq.t, eq.t, c.normalA);
	            averageContactPointA.vadd(c.ri, averageContactPointA); // vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
	            averageContactPointB.vadd(c.rj, averageContactPointB);
	        } else {
	            averageNormal.vsub(c.ni, averageNormal); // vec2.sub(eq.t, eq.t, c.normalA);
	            averageContactPointA.vadd(c.rj, averageContactPointA); // vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
	            averageContactPointB.vadd(c.ri, averageContactPointB);
	        }
	    }

	    var invNumContacts = 1 / numContacts;
	    averageContactPointA.scale(invNumContacts, f1.ri); // vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
	    averageContactPointB.scale(invNumContacts, f1.rj); // vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
	    f2.ri.copy(f1.ri); // Should be the same
	    f2.rj.copy(f1.rj);
	    averageNormal.normalize();
	    averageNormal.tangents(f1.t, f2.t);
	    // return eq;
	};


	var tmpVec1 = new Vec3();
	var tmpVec2 = new Vec3();
	var tmpQuat1 = new Quaternion();
	var tmpQuat2 = new Quaternion();

	/**
	 * Generate all contacts between a list of body pairs
	 * @method getContacts
	 * @param {array} p1 Array of body indices
	 * @param {array} p2 Array of body indices
	 * @param {World} world
	 * @param {array} result Array to store generated contacts
	 * @param {array} oldcontacts Optional. Array of reusable contact objects
	 */
	Narrowphase.prototype.getContacts = function(p1, p2, world, result, oldcontacts, frictionResult, frictionPool){
	    // Save old contact objects
	    this.contactPointPool = oldcontacts;
	    this.frictionEquationPool = frictionPool;
	    this.result = result;
	    this.frictionResult = frictionResult;

	    var qi = tmpQuat1;
	    var qj = tmpQuat2;
	    var xi = tmpVec1;
	    var xj = tmpVec2;

	    for(var k=0, N=p1.length; k!==N; k++){

	        // Get current collision bodies
	        var bi = p1[k],
	            bj = p2[k];

	        // Get contact material
	        var bodyContactMaterial = null;
	        if(bi.material && bj.material){
	            bodyContactMaterial = world.getContactMaterial(bi.material,bj.material) || null;
	        }

	        for (var i = 0; i < bi.shapes.length; i++) {
	            bi.quaternion.mult(bi.shapeOrientations[i], qi);
	            bi.quaternion.vmult(bi.shapeOffsets[i], xi);
	            xi.vadd(bi.position, xi);
	            var si = bi.shapes[i];

	            for (var j = 0; j < bj.shapes.length; j++) {

	                // Compute world transform of shapes
	                bj.quaternion.mult(bj.shapeOrientations[j], qj);
	                bj.quaternion.vmult(bj.shapeOffsets[j], xj);
	                xj.vadd(bj.position, xj);
	                var sj = bj.shapes[j];

	                if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
	                    continue;
	                }

	                // Get collision material
	                var shapeContactMaterial = null;
	                if(si.material && sj.material){
	                    shapeContactMaterial = world.getContactMaterial(si.material,sj.material) || null;
	                }

	                this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial;

	                // Get contacts
	                var resolver = this[si.type | sj.type];
	                if(resolver){
	                    if (si.type < sj.type) {
	                        resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj);
	                    } else {
	                        resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj);
	                    }
	                }
	            }
	        }
	    }
	};

	var numWarnings = 0;
	var maxWarnings = 10;

	function warn(msg){
	    if(numWarnings > maxWarnings){
	        return;
	    }

	    numWarnings++;

	    console.warn(msg);
	}

	Narrowphase.prototype[Shape.types.BOX | Shape.types.BOX] =
	Narrowphase.prototype.boxBox = function(si,sj,xi,xj,qi,qj,bi,bj){
	    si.convexPolyhedronRepresentation.material = si.material;
	    sj.convexPolyhedronRepresentation.material = sj.material;
	    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
	    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
	    this.convexConvex(si.convexPolyhedronRepresentation,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj);
	};

	Narrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] =
	Narrowphase.prototype.boxConvex = function(si,sj,xi,xj,qi,qj,bi,bj){
	    si.convexPolyhedronRepresentation.material = si.material;
	    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
	    this.convexConvex(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
	};

	Narrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] =
	Narrowphase.prototype.boxParticle = function(si,sj,xi,xj,qi,qj,bi,bj){
	    si.convexPolyhedronRepresentation.material = si.material;
	    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
	    this.convexParticle(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
	};

	/**
	 * @method sphereSphere
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.SPHERE] =
	Narrowphase.prototype.sphereSphere = function(si,sj,xi,xj,qi,qj,bi,bj){
	    // We will have only one contact in this case
	    var r = this.createContactEquation(bi,bj,si,sj);

	    // Contact normal
	    xj.vsub(xi, r.ni);
	    r.ni.normalize();

	    // Contact point locations
	    r.ri.copy(r.ni);
	    r.rj.copy(r.ni);
	    r.ri.mult(si.radius, r.ri);
	    r.rj.mult(-sj.radius, r.rj);

	    r.ri.vadd(xi, r.ri);
	    r.ri.vsub(bi.position, r.ri);

	    r.rj.vadd(xj, r.rj);
	    r.rj.vsub(bj.position, r.rj);

	    this.result.push(r);

	    this.createFrictionEquationsFromContact(r, this.frictionResult);
	};

	/**
	 * @method planeTrimesh
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	var planeTrimesh_normal = new Vec3();
	var planeTrimesh_relpos = new Vec3();
	var planeTrimesh_projected = new Vec3();
	Narrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] =
	Narrowphase.prototype.planeTrimesh = function(
	    planeShape,
	    trimeshShape,
	    planePos,
	    trimeshPos,
	    planeQuat,
	    trimeshQuat,
	    planeBody,
	    trimeshBody
	){
	    // Make contacts!
	    var v = new Vec3();

	    var normal = planeTrimesh_normal;
	    normal.set(0,0,1);
	    planeQuat.vmult(normal,normal); // Turn normal according to plane

	    for(var i=0; i<trimeshShape.vertices.length / 3; i++){

	        // Get world vertex from trimesh
	        trimeshShape.getVertex(i, v);

	        // Safe up
	        var v2 = new Vec3();
	        v2.copy(v);
	        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);

	        // Check plane side
	        var relpos = planeTrimesh_relpos;
	        v.vsub(planePos, relpos);
	        var dot = normal.dot(relpos);

	        if(dot <= 0.0){
	            var r = this.createContactEquation(planeBody,trimeshBody,planeShape,trimeshShape);

	            r.ni.copy(normal); // Contact normal is the plane normal

	            // Get vertex position projected on plane
	            var projected = planeTrimesh_projected;
	            normal.scale(relpos.dot(normal), projected);
	            v.vsub(projected,projected);

	            // ri is the projected world position minus plane position
	            r.ri.copy(projected);
	            r.ri.vsub(planeBody.position, r.ri);

	            r.rj.copy(v);
	            r.rj.vsub(trimeshBody.position, r.rj);

	            // Store result
	            this.result.push(r);
	            this.createFrictionEquationsFromContact(r, this.frictionResult);
	        }
	    }
	};

	/**
	 * @method sphereTrimesh
	 * @param  {Shape}      sphereShape
	 * @param  {Shape}      trimeshShape
	 * @param  {Vec3}       spherePos
	 * @param  {Vec3}       trimeshPos
	 * @param  {Quaternion} sphereQuat
	 * @param  {Quaternion} trimeshQuat
	 * @param  {Body}       sphereBody
	 * @param  {Body}       trimeshBody
	 */
	var sphereTrimesh_normal = new Vec3();
	var sphereTrimesh_relpos = new Vec3();
	var sphereTrimesh_projected = new Vec3();
	var sphereTrimesh_v = new Vec3();
	var sphereTrimesh_v2 = new Vec3();
	var sphereTrimesh_edgeVertexA = new Vec3();
	var sphereTrimesh_edgeVertexB = new Vec3();
	var sphereTrimesh_edgeVector = new Vec3();
	var sphereTrimesh_edgeVectorUnit = new Vec3();
	var sphereTrimesh_localSpherePos = new Vec3();
	var sphereTrimesh_tmp = new Vec3();
	var sphereTrimesh_va = new Vec3();
	var sphereTrimesh_vb = new Vec3();
	var sphereTrimesh_vc = new Vec3();
	var sphereTrimesh_localSphereAABB = new AABB();
	var sphereTrimesh_triangles = [];
	Narrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] =
	Narrowphase.prototype.sphereTrimesh = function (
	    sphereShape,
	    trimeshShape,
	    spherePos,
	    trimeshPos,
	    sphereQuat,
	    trimeshQuat,
	    sphereBody,
	    trimeshBody
	) {

	    var edgeVertexA = sphereTrimesh_edgeVertexA;
	    var edgeVertexB = sphereTrimesh_edgeVertexB;
	    var edgeVector = sphereTrimesh_edgeVector;
	    var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
	    var localSpherePos = sphereTrimesh_localSpherePos;
	    var tmp = sphereTrimesh_tmp;
	    var localSphereAABB = sphereTrimesh_localSphereAABB;
	    var v2 = sphereTrimesh_v2;
	    var relpos = sphereTrimesh_relpos;
	    var triangles = sphereTrimesh_triangles;

	    // Convert sphere position to local in the trimesh
	    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos);

	    // Get the aabb of the sphere locally in the trimesh
	    var sphereRadius = sphereShape.radius;
	    localSphereAABB.lowerBound.set(
	        localSpherePos.x - sphereRadius,
	        localSpherePos.y - sphereRadius,
	        localSpherePos.z - sphereRadius
	    );
	    localSphereAABB.upperBound.set(
	        localSpherePos.x + sphereRadius,
	        localSpherePos.y + sphereRadius,
	        localSpherePos.z + sphereRadius
	    );

	    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles);
	    //for (var i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All

	    // Vertices
	    var v = sphereTrimesh_v;
	    var radiusSquared = sphereShape.radius * sphereShape.radius;
	    for(var i=0; i<triangles.length; i++){
	        for (var j = 0; j < 3; j++) {

	            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v);

	            // Check vertex overlap in sphere
	            v.vsub(localSpherePos, relpos);

	            if(relpos.norm2() <= radiusSquared){

	                // Safe up
	                v2.copy(v);
	                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);

	                v.vsub(spherePos, relpos);

	                var r = this.createContactEquation(sphereBody,trimeshBody,sphereShape,trimeshShape);
	                r.ni.copy(relpos);
	                r.ni.normalize();

	                // ri is the vector from sphere center to the sphere surface
	                r.ri.copy(r.ni);
	                r.ri.scale(sphereShape.radius, r.ri);
	                r.ri.vadd(spherePos, r.ri);
	                r.ri.vsub(sphereBody.position, r.ri);

	                r.rj.copy(v);
	                r.rj.vsub(trimeshBody.position, r.rj);

	                // Store result
	                this.result.push(r);
	                this.createFrictionEquationsFromContact(r, this.frictionResult);
	            }
	        }
	    }

	    // Check all edges
	    for(var i=0; i<triangles.length; i++){
	        for (var j = 0; j < 3; j++) {

	            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
	            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + ((j+1)%3)], edgeVertexB);
	            edgeVertexB.vsub(edgeVertexA, edgeVector);

	            // Project sphere position to the edge
	            localSpherePos.vsub(edgeVertexB, tmp);
	            var positionAlongEdgeB = tmp.dot(edgeVector);

	            localSpherePos.vsub(edgeVertexA, tmp);
	            var positionAlongEdgeA = tmp.dot(edgeVector);

	            if(positionAlongEdgeA > 0 && positionAlongEdgeB < 0){

	                // Now check the orthogonal distance from edge to sphere center
	                localSpherePos.vsub(edgeVertexA, tmp);

	                edgeVectorUnit.copy(edgeVector);
	                edgeVectorUnit.normalize();
	                positionAlongEdgeA = tmp.dot(edgeVectorUnit);

	                edgeVectorUnit.scale(positionAlongEdgeA, tmp);
	                tmp.vadd(edgeVertexA, tmp);

	                // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame
	                var dist = tmp.distanceTo(localSpherePos);
	                if(dist < sphereShape.radius){
	                    var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);

	                    tmp.vsub(localSpherePos, r.ni);
	                    r.ni.normalize();
	                    r.ni.scale(sphereShape.radius, r.ri);

	                    Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
	                    tmp.vsub(trimeshBody.position, r.rj);

	                    Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
	                    Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);

	                    this.result.push(r);
	                    this.createFrictionEquationsFromContact(r, this.frictionResult);
	                }
	            }
	        }
	    }

	    // Triangle faces
	    var va = sphereTrimesh_va;
	    var vb = sphereTrimesh_vb;
	    var vc = sphereTrimesh_vc;
	    var normal = sphereTrimesh_normal;
	    for(var i=0, N = triangles.length; i !== N; i++){
	        trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
	        trimeshShape.getNormal(triangles[i], normal);
	        localSpherePos.vsub(va, tmp);
	        var dist = tmp.dot(normal);
	        normal.scale(dist, tmp);
	        localSpherePos.vsub(tmp, tmp);

	        // tmp is now the sphere position projected to the triangle plane
	        dist = tmp.distanceTo(localSpherePos);
	        if(Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius){
	            var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);

	            tmp.vsub(localSpherePos, r.ni);
	            r.ni.normalize();
	            r.ni.scale(sphereShape.radius, r.ri);

	            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
	            tmp.vsub(trimeshBody.position, r.rj);

	            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
	            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);

	            this.result.push(r);
	            this.createFrictionEquationsFromContact(r, this.frictionResult);
	        }
	    }

	    triangles.length = 0;
	};

	var point_on_plane_to_sphere = new Vec3();
	var plane_to_sphere_ortho = new Vec3();

	/**
	 * @method spherePlane
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] =
	Narrowphase.prototype.spherePlane = function(si,sj,xi,xj,qi,qj,bi,bj){
	    // We will have one contact in this case
	    var r = this.createContactEquation(bi,bj,si,sj);

	    // Contact normal
	    r.ni.set(0,0,1);
	    qj.vmult(r.ni, r.ni);
	    r.ni.negate(r.ni); // body i is the sphere, flip normal
	    r.ni.normalize(); // Needed?

	    // Vector from sphere center to contact point
	    r.ni.mult(si.radius, r.ri);

	    // Project down sphere on plane
	    xi.vsub(xj, point_on_plane_to_sphere);
	    r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
	    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,r.rj); // The sphere position projected to plane

	    if(-point_on_plane_to_sphere.dot(r.ni) <= si.radius){

	        // Make it relative to the body
	        var ri = r.ri;
	        var rj = r.rj;
	        ri.vadd(xi, ri);
	        ri.vsub(bi.position, ri);
	        rj.vadd(xj, rj);
	        rj.vsub(bj.position, rj);

	        this.result.push(r);
	        this.createFrictionEquationsFromContact(r, this.frictionResult);
	    }
	};

	// See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html
	var pointInPolygon_edge = new Vec3();
	var pointInPolygon_edge_x_normal = new Vec3();
	var pointInPolygon_vtp = new Vec3();
	function pointInPolygon(verts, normal, p){
	    var positiveResult = null;
	    var N = verts.length;
	    for(var i=0; i!==N; i++){
	        var v = verts[i];

	        // Get edge to the next vertex
	        var edge = pointInPolygon_edge;
	        verts[(i+1) % (N)].vsub(v,edge);

	        // Get cross product between polygon normal and the edge
	        var edge_x_normal = pointInPolygon_edge_x_normal;
	        //var edge_x_normal = new Vec3();
	        edge.cross(normal,edge_x_normal);

	        // Get vector between point and current vertex
	        var vertex_to_p = pointInPolygon_vtp;
	        p.vsub(v,vertex_to_p);

	        // This dot product determines which side of the edge the point is
	        var r = edge_x_normal.dot(vertex_to_p);

	        // If all such dot products have same sign, we are inside the polygon.
	        if(positiveResult===null || (r>0 && positiveResult===true) || (r<=0 && positiveResult===false)){
	            if(positiveResult===null){
	                positiveResult = r>0;
	            }
	            continue;
	        } else {
	            return false; // Encountered some other sign. Exit.
	        }
	    }

	    // If we got here, all dot products were of the same sign.
	    return true;
	}

	var box_to_sphere = new Vec3();
	var sphereBox_ns = new Vec3();
	var sphereBox_ns1 = new Vec3();
	var sphereBox_ns2 = new Vec3();
	var sphereBox_sides = [new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3()];
	var sphereBox_sphere_to_corner = new Vec3();
	var sphereBox_side_ns = new Vec3();
	var sphereBox_side_ns1 = new Vec3();
	var sphereBox_side_ns2 = new Vec3();

	/**
	 * @method sphereBox
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] =
	Narrowphase.prototype.sphereBox = function(si,sj,xi,xj,qi,qj,bi,bj){
	    var v3pool = this.v3pool;

	    // we refer to the box as body j
	    var sides = sphereBox_sides;
	    xi.vsub(xj,box_to_sphere);
	    sj.getSideNormals(sides,qj);
	    var R =     si.radius;
	    var penetrating_sides = [];

	    // Check side (plane) intersections
	    var found = false;

	    // Store the resulting side penetration info
	    var side_ns = sphereBox_side_ns;
	    var side_ns1 = sphereBox_side_ns1;
	    var side_ns2 = sphereBox_side_ns2;
	    var side_h = null;
	    var side_penetrations = 0;
	    var side_dot1 = 0;
	    var side_dot2 = 0;
	    var side_distance = null;
	    for(var idx=0,nsides=sides.length; idx!==nsides && found===false; idx++){
	        // Get the plane side normal (ns)
	        var ns = sphereBox_ns;
	        ns.copy(sides[idx]);

	        var h = ns.norm();
	        ns.normalize();

	        // The normal/distance dot product tells which side of the plane we are
	        var dot = box_to_sphere.dot(ns);

	        if(dot<h+R && dot>0){
	            // Intersects plane. Now check the other two dimensions
	            var ns1 = sphereBox_ns1;
	            var ns2 = sphereBox_ns2;
	            ns1.copy(sides[(idx+1)%3]);
	            ns2.copy(sides[(idx+2)%3]);
	            var h1 = ns1.norm();
	            var h2 = ns2.norm();
	            ns1.normalize();
	            ns2.normalize();
	            var dot1 = box_to_sphere.dot(ns1);
	            var dot2 = box_to_sphere.dot(ns2);
	            if(dot1<h1 && dot1>-h1 && dot2<h2 && dot2>-h2){
	                var dist = Math.abs(dot-h-R);
	                if(side_distance===null || dist < side_distance){
	                    side_distance = dist;
	                    side_dot1 = dot1;
	                    side_dot2 = dot2;
	                    side_h = h;
	                    side_ns.copy(ns);
	                    side_ns1.copy(ns1);
	                    side_ns2.copy(ns2);
	                    side_penetrations++;
	                }
	            }
	        }
	    }
	    if(side_penetrations){
	        found = true;
	        var r = this.createContactEquation(bi,bj,si,sj);
	        side_ns.mult(-R,r.ri); // Sphere r
	        r.ni.copy(side_ns);
	        r.ni.negate(r.ni); // Normal should be out of sphere
	        side_ns.mult(side_h,side_ns);
	        side_ns1.mult(side_dot1,side_ns1);
	        side_ns.vadd(side_ns1,side_ns);
	        side_ns2.mult(side_dot2,side_ns2);
	        side_ns.vadd(side_ns2,r.rj);

	        // Make relative to bodies
	        r.ri.vadd(xi, r.ri);
	        r.ri.vsub(bi.position, r.ri);
	        r.rj.vadd(xj, r.rj);
	        r.rj.vsub(bj.position, r.rj);

	        this.result.push(r);
	        this.createFrictionEquationsFromContact(r, this.frictionResult);
	    }

	    // Check corners
	    var rj = v3pool.get();
	    var sphere_to_corner = sphereBox_sphere_to_corner;
	    for(var j=0; j!==2 && !found; j++){
	        for(var k=0; k!==2 && !found; k++){
	            for(var l=0; l!==2 && !found; l++){
	                rj.set(0,0,0);
	                if(j){
	                    rj.vadd(sides[0],rj);
	                } else {
	                    rj.vsub(sides[0],rj);
	                }
	                if(k){
	                    rj.vadd(sides[1],rj);
	                } else {
	                    rj.vsub(sides[1],rj);
	                }
	                if(l){
	                    rj.vadd(sides[2],rj);
	                } else {
	                    rj.vsub(sides[2],rj);
	                }

	                // World position of corner
	                xj.vadd(rj,sphere_to_corner);
	                sphere_to_corner.vsub(xi,sphere_to_corner);

	                if(sphere_to_corner.norm2() < R*R){
	                    found = true;
	                    var r = this.createContactEquation(bi,bj,si,sj);
	                    r.ri.copy(sphere_to_corner);
	                    r.ri.normalize();
	                    r.ni.copy(r.ri);
	                    r.ri.mult(R,r.ri);
	                    r.rj.copy(rj);

	                    // Make relative to bodies
	                    r.ri.vadd(xi, r.ri);
	                    r.ri.vsub(bi.position, r.ri);
	                    r.rj.vadd(xj, r.rj);
	                    r.rj.vsub(bj.position, r.rj);

	                    this.result.push(r);
	                    this.createFrictionEquationsFromContact(r, this.frictionResult);
	                }
	            }
	        }
	    }
	    v3pool.release(rj);
	    rj = null;

	    // Check edges
	    var edgeTangent = v3pool.get();
	    var edgeCenter = v3pool.get();
	    var r = v3pool.get(); // r = edge center to sphere center
	    var orthogonal = v3pool.get();
	    var dist = v3pool.get();
	    var Nsides = sides.length;
	    for(var j=0; j!==Nsides && !found; j++){
	        for(var k=0; k!==Nsides && !found; k++){
	            if(j%3 !== k%3){
	                // Get edge tangent
	                sides[k].cross(sides[j],edgeTangent);
	                edgeTangent.normalize();
	                sides[j].vadd(sides[k], edgeCenter);
	                r.copy(xi);
	                r.vsub(edgeCenter,r);
	                r.vsub(xj,r);
	                var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction
	                edgeTangent.mult(orthonorm,orthogonal); // Vector from edge center to sphere center in the tangent direction

	                // Find the third side orthogonal to this one
	                var l = 0;
	                while(l===j%3 || l===k%3){
	                    l++;
	                }

	                // vec from edge center to sphere projected to the plane orthogonal to the edge tangent
	                dist.copy(xi);
	                dist.vsub(orthogonal,dist);
	                dist.vsub(edgeCenter,dist);
	                dist.vsub(xj,dist);

	                // Distances in tangent direction and distance in the plane orthogonal to it
	                var tdist = Math.abs(orthonorm);
	                var ndist = dist.norm();

	                if(tdist < sides[l].norm() && ndist<R){
	                    found = true;
	                    var res = this.createContactEquation(bi,bj,si,sj);
	                    edgeCenter.vadd(orthogonal,res.rj); // box rj
	                    res.rj.copy(res.rj);
	                    dist.negate(res.ni);
	                    res.ni.normalize();

	                    res.ri.copy(res.rj);
	                    res.ri.vadd(xj,res.ri);
	                    res.ri.vsub(xi,res.ri);
	                    res.ri.normalize();
	                    res.ri.mult(R,res.ri);

	                    // Make relative to bodies
	                    res.ri.vadd(xi, res.ri);
	                    res.ri.vsub(bi.position, res.ri);
	                    res.rj.vadd(xj, res.rj);
	                    res.rj.vsub(bj.position, res.rj);

	                    this.result.push(res);
	                    this.createFrictionEquationsFromContact(res, this.frictionResult);
	                }
	            }
	        }
	    }
	    v3pool.release(edgeTangent,edgeCenter,r,orthogonal,dist);
	};

	var convex_to_sphere = new Vec3();
	var sphereConvex_edge = new Vec3();
	var sphereConvex_edgeUnit = new Vec3();
	var sphereConvex_sphereToCorner = new Vec3();
	var sphereConvex_worldCorner = new Vec3();
	var sphereConvex_worldNormal = new Vec3();
	var sphereConvex_worldPoint = new Vec3();
	var sphereConvex_worldSpherePointClosestToPlane = new Vec3();
	var sphereConvex_penetrationVec = new Vec3();
	var sphereConvex_sphereToWorldPoint = new Vec3();

	/**
	 * @method sphereConvex
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] =
	Narrowphase.prototype.sphereConvex = function(si,sj,xi,xj,qi,qj,bi,bj){
	    var v3pool = this.v3pool;
	    xi.vsub(xj,convex_to_sphere);
	    var normals = sj.faceNormals;
	    var faces = sj.faces;
	    var verts = sj.vertices;
	    var R =     si.radius;
	    var penetrating_sides = [];

	    // if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){
	    //     return;
	    // }

	    // Check corners
	    for(var i=0; i!==verts.length; i++){
	        var v = verts[i];

	        // World position of corner
	        var worldCorner = sphereConvex_worldCorner;
	        qj.vmult(v,worldCorner);
	        xj.vadd(worldCorner,worldCorner);
	        var sphere_to_corner = sphereConvex_sphereToCorner;
	        worldCorner.vsub(xi, sphere_to_corner);
	        if(sphere_to_corner.norm2() < R * R){
	            found = true;
	            var r = this.createContactEquation(bi,bj,si,sj);
	            r.ri.copy(sphere_to_corner);
	            r.ri.normalize();
	            r.ni.copy(r.ri);
	            r.ri.mult(R,r.ri);
	            worldCorner.vsub(xj,r.rj);

	            // Should be relative to the body.
	            r.ri.vadd(xi, r.ri);
	            r.ri.vsub(bi.position, r.ri);

	            // Should be relative to the body.
	            r.rj.vadd(xj, r.rj);
	            r.rj.vsub(bj.position, r.rj);

	            this.result.push(r);
	            this.createFrictionEquationsFromContact(r, this.frictionResult);
	            return;
	        }
	    }

	    // Check side (plane) intersections
	    var found = false;
	    for(var i=0, nfaces=faces.length; i!==nfaces && found===false; i++){
	        var normal = normals[i];
	        var face = faces[i];

	        // Get world-transformed normal of the face
	        var worldNormal = sphereConvex_worldNormal;
	        qj.vmult(normal,worldNormal);

	        // Get a world vertex from the face
	        var worldPoint = sphereConvex_worldPoint;
	        qj.vmult(verts[face[0]],worldPoint);
	        worldPoint.vadd(xj,worldPoint);

	        // Get a point on the sphere, closest to the face normal
	        var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
	        worldNormal.mult(-R, worldSpherePointClosestToPlane);
	        xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);

	        // Vector from a face point to the closest point on the sphere
	        var penetrationVec = sphereConvex_penetrationVec;
	        worldSpherePointClosestToPlane.vsub(worldPoint,penetrationVec);

	        // The penetration. Negative value means overlap.
	        var penetration = penetrationVec.dot(worldNormal);

	        var worldPointToSphere = sphereConvex_sphereToWorldPoint;
	        xi.vsub(worldPoint, worldPointToSphere);

	        if(penetration < 0 && worldPointToSphere.dot(worldNormal)>0){
	            // Intersects plane. Now check if the sphere is inside the face polygon
	            var faceVerts = []; // Face vertices, in world coords
	            for(var j=0, Nverts=face.length; j!==Nverts; j++){
	                var worldVertex = v3pool.get();
	                qj.vmult(verts[face[j]], worldVertex);
	                xj.vadd(worldVertex,worldVertex);
	                faceVerts.push(worldVertex);
	            }

	            if(pointInPolygon(faceVerts,worldNormal,xi)){ // Is the sphere center in the face polygon?
	                found = true;
	                var r = this.createContactEquation(bi,bj,si,sj);

	                worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact
	                worldNormal.negate(r.ni); // Normal pointing out of sphere

	                var penetrationVec2 = v3pool.get();
	                worldNormal.mult(-penetration, penetrationVec2);
	                var penetrationSpherePoint = v3pool.get();
	                worldNormal.mult(-R, penetrationSpherePoint);

	                //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);
	                xi.vsub(xj,r.rj);
	                r.rj.vadd(penetrationSpherePoint,r.rj);
	                r.rj.vadd(penetrationVec2 , r.rj);

	                // Should be relative to the body.
	                r.rj.vadd(xj, r.rj);
	                r.rj.vsub(bj.position, r.rj);

	                // Should be relative to the body.
	                r.ri.vadd(xi, r.ri);
	                r.ri.vsub(bi.position, r.ri);

	                v3pool.release(penetrationVec2);
	                v3pool.release(penetrationSpherePoint);

	                this.result.push(r);
	                this.createFrictionEquationsFromContact(r, this.frictionResult);

	                // Release world vertices
	                for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
	                    v3pool.release(faceVerts[j]);
	                }

	                return; // We only expect *one* face contact
	            } else {
	                // Edge?
	                for(var j=0; j!==face.length; j++){

	                    // Get two world transformed vertices
	                    var v1 = v3pool.get();
	                    var v2 = v3pool.get();
	                    qj.vmult(verts[face[(j+1)%face.length]], v1);
	                    qj.vmult(verts[face[(j+2)%face.length]], v2);
	                    xj.vadd(v1, v1);
	                    xj.vadd(v2, v2);

	                    // Construct edge vector
	                    var edge = sphereConvex_edge;
	                    v2.vsub(v1,edge);

	                    // Construct the same vector, but normalized
	                    var edgeUnit = sphereConvex_edgeUnit;
	                    edge.unit(edgeUnit);

	                    // p is xi projected onto the edge
	                    var p = v3pool.get();
	                    var v1_to_xi = v3pool.get();
	                    xi.vsub(v1, v1_to_xi);
	                    var dot = v1_to_xi.dot(edgeUnit);
	                    edgeUnit.mult(dot, p);
	                    p.vadd(v1, p);

	                    // Compute a vector from p to the center of the sphere
	                    var xi_to_p = v3pool.get();
	                    p.vsub(xi, xi_to_p);

	                    // Collision if the edge-sphere distance is less than the radius
	                    // AND if p is in between v1 and v2
	                    if(dot > 0 && dot*dot<edge.norm2() && xi_to_p.norm2() < R*R){ // Collision if the edge-sphere distance is less than the radius
	                        // Edge contact!
	                        var r = this.createContactEquation(bi,bj,si,sj);
	                        p.vsub(xj,r.rj);

	                        p.vsub(xi,r.ni);
	                        r.ni.normalize();

	                        r.ni.mult(R,r.ri);

	                        // Should be relative to the body.
	                        r.rj.vadd(xj, r.rj);
	                        r.rj.vsub(bj.position, r.rj);

	                        // Should be relative to the body.
	                        r.ri.vadd(xi, r.ri);
	                        r.ri.vsub(bi.position, r.ri);

	                        this.result.push(r);
	                        this.createFrictionEquationsFromContact(r, this.frictionResult);

	                        // Release world vertices
	                        for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
	                            v3pool.release(faceVerts[j]);
	                        }

	                        v3pool.release(v1);
	                        v3pool.release(v2);
	                        v3pool.release(p);
	                        v3pool.release(xi_to_p);
	                        v3pool.release(v1_to_xi);

	                        return;
	                    }

	                    v3pool.release(v1);
	                    v3pool.release(v2);
	                    v3pool.release(p);
	                    v3pool.release(xi_to_p);
	                    v3pool.release(v1_to_xi);
	                }
	            }

	            // Release world vertices
	            for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
	                v3pool.release(faceVerts[j]);
	            }
	        }
	    }
	};

	var planeBox_normal = new Vec3();
	var plane_to_corner = new Vec3();

	/**
	 * @method planeBox
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] =
	Narrowphase.prototype.planeBox = function(si,sj,xi,xj,qi,qj,bi,bj){
	    sj.convexPolyhedronRepresentation.material = sj.material;
	    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
	    this.planeConvex(si,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj);
	};

	var planeConvex_v = new Vec3();
	var planeConvex_normal = new Vec3();
	var planeConvex_relpos = new Vec3();
	var planeConvex_projected = new Vec3();

	/**
	 * @method planeConvex
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] =
	Narrowphase.prototype.planeConvex = function(
	    planeShape,
	    convexShape,
	    planePosition,
	    convexPosition,
	    planeQuat,
	    convexQuat,
	    planeBody,
	    convexBody
	){
	    // Simply return the points behind the plane.
	    var worldVertex = planeConvex_v,
	        worldNormal = planeConvex_normal;
	    worldNormal.set(0,0,1);
	    planeQuat.vmult(worldNormal,worldNormal); // Turn normal according to plane orientation

	    var numContacts = 0;
	    var relpos = planeConvex_relpos;
	    for(var i = 0; i !== convexShape.vertices.length; i++){

	        // Get world convex vertex
	        worldVertex.copy(convexShape.vertices[i]);
	        convexQuat.vmult(worldVertex, worldVertex);
	        convexPosition.vadd(worldVertex, worldVertex);
	        worldVertex.vsub(planePosition, relpos);

	        var dot = worldNormal.dot(relpos);
	        if(dot <= 0.0){

	            var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape);

	            // Get vertex position projected on plane
	            var projected = planeConvex_projected;
	            worldNormal.mult(worldNormal.dot(relpos),projected);
	            worldVertex.vsub(projected, projected);
	            projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

	            r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane

	            // rj is now just the vector from the convex center to the vertex
	            worldVertex.vsub(convexPosition, r.rj);

	            // Make it relative to the body
	            r.ri.vadd(planePosition, r.ri);
	            r.ri.vsub(planeBody.position, r.ri);
	            r.rj.vadd(convexPosition, r.rj);
	            r.rj.vsub(convexBody.position, r.rj);

	            this.result.push(r);
	            numContacts++;
	            if(!this.enableFrictionReduction){
	                this.createFrictionEquationsFromContact(r, this.frictionResult);
	            }
	        }
	    }

	    if(this.enableFrictionReduction && numContacts){
	        this.createFrictionFromAverage(numContacts);
	    }
	};

	var convexConvex_sepAxis = new Vec3();
	var convexConvex_q = new Vec3();

	/**
	 * @method convexConvex
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] =
	Narrowphase.prototype.convexConvex = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){
	    var sepAxis = convexConvex_sepAxis;

	    if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
	        return;
	    }

	    if(si.findSeparatingAxis(sj,xi,qi,xj,qj,sepAxis,faceListA,faceListB)){
	        var res = [];
	        var q = convexConvex_q;
	        si.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);
	        var numContacts = 0;
	        for(var j = 0; j !== res.length; j++){
	            var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
	                ri = r.ri,
	                rj = r.rj;
	            sepAxis.negate(r.ni);
	            res[j].normal.negate(q);
	            q.mult(res[j].depth, q);
	            res[j].point.vadd(q, ri);
	            rj.copy(res[j].point);

	            // Contact points are in world coordinates. Transform back to relative
	            ri.vsub(xi,ri);
	            rj.vsub(xj,rj);

	            // Make relative to bodies
	            ri.vadd(xi, ri);
	            ri.vsub(bi.position, ri);
	            rj.vadd(xj, rj);
	            rj.vsub(bj.position, rj);

	            this.result.push(r);
	            numContacts++;
	            if(!this.enableFrictionReduction){
	                this.createFrictionEquationsFromContact(r, this.frictionResult);
	            }
	        }
	        if(this.enableFrictionReduction && numContacts){
	            this.createFrictionFromAverage(numContacts);
	        }
	    }
	};


	/**
	 * @method convexTrimesh
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	// Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.TRIMESH] =
	// Narrowphase.prototype.convexTrimesh = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){
	//     var sepAxis = convexConvex_sepAxis;

	//     if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
	//         return;
	//     }

	//     // Construct a temp hull for each triangle
	//     var hullB = new ConvexPolyhedron();

	//     hullB.faces = [[0,1,2]];
	//     var va = new Vec3();
	//     var vb = new Vec3();
	//     var vc = new Vec3();
	//     hullB.vertices = [
	//         va,
	//         vb,
	//         vc
	//     ];

	//     for (var i = 0; i < sj.indices.length / 3; i++) {

	//         var triangleNormal = new Vec3();
	//         sj.getNormal(i, triangleNormal);
	//         hullB.faceNormals = [triangleNormal];

	//         sj.getTriangleVertices(i, va, vb, vc);

	//         var d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
	//         if(!d){
	//             triangleNormal.scale(-1, triangleNormal);
	//             d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);

	//             if(!d){
	//                 continue;
	//             }
	//         }

	//         var res = [];
	//         var q = convexConvex_q;
	//         si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
	//         for(var j = 0; j !== res.length; j++){
	//             var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
	//                 ri = r.ri,
	//                 rj = r.rj;
	//             r.ni.copy(triangleNormal);
	//             r.ni.negate(r.ni);
	//             res[j].normal.negate(q);
	//             q.mult(res[j].depth, q);
	//             res[j].point.vadd(q, ri);
	//             rj.copy(res[j].point);

	//             // Contact points are in world coordinates. Transform back to relative
	//             ri.vsub(xi,ri);
	//             rj.vsub(xj,rj);

	//             // Make relative to bodies
	//             ri.vadd(xi, ri);
	//             ri.vsub(bi.position, ri);
	//             rj.vadd(xj, rj);
	//             rj.vsub(bj.position, rj);

	//             result.push(r);
	//         }
	//     }
	// };

	var particlePlane_normal = new Vec3();
	var particlePlane_relpos = new Vec3();
	var particlePlane_projected = new Vec3();

	/**
	 * @method particlePlane
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] =
	Narrowphase.prototype.planeParticle = function(sj,si,xj,xi,qj,qi,bj,bi){
	    var normal = particlePlane_normal;
	    normal.set(0,0,1);
	    bj.quaternion.vmult(normal,normal); // Turn normal according to plane orientation
	    var relpos = particlePlane_relpos;
	    xi.vsub(bj.position,relpos);
	    var dot = normal.dot(relpos);
	    if(dot <= 0.0){
	        var r = this.createContactEquation(bi,bj,si,sj);
	        r.ni.copy(normal); // Contact normal is the plane normal
	        r.ni.negate(r.ni);
	        r.ri.set(0,0,0); // Center of particle

	        // Get particle position projected on plane
	        var projected = particlePlane_projected;
	        normal.mult(normal.dot(xi),projected);
	        xi.vsub(projected,projected);
	        //projected.vadd(bj.position,projected);

	        // rj is now the projected world position minus plane position
	        r.rj.copy(projected);
	        this.result.push(r);
	        this.createFrictionEquationsFromContact(r, this.frictionResult);
	    }
	};

	var particleSphere_normal = new Vec3();

	/**
	 * @method particleSphere
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] =
	Narrowphase.prototype.sphereParticle = function(sj,si,xj,xi,qj,qi,bj,bi){
	    // The normal is the unit vector from sphere center to particle center
	    var normal = particleSphere_normal;
	    normal.set(0,0,1);
	    xi.vsub(xj,normal);
	    var lengthSquared = normal.norm2();

	    if(lengthSquared <= sj.radius * sj.radius){
	        var r = this.createContactEquation(bi,bj,si,sj);
	        normal.normalize();
	        r.rj.copy(normal);
	        r.rj.mult(sj.radius,r.rj);
	        r.ni.copy(normal); // Contact normal
	        r.ni.negate(r.ni);
	        r.ri.set(0,0,0); // Center of particle
	        this.result.push(r);
	        this.createFrictionEquationsFromContact(r, this.frictionResult);
	    }
	};

	// WIP
	var cqj = new Quaternion();
	var convexParticle_local = new Vec3();
	var convexParticle_normal = new Vec3();
	var convexParticle_penetratedFaceNormal = new Vec3();
	var convexParticle_vertexToParticle = new Vec3();
	var convexParticle_worldPenetrationVec = new Vec3();

	/**
	 * @method convexParticle
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] =
	Narrowphase.prototype.convexParticle = function(sj,si,xj,xi,qj,qi,bj,bi){
	    var penetratedFaceIndex = -1;
	    var penetratedFaceNormal = convexParticle_penetratedFaceNormal;
	    var worldPenetrationVec = convexParticle_worldPenetrationVec;
	    var minPenetration = null;
	    var numDetectedFaces = 0;

	    // Convert particle position xi to local coords in the convex
	    var local = convexParticle_local;
	    local.copy(xi);
	    local.vsub(xj,local); // Convert position to relative the convex origin
	    qj.conjugate(cqj);
	    cqj.vmult(local,local);

	    if(sj.pointIsInside(local)){

	        if(sj.worldVerticesNeedsUpdate){
	            sj.computeWorldVertices(xj,qj);
	        }
	        if(sj.worldFaceNormalsNeedsUpdate){
	            sj.computeWorldFaceNormals(qj);
	        }

	        // For each world polygon in the polyhedra
	        for(var i=0,nfaces=sj.faces.length; i!==nfaces; i++){

	            // Construct world face vertices
	            var verts = [ sj.worldVertices[ sj.faces[i][0] ] ];
	            var normal = sj.worldFaceNormals[i];

	            // Check how much the particle penetrates the polygon plane.
	            xi.vsub(verts[0],convexParticle_vertexToParticle);
	            var penetration = -normal.dot(convexParticle_vertexToParticle);
	            if(minPenetration===null || Math.abs(penetration)<Math.abs(minPenetration)){
	                minPenetration = penetration;
	                penetratedFaceIndex = i;
	                penetratedFaceNormal.copy(normal);
	                numDetectedFaces++;
	            }
	        }

	        if(penetratedFaceIndex!==-1){
	            // Setup contact
	            var r = this.createContactEquation(bi,bj,si,sj);
	            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec);

	            // rj is the particle position projected to the face
	            worldPenetrationVec.vadd(xi,worldPenetrationVec);
	            worldPenetrationVec.vsub(xj,worldPenetrationVec);
	            r.rj.copy(worldPenetrationVec);
	            //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
	            //projectedToFace.copy(r.rj);

	            //qj.vmult(r.rj,r.rj);
	            penetratedFaceNormal.negate( r.ni ); // Contact normal
	            r.ri.set(0,0,0); // Center of particle

	            var ri = r.ri,
	                rj = r.rj;

	            // Make relative to bodies
	            ri.vadd(xi, ri);
	            ri.vsub(bi.position, ri);
	            rj.vadd(xj, rj);
	            rj.vsub(bj.position, rj);

	            this.result.push(r);
	            this.createFrictionEquationsFromContact(r, this.frictionResult);
	        } else {
	            console.warn("Point found inside convex, but did not find penetrating face!");
	        }
	    }
	};

	Narrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] =
	Narrowphase.prototype.boxHeightfield = function (si,sj,xi,xj,qi,qj,bi,bj){
	    si.convexPolyhedronRepresentation.material = si.material;
	    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
	    this.convexHeightfield(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj);
	};

	var convexHeightfield_tmp1 = new Vec3();
	var convexHeightfield_tmp2 = new Vec3();
	var convexHeightfield_faceList = [0];

	/**
	 * @method convexHeightfield
	 */
	Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] =
	Narrowphase.prototype.convexHeightfield = function (
	    convexShape,
	    hfShape,
	    convexPos,
	    hfPos,
	    convexQuat,
	    hfQuat,
	    convexBody,
	    hfBody
	){
	    var data = hfShape.data,
	        w = hfShape.elementSize,
	        radius = convexShape.boundingSphereRadius,
	        worldPillarOffset = convexHeightfield_tmp2,
	        faceList = convexHeightfield_faceList;

	    // Get sphere position to heightfield local!
	    var localConvexPos = convexHeightfield_tmp1;
	    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);

	    // Get the index of the data points to test against
	    var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,
	        iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,
	        iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,
	        iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;

	    // Bail out if we are out of the terrain
	    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length){
	        return;
	    }

	    // Clamp index to edges
	    if(iMinX < 0){ iMinX = 0; }
	    if(iMaxX < 0){ iMaxX = 0; }
	    if(iMinY < 0){ iMinY = 0; }
	    if(iMaxY < 0){ iMaxY = 0; }
	    if(iMinX >= data.length){ iMinX = data.length - 1; }
	    if(iMaxX >= data.length){ iMaxX = data.length - 1; }
	    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }
	    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }

	    var minMax = [];
	    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
	    var min = minMax[0];
	    var max = minMax[1];

	    // Bail out if we're cant touch the bounding height box
	    if(localConvexPos.z - radius > max || localConvexPos.z + radius < min){
	        return;
	    }

	    for(var i = iMinX; i < iMaxX; i++){
	        for(var j = iMinY; j < iMaxY; j++){

	            // Lower triangle
	            hfShape.getConvexTrianglePillar(i, j, false);
	            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
	            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
	                this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);
	            }

	            // Upper triangle
	            hfShape.getConvexTrianglePillar(i, j, true);
	            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
	            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
	                this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);
	            }
	        }
	    }
	};

	var sphereHeightfield_tmp1 = new Vec3();
	var sphereHeightfield_tmp2 = new Vec3();

	/**
	 * @method sphereHeightfield
	 */
	Narrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] =
	Narrowphase.prototype.sphereHeightfield = function (
	    sphereShape,
	    hfShape,
	    spherePos,
	    hfPos,
	    sphereQuat,
	    hfQuat,
	    sphereBody,
	    hfBody
	){
	    var data = hfShape.data,
	        radius = sphereShape.radius,
	        w = hfShape.elementSize,
	        worldPillarOffset = sphereHeightfield_tmp2;

	    // Get sphere position to heightfield local!
	    var localSpherePos = sphereHeightfield_tmp1;
	    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);

	    // Get the index of the data points to test against
	    var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,
	        iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,
	        iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,
	        iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;

	    // Bail out if we are out of the terrain
	    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length){
	        return;
	    }

	    // Clamp index to edges
	    if(iMinX < 0){ iMinX = 0; }
	    if(iMaxX < 0){ iMaxX = 0; }
	    if(iMinY < 0){ iMinY = 0; }
	    if(iMaxY < 0){ iMaxY = 0; }
	    if(iMinX >= data.length){ iMinX = data.length - 1; }
	    if(iMaxX >= data.length){ iMaxX = data.length - 1; }
	    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }
	    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }

	    var minMax = [];
	    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
	    var min = minMax[0];
	    var max = minMax[1];

	    // Bail out if we're cant touch the bounding height box
	    if(localSpherePos.z - radius > max || localSpherePos.z + radius < min){
	        return;
	    }

	    var result = this.result;
	    for(var i = iMinX; i < iMaxX; i++){
	        for(var j = iMinY; j < iMaxY; j++){

	            var numContactsBefore = result.length;

	            // Lower triangle
	            hfShape.getConvexTrianglePillar(i, j, false);
	            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
	            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
	                this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
	            }

	            // Upper triangle
	            hfShape.getConvexTrianglePillar(i, j, true);
	            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
	            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
	                this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
	            }

	            var numContacts = result.length - numContactsBefore;

	            if(numContacts > 2){
	                return;
	            }
	            /*
	            // Skip all but 1
	            for (var k = 0; k < numContacts - 1; k++) {
	                result.pop();
	            }
	            */
	        }
	    }
	};

	},{"../collision/AABB":3,"../collision/Ray":9,"../equations/ContactEquation":19,"../equations/FrictionEquation":21,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../shapes/ConvexPolyhedron":38,"../shapes/Shape":43,"../solver/Solver":47,"../utils/Vec3Pool":54}],56:[function(_dereq_,module,exports){
	/* global performance */

	module.exports = World;

	var Shape = _dereq_('../shapes/Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var GSSolver = _dereq_('../solver/GSSolver');
	var Vec3Pool = _dereq_('../utils/Vec3Pool');
	var ContactEquation = _dereq_('../equations/ContactEquation');
	var FrictionEquation = _dereq_('../equations/FrictionEquation');
	var Narrowphase = _dereq_('./Narrowphase');
	var EventTarget = _dereq_('../utils/EventTarget');
	var ArrayCollisionMatrix = _dereq_('../collision/ArrayCollisionMatrix');
	var Material = _dereq_('../material/Material');
	var ContactMaterial = _dereq_('../material/ContactMaterial');
	var Body = _dereq_('../objects/Body');
	var TupleDictionary = _dereq_('../utils/TupleDictionary');
	var RaycastResult = _dereq_('../collision/RaycastResult');
	var AABB = _dereq_('../collision/AABB');
	var Ray = _dereq_('../collision/Ray');
	var NaiveBroadphase = _dereq_('../collision/NaiveBroadphase');

	/**
	 * The physics world
	 * @class World
	 * @constructor
	 * @extends EventTarget
	 */
	function World(){
	    EventTarget.apply(this);

	    /**
	     * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
	     * @property {Number} dt
	     */
	    this.dt = -1;

	    /**
	     * Makes bodies go to sleep when they've been inactive
	     * @property allowSleep
	     * @type {Boolean}
	     */
	    this.allowSleep = false;

	    /**
	     * All the current contacts (instances of ContactEquation) in the world.
	     * @property contacts
	     * @type {Array}
	     */
	    this.contacts = [];
	    this.frictionEquations = [];

	    /**
	     * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
	     * @property quatNormalizeSkip
	     * @type {Number}
	     */
	    this.quatNormalizeSkip = 0;

	    /**
	     * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.
	     * @property quatNormalizeFast
	     * @type {Boolean}
	     * @see Quaternion.normalizeFast
	     * @see Quaternion.normalize
	     */
	    this.quatNormalizeFast = false;

	    /**
	     * The wall-clock time since simulation start
	     * @property time
	     * @type {Number}
	     */
	    this.time = 0.0;

	    /**
	     * Number of timesteps taken since start
	     * @property stepnumber
	     * @type {Number}
	     */
	    this.stepnumber = 0;

	    /// Default and last timestep sizes
	    this.default_dt = 1/60;

	    this.nextId = 0;
	    /**
	     * @property gravity
	     * @type {Vec3}
	     */
	    this.gravity = new Vec3();

	    /**
	     * @property broadphase
	     * @type {Broadphase}
	     */
	    this.broadphase = new NaiveBroadphase();

	    /**
	     * @property bodies
	     * @type {Array}
	     */
	    this.bodies = [];

	    /**
	     * @property solver
	     * @type {Solver}
	     */
	    this.solver = new GSSolver();

	    /**
	     * @property constraints
	     * @type {Array}
	     */
	    this.constraints = [];

	    /**
	     * @property narrowphase
	     * @type {Narrowphase}
	     */
	    this.narrowphase = new Narrowphase(this);

	    /**
	     * @property {ArrayCollisionMatrix} collisionMatrix
		 * @type {ArrayCollisionMatrix}
		 */
		this.collisionMatrix = new ArrayCollisionMatrix();

	    /**
	     * CollisionMatrix from the previous step.
	     * @property {ArrayCollisionMatrix} collisionMatrixPrevious
		 * @type {ArrayCollisionMatrix}
		 */
		this.collisionMatrixPrevious = new ArrayCollisionMatrix();

	    /**
	     * All added materials
	     * @property materials
	     * @type {Array}
	     */
	    this.materials = [];

	    /**
	     * @property contactmaterials
	     * @type {Array}
	     */
	    this.contactmaterials = [];

	    /**
	     * Used to look up a ContactMaterial given two instances of Material.
	     * @property {TupleDictionary} contactMaterialTable
	     */
	    this.contactMaterialTable = new TupleDictionary();

	    this.defaultMaterial = new Material("default");

	    /**
	     * This contact material is used if no suitable contactmaterial is found for a contact.
	     * @property defaultContactMaterial
	     * @type {ContactMaterial}
	     */
	    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0.0 });

	    /**
	     * @property doProfiling
	     * @type {Boolean}
	     */
	    this.doProfiling = false;

	    /**
	     * @property profile
	     * @type {Object}
	     */
	    this.profile = {
	        solve:0,
	        makeContactConstraints:0,
	        broadphase:0,
	        integrate:0,
	        narrowphase:0,
	    };

	    /**
	     * @property subsystems
	     * @type {Array}
	     */
	    this.subsystems = [];

	    this.addBodyEvent = {
	        type:"addBody",
	        body : null,
	    };

	    this.removeBodyEvent = {
	        type:"removeBody",
	        body : null,
	    };
	}
	World.prototype = new EventTarget();

	// Temp stuff
	var tmpAABB1 = new AABB();
	var tmpArray1 = [];
	var tmpRay = new Ray();

	/**
	 * Get the contact material between materials m1 and m2
	 * @method getContactMaterial
	 * @param {Material} m1
	 * @param {Material} m2
	 * @return {ContactMaterial} The contact material if it was found.
	 */
	World.prototype.getContactMaterial = function(m1,m2){
	    return this.contactMaterialTable.get(m1.id,m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];
	};

	/**
	 * Get number of objects in the world.
	 * @method numObjects
	 * @return {Number}
	 * @deprecated
	 */
	World.prototype.numObjects = function(){
	    return this.bodies.length;
	};

	/**
	 * Store old collision state info
	 * @method collisionMatrixTick
	 */
	World.prototype.collisionMatrixTick = function(){
		var temp = this.collisionMatrixPrevious;
		this.collisionMatrixPrevious = this.collisionMatrix;
		this.collisionMatrix = temp;
		this.collisionMatrix.reset();
	};

	/**
	 * Add a rigid body to the simulation.
	 * @method add
	 * @param {Body} body
	 * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
	 * @todo Adding an array of bodies should be possible. This would save some loops too
	 * @deprecated Use .addBody instead
	 */
	World.prototype.add = World.prototype.addBody = function(body){
	    if(this.bodies.indexOf(body) !== -1){
	        return;
	    }
	    body.index = this.bodies.length;
	    this.bodies.push(body);
	    body.world = this;
	    body.initPosition.copy(body.position);
	    body.initVelocity.copy(body.velocity);
	    body.timeLastSleepy = this.time;
	    if(body instanceof Body){
	        body.initAngularVelocity.copy(body.angularVelocity);
	        body.initQuaternion.copy(body.quaternion);
	    }
		this.collisionMatrix.setNumObjects(this.bodies.length);
	    this.addBodyEvent.body = body;
	    this.dispatchEvent(this.addBodyEvent);
	};

	/**
	 * Add a constraint to the simulation.
	 * @method addConstraint
	 * @param {Constraint} c
	 */
	World.prototype.addConstraint = function(c){
	    this.constraints.push(c);
	};

	/**
	 * Removes a constraint
	 * @method removeConstraint
	 * @param {Constraint} c
	 */
	World.prototype.removeConstraint = function(c){
	    var idx = this.constraints.indexOf(c);
	    if(idx!==-1){
	        this.constraints.splice(idx,1);
	    }
	};

	/**
	 * Raycast test
	 * @method rayTest
	 * @param {Vec3} from
	 * @param {Vec3} to
	 * @param {Function|RaycastResult} result
	 * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
	 */
	World.prototype.rayTest = function(from, to, result){
	    if(result instanceof RaycastResult){
	        // Do raycastclosest
	        this.raycastClosest(from, to, {
	            skipBackfaces: true
	        }, result);
	    } else {
	        // Do raycastAll
	        this.raycastAll(from, to, {
	            skipBackfaces: true
	        }, result);
	    }
	};

	/**
	 * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
	 * @method raycastAll
	 * @param  {Vec3} from
	 * @param  {Vec3} to
	 * @param  {Object} options
	 * @param  {number} [options.collisionFilterMask=-1]
	 * @param  {number} [options.collisionFilterGroup=-1]
	 * @param  {boolean} [options.skipBackfaces=false]
	 * @param  {boolean} [options.checkCollisionResponse=true]
	 * @param  {Function} callback
	 * @return {boolean} True if any body was hit.
	 */
	World.prototype.raycastAll = function(from, to, options, callback){
	    options.mode = Ray.ALL;
	    options.from = from;
	    options.to = to;
	    options.callback = callback;
	    return tmpRay.intersectWorld(this, options);
	};

	/**
	 * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
	 * @method raycastAny
	 * @param  {Vec3} from
	 * @param  {Vec3} to
	 * @param  {Object} options
	 * @param  {number} [options.collisionFilterMask=-1]
	 * @param  {number} [options.collisionFilterGroup=-1]
	 * @param  {boolean} [options.skipBackfaces=false]
	 * @param  {boolean} [options.checkCollisionResponse=true]
	 * @param  {RaycastResult} result
	 * @return {boolean} True if any body was hit.
	 */
	World.prototype.raycastAny = function(from, to, options, result){
	    options.mode = Ray.ANY;
	    options.from = from;
	    options.to = to;
	    options.result = result;
	    return tmpRay.intersectWorld(this, options);
	};

	/**
	 * Ray cast, and return information of the closest hit.
	 * @method raycastClosest
	 * @param  {Vec3} from
	 * @param  {Vec3} to
	 * @param  {Object} options
	 * @param  {number} [options.collisionFilterMask=-1]
	 * @param  {number} [options.collisionFilterGroup=-1]
	 * @param  {boolean} [options.skipBackfaces=false]
	 * @param  {boolean} [options.checkCollisionResponse=true]
	 * @param  {RaycastResult} result
	 * @return {boolean} True if any body was hit.
	 */
	World.prototype.raycastClosest = function(from, to, options, result){
	    options.mode = Ray.CLOSEST;
	    options.from = from;
	    options.to = to;
	    options.result = result;
	    return tmpRay.intersectWorld(this, options);
	};

	/**
	 * Remove a rigid body from the simulation.
	 * @method remove
	 * @param {Body} body
	 * @deprecated Use .removeBody instead
	 */
	World.prototype.remove = function(body){
	    body.world = null;
	    var n = this.bodies.length-1,
	        bodies = this.bodies,
	        idx = bodies.indexOf(body);
	    if(idx !== -1){
	        bodies.splice(idx, 1); // Todo: should use a garbage free method

	        // Recompute index
	        for(var i=0; i!==bodies.length; i++){
	            bodies[i].index = i;
	        }

	        this.collisionMatrix.setNumObjects(n);
	        this.removeBodyEvent.body = body;
	        this.dispatchEvent(this.removeBodyEvent);
	    }
	};

	/**
	 * Remove a rigid body from the simulation.
	 * @method removeBody
	 * @param {Body} body
	 */
	World.prototype.removeBody = World.prototype.remove;

	/**
	 * Adds a material to the World.
	 * @method addMaterial
	 * @param {Material} m
	 * @todo Necessary?
	 */
	World.prototype.addMaterial = function(m){
	    this.materials.push(m);
	};

	/**
	 * Adds a contact material to the World
	 * @method addContactMaterial
	 * @param {ContactMaterial} cmat
	 */
	World.prototype.addContactMaterial = function(cmat) {

	    // Add contact material
	    this.contactmaterials.push(cmat);

	    // Add current contact material to the material table
	    this.contactMaterialTable.set(cmat.materials[0].id,cmat.materials[1].id,cmat);
	};

	// performance.now()
	if(typeof performance === 'undefined'){
	    performance = {};
	}
	if(!performance.now){
	    var nowOffset = Date.now();
	    if (performance.timing && performance.timing.navigationStart){
	        nowOffset = performance.timing.navigationStart;
	    }
	    performance.now = function(){
	        return Date.now() - nowOffset;
	    };
	}

	var step_tmp1 = new Vec3();

	/**
	 * Step the physics world forward in time.
	 *
	 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
	 *
	 * @method step
	 * @param {Number} dt                       The fixed time step size to use.
	 * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.
	 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
	 *
	 * @example
	 *     // fixed timestepping without interpolation
	 *     world.step(1/60);
	 *
	 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
	 */
	World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps){
	    maxSubSteps = maxSubSteps || 10;
	    timeSinceLastCalled = timeSinceLastCalled || 0;

	    if(timeSinceLastCalled === 0){ // Fixed, simple stepping

	        this.internalStep(dt);

	        // Increment time
	        this.time += dt;

	    } else {

	        // Compute the number of fixed steps we should have taken since the last step
	        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
	        internalSteps = Math.min(internalSteps,maxSubSteps);

	        // Do some fixed steps to catch up
	        var t0 = performance.now();
	        for(var i=0; i!==internalSteps; i++){
	            this.internalStep(dt);
	            if(performance.now() - t0 > dt * 1000){
	                // We are slower than real-time. Better bail out.
	                break;
	            }
	        }

	        // Increment internal clock
	        this.time += timeSinceLastCalled;

	        // Compute "Left over" time step
	        var h = this.time % dt;
	        var h_div_dt = h / dt;
	        var interpvelo = step_tmp1;
	        var bodies = this.bodies;

	        for(var j=0; j !== bodies.length; j++){
	            var b = bodies[j];
	            if(b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING){

	                // Interpolate
	                b.position.vsub(b.previousPosition, interpvelo);
	                interpvelo.scale(h_div_dt, interpvelo);
	                b.position.vadd(interpvelo, b.interpolatedPosition);

	                // TODO: interpolate quaternion
	                // b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;

	            } else {

	                // For static bodies, just copy. Who else will do it?
	                b.interpolatedPosition.copy(b.position);
	                b.interpolatedQuaternion.copy(b.quaternion);
	            }
	        }
	    }
	};

	/**
	 * Step the simulation
	 * @method step
	 * @param {Number} dt
	 */
	var World_step_postStepEvent = {type:"postStep"}, // Reusable event objects to save memory
	    World_step_preStepEvent = {type:"preStep"},
	    World_step_collideEvent = {type:"collide", body:null, contact:null },
	    World_step_oldContacts = [], // Pools for unused objects
	    World_step_frictionEquationPool = [],
	    World_step_p1 = [], // Reusable arrays for collision pairs
	    World_step_p2 = [],
	    World_step_gvec = new Vec3(), // Temporary vectors and quats
	    World_step_vi = new Vec3(),
	    World_step_vj = new Vec3(),
	    World_step_wi = new Vec3(),
	    World_step_wj = new Vec3(),
	    World_step_t1 = new Vec3(),
	    World_step_t2 = new Vec3(),
	    World_step_rixn = new Vec3(),
	    World_step_rjxn = new Vec3(),
	    World_step_step_q = new Quaternion(),
	    World_step_step_w = new Quaternion(),
	    World_step_step_wq = new Quaternion(),
	    invI_tau_dt = new Vec3();
	World.prototype.internalStep = function(dt){
	    this.dt = dt;

	    var world = this,
	        that = this,
	        contacts = this.contacts,
	        p1 = World_step_p1,
	        p2 = World_step_p2,
	        N = this.numObjects(),
	        bodies = this.bodies,
	        solver = this.solver,
	        gravity = this.gravity,
	        doProfiling = this.doProfiling,
	        profile = this.profile,
	        DYNAMIC = Body.DYNAMIC,
	        profilingStart,
	        constraints = this.constraints,
	        frictionEquationPool = World_step_frictionEquationPool,
	        gnorm = gravity.norm(),
	        gx = gravity.x,
	        gy = gravity.y,
	        gz = gravity.z,
	        i=0;

	    if(doProfiling){
	        profilingStart = performance.now();
	    }

	    // Add gravity to all objects
	    for(i=0; i!==N; i++){
	        var bi = bodies[i];
	        if(bi.type & DYNAMIC){ // Only for dynamic bodies
	            var f = bi.force, m = bi.mass;
	            f.x += m*gx;
	            f.y += m*gy;
	            f.z += m*gz;
	        }
	    }

	    // Update subsystems
	    for(var i=0, Nsubsystems=this.subsystems.length; i!==Nsubsystems; i++){
	        this.subsystems[i].update();
	    }

	    // Collision detection
	    if(doProfiling){ profilingStart = performance.now(); }
	    p1.length = 0; // Clean up pair arrays from last step
	    p2.length = 0;
	    this.broadphase.collisionPairs(this,p1,p2);
	    if(doProfiling){ profile.broadphase = performance.now() - profilingStart; }

	    // Remove constrained pairs with collideConnected == false
	    var Nconstraints = constraints.length;
	    for(i=0; i!==Nconstraints; i++){
	        var c = constraints[i];
	        if(!c.collideConnected){
	            for(var j = p1.length-1; j>=0; j-=1){
	                if( (c.bodyA === p1[j] && c.bodyB === p2[j]) ||
	                    (c.bodyB === p1[j] && c.bodyA === p2[j])){
	                    p1.splice(j, 1);
	                    p2.splice(j, 1);
	                }
	            }
	        }
	    }

	    this.collisionMatrixTick();

	    // Generate contacts
	    if(doProfiling){ profilingStart = performance.now(); }
	    var oldcontacts = World_step_oldContacts;
	    var NoldContacts = contacts.length;

	    for(i=0; i!==NoldContacts; i++){
	        oldcontacts.push(contacts[i]);
	    }
	    contacts.length = 0;

	    // Transfer FrictionEquation from current list to the pool for reuse
	    var NoldFrictionEquations = this.frictionEquations.length;
	    for(i=0; i!==NoldFrictionEquations; i++){
	        frictionEquationPool.push(this.frictionEquations[i]);
	    }
	    this.frictionEquations.length = 0;

	    this.narrowphase.getContacts(
	        p1,
	        p2,
	        this,
	        contacts,
	        oldcontacts, // To be reused
	        this.frictionEquations,
	        frictionEquationPool
	    );

	    if(doProfiling){
	        profile.narrowphase = performance.now() - profilingStart;
	    }

	    // Loop over all collisions
	    if(doProfiling){
	        profilingStart = performance.now();
	    }

	    // Add all friction eqs
	    for (var i = 0; i < this.frictionEquations.length; i++) {
	        solver.addEquation(this.frictionEquations[i]);
	    }

	    var ncontacts = contacts.length;
	    for(var k=0; k!==ncontacts; k++){

	        // Current contact
	        var c = contacts[k];

	        // Get current collision indeces
	        var bi = c.bi,
	            bj = c.bj,
	            si = c.si,
	            sj = c.sj;

	        // Get collision properties
	        var cm;
	        if(bi.material && bj.material){
	            cm = this.getContactMaterial(bi.material,bj.material) || this.defaultContactMaterial;
	        } else {
	            cm = this.defaultContactMaterial;
	        }

	        // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

	        var mu = cm.friction;
	        // c.restitution = cm.restitution;

	        // If friction or restitution were specified in the material, use them
	        if(bi.material && bj.material){
	            if(bi.material.friction >= 0 && bj.material.friction >= 0){
	                mu = bi.material.friction * bj.material.friction;
	            }

	            if(bi.material.restitution >= 0 && bj.material.restitution >= 0){
	                c.restitution = bi.material.restitution * bj.material.restitution;
	            }
	        }

			// c.setSpookParams(
	  //           cm.contactEquationStiffness,
	  //           cm.contactEquationRelaxation,
	  //           dt
	  //       );

			solver.addEquation(c);

			// // Add friction constraint equation
			// if(mu > 0){

			// 	// Create 2 tangent equations
			// 	var mug = mu * gnorm;
			// 	var reducedMass = (bi.invMass + bj.invMass);
			// 	if(reducedMass > 0){
			// 		reducedMass = 1/reducedMass;
			// 	}
			// 	var pool = frictionEquationPool;
			// 	var c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
			// 	var c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
			// 	this.frictionEquations.push(c1, c2);

			// 	c1.bi = c2.bi = bi;
			// 	c1.bj = c2.bj = bj;
			// 	c1.minForce = c2.minForce = -mug*reducedMass;
			// 	c1.maxForce = c2.maxForce = mug*reducedMass;

			// 	// Copy over the relative vectors
			// 	c1.ri.copy(c.ri);
			// 	c1.rj.copy(c.rj);
			// 	c2.ri.copy(c.ri);
			// 	c2.rj.copy(c.rj);

			// 	// Construct tangents
			// 	c.ni.tangents(c1.t, c2.t);

	  //           // Set spook params
	  //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
	  //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);

	  //           c1.enabled = c2.enabled = c.enabled;

			// 	// Add equations to solver
			// 	solver.addEquation(c1);
			// 	solver.addEquation(c2);
			// }

	        if( bi.allowSleep &&
	            bi.type === Body.DYNAMIC &&
	            bi.sleepState  === Body.SLEEPING &&
	            bj.sleepState  === Body.AWAKE &&
	            bj.type !== Body.STATIC
	        ){
	            var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();
	            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
	            if(speedSquaredB >= speedLimitSquaredB*2){
	                bi._wakeUpAfterNarrowphase = true;
	            }
	        }

	        if( bj.allowSleep &&
	            bj.type === Body.DYNAMIC &&
	            bj.sleepState  === Body.SLEEPING &&
	            bi.sleepState  === Body.AWAKE &&
	            bi.type !== Body.STATIC
	        ){
	            var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();
	            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
	            if(speedSquaredA >= speedLimitSquaredA*2){
	                bj._wakeUpAfterNarrowphase = true;
	            }
	        }

	        // Now we know that i and j are in contact. Set collision matrix state
			this.collisionMatrix.set(bi, bj, true);

	        if (!this.collisionMatrixPrevious.get(bi, bj)) {
	            // First contact!
	            // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
	            World_step_collideEvent.body = bj;
	            World_step_collideEvent.contact = c;
	            bi.dispatchEvent(World_step_collideEvent);

	            World_step_collideEvent.body = bi;
	            bj.dispatchEvent(World_step_collideEvent);
	        }
	    }
	    if(doProfiling){
	        profile.makeContactConstraints = performance.now() - profilingStart;
	        profilingStart = performance.now();
	    }

	    // Wake up bodies
	    for(i=0; i!==N; i++){
	        var bi = bodies[i];
	        if(bi._wakeUpAfterNarrowphase){
	            bi.wakeUp();
	            bi._wakeUpAfterNarrowphase = false;
	        }
	    }

	    // Add user-added constraints
	    var Nconstraints = constraints.length;
	    for(i=0; i!==Nconstraints; i++){
	        var c = constraints[i];
	        c.update();
	        for(var j=0, Neq=c.equations.length; j!==Neq; j++){
	            var eq = c.equations[j];
	            solver.addEquation(eq);
	        }
	    }

	    // Solve the constrained system
	    solver.solve(dt,this);

	    if(doProfiling){
	        profile.solve = performance.now() - profilingStart;
	    }

	    // Remove all contacts from solver
	    solver.removeAllEquations();

	    // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details
	    var pow = Math.pow;
	    for(i=0; i!==N; i++){
	        var bi = bodies[i];
	        if(bi.type & DYNAMIC){ // Only for dynamic bodies
	            var ld = pow(1.0 - bi.linearDamping,dt);
	            var v = bi.velocity;
	            v.mult(ld,v);
	            var av = bi.angularVelocity;
	            if(av){
	                var ad = pow(1.0 - bi.angularDamping,dt);
	                av.mult(ad,av);
	            }
	        }
	    }

	    this.dispatchEvent(World_step_preStepEvent);

	    // Invoke pre-step callbacks
	    for(i=0; i!==N; i++){
	        var bi = bodies[i];
	        if(bi.preStep){
	            bi.preStep.call(bi);
	        }
	    }

	    // Leap frog
	    // vnew = v + h*f/m
	    // xnew = x + h*vnew
	    if(doProfiling){
	        profilingStart = performance.now();
	    }
	    var q = World_step_step_q;
	    var w = World_step_step_w;
	    var wq = World_step_step_wq;
	    var stepnumber = this.stepnumber;
	    var DYNAMIC_OR_KINEMATIC = Body.DYNAMIC | Body.KINEMATIC;
	    var quatNormalize = stepnumber % (this.quatNormalizeSkip+1) === 0;
	    var quatNormalizeFast = this.quatNormalizeFast;
	    var half_dt = dt * 0.5;
	    var PLANE = Shape.types.PLANE,
	        CONVEX = Shape.types.CONVEXPOLYHEDRON;

	    for(i=0; i!==N; i++){
	        var b = bodies[i],
	            force = b.force,
	            tau = b.torque;
	        if((b.type & DYNAMIC_OR_KINEMATIC) && b.sleepState !== Body.SLEEPING){ // Only for dynamic
	            var velo = b.velocity,
	                angularVelo = b.angularVelocity,
	                pos = b.position,
	                quat = b.quaternion,
	                invMass = b.invMass,
	                invInertia = b.invInertiaWorld;

	            velo.x += force.x * invMass * dt;
	            velo.y += force.y * invMass * dt;
	            velo.z += force.z * invMass * dt;

	            if(b.angularVelocity){
	                invInertia.vmult(tau,invI_tau_dt);
	                invI_tau_dt.mult(dt,invI_tau_dt);
	                invI_tau_dt.vadd(angularVelo,angularVelo);
	            }

	            // Use new velocity  - leap frog
	            pos.x += velo.x * dt;
	            pos.y += velo.y * dt;
	            pos.z += velo.z * dt;

	            if(b.angularVelocity){
	                w.set(angularVelo.x, angularVelo.y, angularVelo.z, 0);
	                w.mult(quat,wq);
	                quat.x += half_dt * wq.x;
	                quat.y += half_dt * wq.y;
	                quat.z += half_dt * wq.z;
	                quat.w += half_dt * wq.w;
	                if(quatNormalize){
	                    if(quatNormalizeFast){
	                        quat.normalizeFast();
	                    } else {
	                        quat.normalize();
	                    }
	                }
	            }

	            if(b.aabb){
	                b.aabbNeedsUpdate = true;
	            }

	            // Update world inertia
	            if(b.updateInertiaWorld){
	                b.updateInertiaWorld();
	            }
	        }
	    }
	    this.clearForces();

	    this.broadphase.dirty = true;

	    if(doProfiling){
	        profile.integrate = performance.now() - profilingStart;
	    }

	    // Update world time
	    this.time += dt;
	    this.stepnumber += 1;

	    this.dispatchEvent(World_step_postStepEvent);

	    // Invoke post-step callbacks
	    for(i=0; i!==N; i++){
	        var bi = bodies[i];
	        var postStep = bi.postStep;
	        if(postStep){
	            postStep.call(bi);
	        }
	    }

	    // Sleeping update
	    if(this.allowSleep){
	        for(i=0; i!==N; i++){
	            bodies[i].sleepTick(this.time);
	        }
	    }
	};

	/**
	 * Sets all body forces in the world to zero.
	 * @method clearForces
	 */
	World.prototype.clearForces = function(){
	    var bodies = this.bodies;
	    var N = bodies.length;
	    for(var i=0; i !== N; i++){
	        var b = bodies[i],
	            force = b.force,
	            tau = b.torque;

	        b.force.set(0,0,0);
	        b.torque.set(0,0,0);
	    }
	};

	},{"../collision/AABB":3,"../collision/ArrayCollisionMatrix":4,"../collision/NaiveBroadphase":7,"../collision/Ray":9,"../collision/RaycastResult":10,"../equations/ContactEquation":19,"../equations/FrictionEquation":21,"../material/ContactMaterial":24,"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Shape":43,"../solver/GSSolver":46,"../utils/EventTarget":49,"../utils/TupleDictionary":52,"../utils/Vec3Pool":54,"./Narrowphase":55}]},{},[2])
	(2)
	});

/***/ },
/* 197 */
/*!*****************************************!*\
  !*** ./~/three-orbit-controls/index.js ***!
  \*****************************************/
/***/ function(module, exports) {

	module.exports = function(THREE) {
	    var MOUSE = THREE.MOUSE
	    if (!MOUSE)
	        MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

	    /**
	     * @author qiao / https://github.com/qiao
	     * @author mrdoob / http://mrdoob.com
	     * @author alteredq / http://alteredqualia.com/
	     * @author WestLangley / http://github.com/WestLangley
	     * @author erich666 / http://erichaines.com
	     */
	    /*global THREE, console */

	    // This set of controls performs orbiting, dollying (zooming), and panning. It maintains
	    // the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
	    // supported.
	    //
	    //    Orbit - left mouse / touch: one finger move
	    //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
	    //    Pan - right mouse, or arrow keys / touch: three finter swipe

	    function OrbitControls ( object, domElement ) {

	        this.object = object;
	        this.domElement = ( domElement !== undefined ) ? domElement : document;

	        // API

	        // Set to false to disable this control
	        this.enabled = true;

	        // "target" sets the location of focus, where the control orbits around
	        // and where it pans with respect to.
	        this.target = new THREE.Vector3();

	        // center is old, deprecated; use "target" instead
	        this.center = this.target;

	        // This option actually enables dollying in and out; left as "zoom" for
	        // backwards compatibility
	        this.noZoom = false;
	        this.zoomSpeed = 1.0;

	        // Limits to how far you can dolly in and out ( PerspectiveCamera only )
	        this.minDistance = 0;
	        this.maxDistance = Infinity;

	        // Limits to how far you can zoom in and out ( OrthographicCamera only )
	        this.minZoom = 0;
	        this.maxZoom = Infinity;

	        // Set to true to disable this control
	        this.noRotate = false;
	        this.rotateSpeed = 1.0;

	        // Set to true to disable this control
	        this.noPan = false;
	        this.keyPanSpeed = 7.0; // pixels moved per arrow key push

	        // Set to true to automatically rotate around the target
	        this.autoRotate = false;
	        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	        // How far you can orbit vertically, upper and lower limits.
	        // Range is 0 to Math.PI radians.
	        this.minPolarAngle = 0; // radians
	        this.maxPolarAngle = Math.PI; // radians

	        // How far you can orbit horizontally, upper and lower limits.
	        // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	        this.minAzimuthAngle = - Infinity; // radians
	        this.maxAzimuthAngle = Infinity; // radians

	        // Set to true to disable use of the keys
	        this.noKeys = false;

	        // The four arrow keys
	        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	        // Mouse buttons
	        this.mouseButtons = { ORBIT: MOUSE.LEFT, ZOOM: MOUSE.MIDDLE, PAN: MOUSE.RIGHT };

	        ////////////
	        // internals

	        var scope = this;

	        var EPS = 0.000001;

	        var rotateStart = new THREE.Vector2();
	        var rotateEnd = new THREE.Vector2();
	        var rotateDelta = new THREE.Vector2();

	        var panStart = new THREE.Vector2();
	        var panEnd = new THREE.Vector2();
	        var panDelta = new THREE.Vector2();
	        var panOffset = new THREE.Vector3();

	        var offset = new THREE.Vector3();

	        var dollyStart = new THREE.Vector2();
	        var dollyEnd = new THREE.Vector2();
	        var dollyDelta = new THREE.Vector2();

	        var theta;
	        var phi;
	        var phiDelta = 0;
	        var thetaDelta = 0;
	        var scale = 1;
	        var pan = new THREE.Vector3();

	        var lastPosition = new THREE.Vector3();
	        var lastQuaternion = new THREE.Quaternion();

	        var STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };

	        var state = STATE.NONE;

	        // for reset

	        this.target0 = this.target.clone();
	        this.position0 = this.object.position.clone();
	        this.zoom0 = this.object.zoom;

	        // so camera.up is the orbit axis

	        var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
	        var quatInverse = quat.clone().inverse();

	        // events

	        var changeEvent = { type: 'change' };
	        var startEvent = { type: 'start' };
	        var endEvent = { type: 'end' };

	        this.rotateLeft = function ( angle ) {

	            if ( angle === undefined ) {

	                angle = getAutoRotationAngle();

	            }

	            thetaDelta -= angle;

	        };

	        this.rotateUp = function ( angle ) {

	            if ( angle === undefined ) {

	                angle = getAutoRotationAngle();

	            }

	            phiDelta -= angle;

	        };

	        // pass in distance in world space to move left
	        this.panLeft = function ( distance ) {

	            var te = this.object.matrix.elements;

	            // get X column of matrix
	            panOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );
	            panOffset.multiplyScalar( - distance );

	            pan.add( panOffset );

	        };

	        // pass in distance in world space to move up
	        this.panUp = function ( distance ) {

	            var te = this.object.matrix.elements;

	            // get Y column of matrix
	            panOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );
	            panOffset.multiplyScalar( distance );

	            pan.add( panOffset );

	        };

	        // pass in x,y of change desired in pixel space,
	        // right and down are positive
	        this.pan = function ( deltaX, deltaY ) {

	            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

	            if ( scope.object instanceof THREE.PerspectiveCamera ) {

	                // perspective
	                var position = scope.object.position;
	                var offset = position.clone().sub( scope.target );
	                var targetDistance = offset.length();

	                // half of the fov is center to top of screen
	                targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

	                // we actually don't use screenWidth, since perspective camera is fixed to screen height
	                scope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );
	                scope.panUp( 2 * deltaY * targetDistance / element.clientHeight );

	            } else if ( scope.object instanceof THREE.OrthographicCamera ) {

	                // orthographic
	                scope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );
	                scope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );

	            } else {

	                // camera neither orthographic or perspective
	                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );

	            }

	        };

	        this.dollyIn = function ( dollyScale ) {

	            if ( dollyScale === undefined ) {

	                dollyScale = getZoomScale();

	            }

	            if ( scope.object instanceof THREE.PerspectiveCamera ) {

	                scale /= dollyScale;

	            } else if ( scope.object instanceof THREE.OrthographicCamera ) {

	                scope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom * dollyScale ) );
	                scope.object.updateProjectionMatrix();
	                scope.dispatchEvent( changeEvent );

	            } else {

	                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );

	            }

	        };

	        this.dollyOut = function ( dollyScale ) {

	            if ( dollyScale === undefined ) {

	                dollyScale = getZoomScale();

	            }

	            if ( scope.object instanceof THREE.PerspectiveCamera ) {

	                scale *= dollyScale;

	            } else if ( scope.object instanceof THREE.OrthographicCamera ) {

	                scope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / dollyScale ) );
	                scope.object.updateProjectionMatrix();
	                scope.dispatchEvent( changeEvent );

	            } else {

	                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );

	            }

	        };

	        this.update = function () {

	            var position = this.object.position;

	            offset.copy( position ).sub( this.target );

	            // rotate offset to "y-axis-is-up" space
	            offset.applyQuaternion( quat );

	            // angle from z-axis around y-axis

	            theta = Math.atan2( offset.x, offset.z );

	            // angle from y-axis

	            phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );

	            if ( this.autoRotate && state === STATE.NONE ) {

	                this.rotateLeft( getAutoRotationAngle() );

	            }

	            theta += thetaDelta;
	            phi += phiDelta;

	            // restrict theta to be between desired limits
	            theta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, theta ) );

	            // restrict phi to be between desired limits
	            phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );

	            // restrict phi to be betwee EPS and PI-EPS
	            phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );

	            var radius = offset.length() * scale;

	            // restrict radius to be between desired limits
	            radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );

	            // move target to panned location
	            this.target.add( pan );

	            offset.x = radius * Math.sin( phi ) * Math.sin( theta );
	            offset.y = radius * Math.cos( phi );
	            offset.z = radius * Math.sin( phi ) * Math.cos( theta );

	            // rotate offset back to "camera-up-vector-is-up" space
	            offset.applyQuaternion( quatInverse );

	            position.copy( this.target ).add( offset );

	            this.object.lookAt( this.target );

	            thetaDelta = 0;
	            phiDelta = 0;
	            scale = 1;
	            pan.set( 0, 0, 0 );

	            // update condition is:
	            // min(camera displacement, camera rotation in radians)^2 > EPS
	            // using small-angle approximation cos(x/2) = 1 - x^2 / 8

	            if ( lastPosition.distanceToSquared( this.object.position ) > EPS
	                || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS ) {

	                this.dispatchEvent( changeEvent );

	                lastPosition.copy( this.object.position );
	                lastQuaternion.copy (this.object.quaternion );

	            }

	        };


	        this.reset = function () {

	            state = STATE.NONE;

	            this.target.copy( this.target0 );
	            this.object.position.copy( this.position0 );
	            this.object.zoom = this.zoom0;

	            this.object.updateProjectionMatrix();
	            this.dispatchEvent( changeEvent );

	            this.update();

	        };

	        this.getPolarAngle = function () {

	            return phi;

	        };

	        this.getAzimuthalAngle = function () {

	            return theta

	        };

	        function getAutoRotationAngle() {

	            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

	        }

	        function getZoomScale() {

	            return Math.pow( 0.95, scope.zoomSpeed );

	        }

	        function onMouseDown( event ) {

	            if ( scope.enabled === false ) return;
	            event.preventDefault();

	            if ( event.button === scope.mouseButtons.ORBIT ) {
	                if ( scope.noRotate === true ) return;

	                state = STATE.ROTATE;

	                rotateStart.set( event.clientX, event.clientY );

	            } else if ( event.button === scope.mouseButtons.ZOOM ) {
	                if ( scope.noZoom === true ) return;

	                state = STATE.DOLLY;

	                dollyStart.set( event.clientX, event.clientY );

	            } else if ( event.button === scope.mouseButtons.PAN ) {
	                if ( scope.noPan === true ) return;

	                state = STATE.PAN;

	                panStart.set( event.clientX, event.clientY );

	            }

	            if ( state !== STATE.NONE ) {
	                document.addEventListener( 'mousemove', onMouseMove, false );
	                document.addEventListener( 'mouseup', onMouseUp, false );
	                scope.dispatchEvent( startEvent );
	            }

	        }

	        function onMouseMove( event ) {

	            if ( scope.enabled === false ) return;

	            event.preventDefault();

	            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

	            if ( state === STATE.ROTATE ) {

	                if ( scope.noRotate === true ) return;

	                rotateEnd.set( event.clientX, event.clientY );
	                rotateDelta.subVectors( rotateEnd, rotateStart );

	                // rotating across whole screen goes 360 degrees around
	                scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

	                // rotating up and down along whole screen attempts to go 360, but limited to 180
	                scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

	                rotateStart.copy( rotateEnd );

	            } else if ( state === STATE.DOLLY ) {

	                if ( scope.noZoom === true ) return;

	                dollyEnd.set( event.clientX, event.clientY );
	                dollyDelta.subVectors( dollyEnd, dollyStart );

	                if ( dollyDelta.y > 0 ) {

	                    scope.dollyIn();

	                } else if ( dollyDelta.y < 0 ) {

	                    scope.dollyOut();

	                }

	                dollyStart.copy( dollyEnd );

	            } else if ( state === STATE.PAN ) {

	                if ( scope.noPan === true ) return;

	                panEnd.set( event.clientX, event.clientY );
	                panDelta.subVectors( panEnd, panStart );

	                scope.pan( panDelta.x, panDelta.y );

	                panStart.copy( panEnd );

	            }

	            if ( state !== STATE.NONE ) scope.update();

	        }

	        function onMouseUp( /* event */ ) {

	            if ( scope.enabled === false ) return;

	            document.removeEventListener( 'mousemove', onMouseMove, false );
	            document.removeEventListener( 'mouseup', onMouseUp, false );
	            scope.dispatchEvent( endEvent );
	            state = STATE.NONE;

	        }

	        function onMouseWheel( event ) {

	            if ( scope.enabled === false || scope.noZoom === true || state !== STATE.NONE ) return;

	            event.preventDefault();
	            event.stopPropagation();

	            var delta = 0;

	            if ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9

	                delta = event.wheelDelta;

	            } else if ( event.detail !== undefined ) { // Firefox

	                delta = - event.detail;

	            }

	            if ( delta > 0 ) {

	                scope.dollyOut();

	            } else if ( delta < 0 ) {

	                scope.dollyIn();

	            }

	            scope.update();
	            scope.dispatchEvent( startEvent );
	            scope.dispatchEvent( endEvent );

	        }

	        function onKeyDown( event ) {

	            if ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;

	            switch ( event.keyCode ) {

	                case scope.keys.UP:
	                    scope.pan( 0, scope.keyPanSpeed );
	                    scope.update();
	                    break;

	                case scope.keys.BOTTOM:
	                    scope.pan( 0, - scope.keyPanSpeed );
	                    scope.update();
	                    break;

	                case scope.keys.LEFT:
	                    scope.pan( scope.keyPanSpeed, 0 );
	                    scope.update();
	                    break;

	                case scope.keys.RIGHT:
	                    scope.pan( - scope.keyPanSpeed, 0 );
	                    scope.update();
	                    break;

	            }

	        }

	        function touchstart( event ) {

	            if ( scope.enabled === false ) return;

	            switch ( event.touches.length ) {

	                case 1: // one-fingered touch: rotate

	                    if ( scope.noRotate === true ) return;

	                    state = STATE.TOUCH_ROTATE;

	                    rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
	                    break;

	                case 2: // two-fingered touch: dolly

	                    if ( scope.noZoom === true ) return;

	                    state = STATE.TOUCH_DOLLY;

	                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
	                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
	                    var distance = Math.sqrt( dx * dx + dy * dy );
	                    dollyStart.set( 0, distance );
	                    break;

	                case 3: // three-fingered touch: pan

	                    if ( scope.noPan === true ) return;

	                    state = STATE.TOUCH_PAN;

	                    panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
	                    break;

	                default:

	                    state = STATE.NONE;

	            }

	            if ( state !== STATE.NONE ) scope.dispatchEvent( startEvent );

	        }

	        function touchmove( event ) {

	            if ( scope.enabled === false ) return;

	            event.preventDefault();
	            event.stopPropagation();

	            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

	            switch ( event.touches.length ) {

	                case 1: // one-fingered touch: rotate

	                    if ( scope.noRotate === true ) return;
	                    if ( state !== STATE.TOUCH_ROTATE ) return;

	                    rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
	                    rotateDelta.subVectors( rotateEnd, rotateStart );

	                    // rotating across whole screen goes 360 degrees around
	                    scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
	                    // rotating up and down along whole screen attempts to go 360, but limited to 180
	                    scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

	                    rotateStart.copy( rotateEnd );

	                    scope.update();
	                    break;

	                case 2: // two-fingered touch: dolly

	                    if ( scope.noZoom === true ) return;
	                    if ( state !== STATE.TOUCH_DOLLY ) return;

	                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
	                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
	                    var distance = Math.sqrt( dx * dx + dy * dy );

	                    dollyEnd.set( 0, distance );
	                    dollyDelta.subVectors( dollyEnd, dollyStart );

	                    if ( dollyDelta.y > 0 ) {

	                        scope.dollyOut();

	                    } else if ( dollyDelta.y < 0 ) {

	                        scope.dollyIn();

	                    }

	                    dollyStart.copy( dollyEnd );

	                    scope.update();
	                    break;

	                case 3: // three-fingered touch: pan

	                    if ( scope.noPan === true ) return;
	                    if ( state !== STATE.TOUCH_PAN ) return;

	                    panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
	                    panDelta.subVectors( panEnd, panStart );

	                    scope.pan( panDelta.x, panDelta.y );

	                    panStart.copy( panEnd );

	                    scope.update();
	                    break;

	                default:

	                    state = STATE.NONE;

	            }

	        }

	        function touchend( /* event */ ) {

	            if ( scope.enabled === false ) return;

	            scope.dispatchEvent( endEvent );
	            state = STATE.NONE;

	        }

	        this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
	        this.domElement.addEventListener( 'mousedown', onMouseDown, false );
	        this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
	        this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox

	        this.domElement.addEventListener( 'touchstart', touchstart, false );
	        this.domElement.addEventListener( 'touchend', touchend, false );
	        this.domElement.addEventListener( 'touchmove', touchmove, false );

	        window.addEventListener( 'keydown', onKeyDown, false );

	        // force an update at start
	        this.update();

	    };

	    OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
	    OrbitControls.prototype.constructor = OrbitControls;
	    return OrbitControls;
	}


/***/ },
/* 198 */
/*!********************************************!*\
  !*** ./static/js/vendor/keyboard_state.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	// THREEx.KeyboardState.js keep the current state of the keyboard.
	// It is possible to query it at any time. No need of an event.
	// This is particularly convenient in loop driven case, like in
	// 3D demos or games.
	//
	// # Usage
	//
	// **Step 1**: Create the object
	//
	// ```var keyboard      = new THREEx.KeyboardState();```
	//
	// **Step 2**: Query the keyboard state
	//
	// This will return true if shift and A are pressed, false otherwise
	//
	// ```keyboard.pressed("shift+A")```
	//
	// **Step 3**: Stop listening to the keyboard
	//
	// ```keyboard.destroy()```
	//
	// NOTE: this library may be nice as standaline. independant from three.js
	// - rename it keyboardForGame
	//
	// # Code
	//

	/** @namespace */
	"use strict";

	var _Object$keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ 199)["default"];

	var THREEx = THREEx || {};

	/**
	 * - NOTE: it would be quite easy to push event-driven too
	 *   - microevent.js for events handling
	 *   - in this._onkeyChange, generate a string from the DOM event
	 *   - use this as event name
	*/
	THREEx.KeyboardState = function () {
	    // to store the current state
	    this.keyCodes = {};
	    this.modifiers = {};

	    // create callback to bind/unbind keyboard events
	    var self = this;
	    this._onKeyDown = function (event) {
	        self._onKeyChange(event, true);
	    };
	    this._onKeyUp = function (event) {
	        self._onKeyChange(event, false);
	    };

	    // bind keyEvents
	    document.addEventListener("keydown", this._onKeyDown, false);
	    document.addEventListener("keyup", this._onKeyUp, false);
	};

	/**
	 * To stop listening of the keyboard events
	*/
	THREEx.KeyboardState.prototype.destroy = function () {
	    // unbind keyEvents
	    document.removeEventListener("keydown", this._onKeyDown, false);
	    document.removeEventListener("keyup", this._onKeyUp, false);
	};

	THREEx.KeyboardState.MODIFIERS = ['shift', 'ctrl', 'alt', 'meta'];
	THREEx.KeyboardState.ALIAS = {
	    'left': 37,
	    'up': 38,
	    'right': 39,
	    'down': 40,
	    'space': 32,
	    'pageup': 33,
	    'pagedown': 34,
	    'tab': 9
	};

	/**
	 * to process the keyboard dom event
	*/
	THREEx.KeyboardState.prototype._onKeyChange = function (event, pressed) {
	    // log to debug
	    //console.log("onKeyChange", event, pressed, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey)

	    // update this.keyCodes
	    var keyCode = event.keyCode;
	    this.keyCodes[keyCode] = pressed;

	    // update this.modifiers
	    this.modifiers['shift'] = event.shiftKey;
	    this.modifiers['ctrl'] = event.ctrlKey;
	    this.modifiers['alt'] = event.altKey;
	    this.modifiers['meta'] = event.metaKey;
	};

	/**
	 * query keyboard state to know if a key is pressed of not
	 *
	 * @param {String} keyDesc the description of the key. format : modifiers+key e.g shift+A
	 * @returns {Boolean} true if the key is pressed, false otherwise
	*/
	THREEx.KeyboardState.prototype.pressed = function (keyDesc) {
	    var keys = keyDesc.split("+");
	    for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        var pressed;
	        if (THREEx.KeyboardState.MODIFIERS.indexOf(key) !== -1) {
	            pressed = this.modifiers[key];
	        } else if (_Object$keys(THREEx.KeyboardState.ALIAS).indexOf(key) != -1) {
	            pressed = this.keyCodes[THREEx.KeyboardState.ALIAS[key]];
	        } else {
	            pressed = this.keyCodes[key.toUpperCase().charCodeAt(0)];
	        }
	        if (!pressed) return false;
	    };
	    return true;
	};

	module.exports = THREEx.KeyboardState;

/***/ },
/* 199 */
/*!************************************************!*\
  !*** ./~/babel-runtime/core-js/object/keys.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/keys */ 200), __esModule: true };

/***/ },
/* 200 */
/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/keys.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.object.keys */ 201);
	module.exports = __webpack_require__(/*! ../../modules/$.core */ 207).Object.keys;

/***/ },
/* 201 */
/*!**********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.keys.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(/*! ./$.to-object */ 202);

	__webpack_require__(/*! ./$.object-sap */ 204)('keys', function($keys){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 202 */
/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.to-object.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(/*! ./$.defined */ 203);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 203 */
/*!****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.defined.js ***!
  \****************************************************************/
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 204 */
/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.object-sap.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	module.exports = function(KEY, exec){
	  var $def = __webpack_require__(/*! ./$.def */ 205)
	    , fn   = (__webpack_require__(/*! ./$.core */ 207).Object || {})[KEY] || Object[KEY]
	    , exp  = {};
	  exp[KEY] = exec(fn);
	  $def($def.S + $def.F * __webpack_require__(/*! ./$.fails */ 208)(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 205 */
/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.def.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(/*! ./$.global */ 206)
	  , core      = __webpack_require__(/*! ./$.core */ 207)
	  , PROTOTYPE = 'prototype';
	var ctx = function(fn, that){
	  return function(){
	    return fn.apply(that, arguments);
	  };
	};
	var $def = function(type, name, source){
	  var key, own, out, exp
	    , isGlobal = type & $def.G
	    , isProto  = type & $def.P
	    , target   = isGlobal ? global : type & $def.S
	        ? global[name] : (global[name] || {})[PROTOTYPE]
	    , exports  = isGlobal ? core : core[name] || (core[name] = {});
	  if(isGlobal)source = name;
	  for(key in source){
	    // contains in native
	    own = !(type & $def.F) && target && key in target;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    if(isGlobal && typeof target[key] != 'function')exp = source[key];
	    // bind timers to global for call from export context
	    else if(type & $def.B && own)exp = ctx(out, global);
	    // wrap global constructors for prevent change them in library
	    else if(type & $def.W && target[key] == out)!function(C){
	      exp = function(param){
	        return this instanceof C ? new C(param) : C(param);
	      };
	      exp[PROTOTYPE] = C[PROTOTYPE];
	    }(out);
	    else exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export
	    exports[key] = exp;
	    if(isProto)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
	  }
	};
	// type bitmap
	$def.F = 1;  // forced
	$def.G = 2;  // global
	$def.S = 4;  // static
	$def.P = 8;  // proto
	$def.B = 16; // bind
	$def.W = 32; // wrap
	module.exports = $def;

/***/ },
/* 206 */
/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.global.js ***!
  \***************************************************************/
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 207 */
/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.core.js ***!
  \*************************************************************/
/***/ function(module, exports) {

	var core = module.exports = {version: '1.2.2'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 208 */
/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.fails.js ***!
  \**************************************************************/
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 209 */
/*!*******************************!*\
  !*** ./static/js/util/ecs.js ***!
  \*******************************/
/***/ function(module, exports) {

	"use strict";

	var Entities = {};

	function Entity() {
	    this.id = Entity.prototype._idGen++;
	    Entities[this.id] = this;
	};

	Entity.prototype = {
	    _idGen: 0,

	    addComponent: function addComponent(component) {
	        this[component.name] = component;
	    },

	    removeComponent: function removeComponent(component) {
	        delete this[component.name];
	    },

	    "delete": function _delete() {
	        delete Entities[this.id];
	    }
	};

	function Position(x, y, z) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	};
	Position.prototype.name = "position";

	function THREEObject(object) {};
	THREEObject.prototype.name = "threeObject";

	var Component = { Position: Position, THREEObject: THREEObject };

	module.exports = { Entity: Entity, Entities: Entities, Component: Component };

/***/ },
/* 210 */
/*!**********************************************!*\
  !*** ./static/js/vendor/three/CopyShader.js ***!
  \**********************************************/
/***/ function(module, exports) {

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Full-screen textured quad shader
	 */

	"use strict";

	exports.__esModule = true;
	var CopyShader = {

	    uniforms: {

	        "tDiffuse": { type: "t", value: null },
	        "opacity": { type: "f", value: 1.0 }

	    },

	    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	    fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")

	};

	exports["default"] = CopyShader;
	module.exports = exports["default"];

/***/ },
/* 211 */
/*!*************************************************!*\
  !*** ./static/js/vendor/three/DigitalGlitch.js ***!
  \*************************************************/
/***/ function(module, exports) {

	/**
	 * @author felixturner / http://airtight.cc/
	 *
	 * RGB Shift Shader
	 * Shifts red and blue channels from center in opposite directions
	 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
	 * by Tom Butterworth / http://kriss.cx/tom/
	 *
	 * amount: shift distance (1 is width of input)
	 * angle: shift angle in radians
	 */

	"use strict";

	exports.__esModule = true;
	var DigitalGlitch = {

	    uniforms: {

	        "tDiffuse": { type: "t", value: null }, //diffuse texture
	        "tDisp": { type: "t", value: null }, //displacement texture for digital glitch squares
	        "byp": { type: "i", value: 0 }, //apply the glitch ?
	        "amount": { type: "f", value: 0.08 },
	        "angle": { type: "f", value: 0.02 },
	        "seed": { type: "f", value: 0.02 },
	        "seed_x": { type: "f", value: 0.02 }, //-1,1
	        "seed_y": { type: "f", value: 0.02 }, //-1,1
	        "distortion_x": { type: "f", value: 0.5 },
	        "distortion_y": { type: "f", value: 0.6 },
	        "col_s": { type: "f", value: 0.05 }
	    },

	    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	    fragmentShader: ["uniform int byp;", //should we apply the glitch ?

	    "uniform sampler2D tDiffuse;", "uniform sampler2D tDisp;", "uniform float amount;", "uniform float angle;", "uniform float seed;", "uniform float seed_x;", "uniform float seed_y;", "uniform float distortion_x;", "uniform float distortion_y;", "uniform float col_s;", "varying vec2 vUv;", "float rand(vec2 co){", "return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);", "}", "void main() {", "if(byp<1) {", "vec2 p = vUv;", "float xs = floor(gl_FragCoord.x / 0.5);", "float ys = floor(gl_FragCoord.y / 0.5);",
	    //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch
	    "vec4 normal = texture2D (tDisp, p*seed*seed);", "if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {", "if(seed_x>0.){", "p.y = 1. - (p.y + distortion_y);", "}", "else {", "p.y = distortion_y;", "}", "}", "if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {", "if(seed_y>0.){", "p.x=distortion_x;", "}", "else {", "p.x = 1. - (p.x + distortion_x);", "}", "}", "p.x+=normal.x*seed_x*(seed/5.);", "p.y+=normal.y*seed_y*(seed/5.);",
	    //base from RGB shift shader
	    "vec2 offset = amount * vec2( cos(angle), sin(angle));", "vec4 cr = texture2D(tDiffuse, p + offset);", "vec4 cga = texture2D(tDiffuse, p);", "vec4 cb = texture2D(tDiffuse, p - offset);", "gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",
	    //add noise
	    "vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);", "gl_FragColor = gl_FragColor+ snow;", "}", "else {", "gl_FragColor=texture2D (tDiffuse, vUv);", "}", "}"].join("\n")

	};

	exports["default"] = DigitalGlitch;
	module.exports = exports["default"];

/***/ },
/* 212 */
/*!**************************************************!*\
  !*** ./static/js/vendor/three/EffectComposer.js ***!
  \**************************************************/
/***/ function(module, exports) {

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	"use strict";

	exports.__esModule = true;
	var _EffectComposer = function _EffectComposer(THREE) {
	    var EffectComposer = function EffectComposer(renderer, renderTarget) {

	        this.renderer = renderer;

	        if (renderTarget === undefined) {

	            var pixelRatio = renderer.getPixelRatio();

	            var width = Math.floor(renderer.context.canvas.width / pixelRatio) || 1;
	            var height = Math.floor(renderer.context.canvas.height / pixelRatio) || 1;
	            var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

	            renderTarget = new THREE.WebGLRenderTarget(width, height, parameters);
	        }

	        this.renderTarget1 = renderTarget;
	        this.renderTarget2 = renderTarget.clone();

	        this.writeBuffer = this.renderTarget1;
	        this.readBuffer = this.renderTarget2;

	        this.passes = [];

	        if (THREE.CopyShader === undefined) console.error("THREE.EffectComposer relies on THREE.CopyShader");

	        this.copyPass = new THREE.ShaderPass(THREE.CopyShader);
	    };

	    EffectComposer.prototype = {

	        swapBuffers: function swapBuffers() {

	            var tmp = this.readBuffer;
	            this.readBuffer = this.writeBuffer;
	            this.writeBuffer = tmp;
	        },

	        addPass: function addPass(pass) {

	            this.passes.push(pass);
	        },

	        insertPass: function insertPass(pass, index) {

	            this.passes.splice(index, 0, pass);
	        },

	        render: function render(delta) {

	            this.writeBuffer = this.renderTarget1;
	            this.readBuffer = this.renderTarget2;

	            var maskActive = false;

	            var pass,
	                i,
	                il = this.passes.length;

	            for (i = 0; i < il; i++) {

	                pass = this.passes[i];

	                if (!pass.enabled) continue;

	                pass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);

	                if (pass.needsSwap) {

	                    if (maskActive) {

	                        var context = this.renderer.context;

	                        context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);

	                        this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);

	                        context.stencilFunc(context.EQUAL, 1, 0xffffffff);
	                    }

	                    this.swapBuffers();
	                }

	                if (pass instanceof THREE.MaskPass) {

	                    maskActive = true;
	                } else if (pass instanceof THREE.ClearMaskPass) {

	                    maskActive = false;
	                }
	            }
	        },

	        reset: function reset(renderTarget) {

	            if (renderTarget === undefined) {

	                renderTarget = this.renderTarget1.clone();

	                var pixelRatio = this.renderer.getPixelRatio();

	                renderTarget.width = Math.floor(this.renderer.context.canvas.width / pixelRatio);
	                renderTarget.height = Math.floor(this.renderer.context.canvas.height / pixelRatio);
	            }

	            this.renderTarget1.dispose();
	            this.renderTarget1 = renderTarget;
	            this.renderTarget2.dispose();
	            this.renderTarget2 = renderTarget.clone();

	            this.writeBuffer = this.renderTarget1;
	            this.readBuffer = this.renderTarget2;
	        },

	        setSize: function setSize(width, height) {

	            this.renderTarget1.setSize(width, height);
	            this.renderTarget2.setSize(width, height);
	        }

	    };

	    return EffectComposer;
	};

	exports["default"] = _EffectComposer;
	module.exports = exports["default"];

/***/ },
/* 213 */
/*!**********************************************!*\
  !*** ./static/js/vendor/three/RenderPass.js ***!
  \**********************************************/
/***/ function(module, exports) {

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	"use strict";

	exports.__esModule = true;
	var _RenderPass = function _RenderPass(THREE) {
	    var RenderPass = function RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha) {

	        this.scene = scene;
	        this.camera = camera;

	        this.overrideMaterial = overrideMaterial;

	        this.clearColor = clearColor;
	        this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 1;

	        this.oldClearColor = new THREE.Color();
	        this.oldClearAlpha = 1;

	        this.enabled = true;
	        this.clear = true;
	        this.needsSwap = false;
	    };

	    RenderPass.prototype = {

	        render: function render(renderer, writeBuffer, readBuffer, delta) {

	            this.scene.overrideMaterial = this.overrideMaterial;

	            if (this.clearColor) {

	                this.oldClearColor.copy(renderer.getClearColor());
	                this.oldClearAlpha = renderer.getClearAlpha();

	                renderer.setClearColor(this.clearColor, this.clearAlpha);
	            }

	            renderer.render(this.scene, this.camera, readBuffer, this.clear);

	            if (this.clearColor) {

	                renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
	            }

	            this.scene.overrideMaterial = null;
	        }

	    };

	    return RenderPass;
	};

	exports["default"] = _RenderPass;
	module.exports = exports["default"];

/***/ },
/* 214 */
/*!********************************************!*\
  !*** ./static/js/vendor/three/MaskPass.js ***!
  \********************************************/
/***/ function(module, exports) {

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	"use strict";

	exports.__esModule = true;
	var MaskPass = function MaskPass(scene, camera) {

	    this.scene = scene;
	    this.camera = camera;

	    this.enabled = true;
	    this.clear = true;
	    this.needsSwap = false;

	    this.inverse = false;
	};

	MaskPass.prototype = {

	    render: function render(renderer, writeBuffer, readBuffer, delta) {

	        var context = renderer.context;

	        // don't update color or depth

	        context.colorMask(false, false, false, false);
	        context.depthMask(false);

	        // set up stencil

	        var writeValue, clearValue;

	        if (this.inverse) {

	            writeValue = 0;
	            clearValue = 1;
	        } else {

	            writeValue = 1;
	            clearValue = 0;
	        }

	        context.enable(context.STENCIL_TEST);
	        context.stencilOp(context.REPLACE, context.REPLACE, context.REPLACE);
	        context.stencilFunc(context.ALWAYS, writeValue, 0xffffffff);
	        context.clearStencil(clearValue);

	        // draw into the stencil buffer

	        renderer.render(this.scene, this.camera, readBuffer, this.clear);
	        renderer.render(this.scene, this.camera, writeBuffer, this.clear);

	        // re-enable update of color and depth

	        context.colorMask(true, true, true, true);
	        context.depthMask(true);

	        // only render where stencil is set to 1

	        context.stencilFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
	        context.stencilOp(context.KEEP, context.KEEP, context.KEEP);
	    }

	};

	var ClearMaskPass = function ClearMaskPass() {

	    this.enabled = true;
	};

	ClearMaskPass.prototype = {

	    render: function render(renderer, writeBuffer, readBuffer, delta) {

	        var context = renderer.context;

	        context.disable(context.STENCIL_TEST);
	    }

	};

	exports["default"] = { MaskPass: MaskPass, ClearMaskPass: ClearMaskPass };
	module.exports = exports["default"];

/***/ },
/* 215 */
/*!**********************************************!*\
  !*** ./static/js/vendor/three/ShaderPass.js ***!
  \**********************************************/
/***/ function(module, exports) {

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	"use strict";

	exports.__esModule = true;
	var _ShaderPass = function _ShaderPass(THREE) {
	    var ShaderPass = function ShaderPass(shader, textureID) {

	        this.textureID = textureID !== undefined ? textureID : "tDiffuse";

	        this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);

	        this.material = new THREE.ShaderMaterial({

	            defines: shader.defines || {},
	            uniforms: this.uniforms,
	            vertexShader: shader.vertexShader,
	            fragmentShader: shader.fragmentShader

	        });

	        this.renderToScreen = false;

	        this.enabled = true;
	        this.needsSwap = true;
	        this.clear = false;

	        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	        this.scene = new THREE.Scene();

	        this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	        this.scene.add(this.quad);
	    };

	    ShaderPass.prototype = {

	        render: function render(renderer, writeBuffer, readBuffer, delta) {

	            if (this.uniforms[this.textureID]) {

	                this.uniforms[this.textureID].value = readBuffer;
	            }

	            this.quad.material = this.material;

	            if (this.renderToScreen) {

	                renderer.render(this.scene, this.camera);
	            } else {

	                renderer.render(this.scene, this.camera, writeBuffer, this.clear);
	            }
	        }

	    };

	    return ShaderPass;
	};

	exports["default"] = _ShaderPass;
	module.exports = exports["default"];

/***/ },
/* 216 */
/*!**********************************************!*\
  !*** ./static/js/vendor/three/GlitchPass.js ***!
  \**********************************************/
/***/ function(module, exports) {

	/**
	 
	 */

	"use strict";

	exports.__esModule = true;
	var _GlitchPass = function _GlitchPass(THREE) {

	    var GlitchPass = function GlitchPass(dt_size) {

	        if (THREE.DigitalGlitch === undefined) console.error("THREE.GlitchPass relies on THREE.DigitalGlitch");

	        var shader = THREE.DigitalGlitch;
	        this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);

	        if (dt_size == undefined) dt_size = 64;

	        this.uniforms["tDisp"].value = this.generateHeightmap(dt_size);

	        this.material = new THREE.ShaderMaterial({
	            uniforms: this.uniforms,
	            vertexShader: shader.vertexShader,
	            fragmentShader: shader.fragmentShader
	        });

	        this.enabled = true;
	        this.renderToScreen = false;
	        this.needsSwap = true;

	        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	        this.scene = new THREE.Scene();

	        this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	        this.scene.add(this.quad);

	        this.goWild = false;
	        this.curF = 0;
	        this.generateTrigger();
	    };

	    GlitchPass.prototype = {

	        render: function render(renderer, writeBuffer, readBuffer, delta) {

	            this.uniforms["tDiffuse"].value = readBuffer;
	            this.uniforms['seed'].value = Math.random(); //default seeding
	            this.uniforms['byp'].value = 0;

	            if (this.curF % this.randX == 0 || this.goWild == true) {

	                this.uniforms['amount'].value = Math.random() / 30;
	                this.uniforms['angle'].value = THREE.Math.randFloat(-Math.PI, Math.PI);
	                this.uniforms['seed_x'].value = THREE.Math.randFloat(-1, 1);
	                this.uniforms['seed_y'].value = THREE.Math.randFloat(-1, 1);
	                this.uniforms['distortion_x'].value = THREE.Math.randFloat(0, 1);
	                this.uniforms['distortion_y'].value = THREE.Math.randFloat(0, 1);
	                this.curF = 0;
	                this.generateTrigger();
	            } else if (this.curF % this.randX < this.randX / 5) {

	                this.uniforms['amount'].value = Math.random() / 90;
	                this.uniforms['angle'].value = THREE.Math.randFloat(-Math.PI, Math.PI);
	                this.uniforms['distortion_x'].value = THREE.Math.randFloat(0, 1);
	                this.uniforms['distortion_y'].value = THREE.Math.randFloat(0, 1);
	                this.uniforms['seed_x'].value = THREE.Math.randFloat(-0.3, 0.3);
	                this.uniforms['seed_y'].value = THREE.Math.randFloat(-0.3, 0.3);
	            } else if (this.goWild == false) {

	                this.uniforms['byp'].value = 1;
	            }
	            this.curF++;

	            this.quad.material = this.material;
	            if (this.renderToScreen) {

	                renderer.render(this.scene, this.camera);
	            } else {

	                renderer.render(this.scene, this.camera, writeBuffer, false);
	            }
	        },
	        generateTrigger: function generateTrigger() {

	            this.randX = THREE.Math.randInt(120, 240);
	        },
	        generateHeightmap: function generateHeightmap(dt_size) {

	            var data_arr = new Float32Array(dt_size * dt_size * 3);
	            var length = dt_size * dt_size;

	            for (var i = 0; i < length; i++) {

	                var val = THREE.Math.randFloat(0, 1);
	                data_arr[i * 3 + 0] = val;
	                data_arr[i * 3 + 1] = val;
	                data_arr[i * 3 + 2] = val;
	            }

	            var texture = new THREE.DataTexture(data_arr, dt_size, dt_size, THREE.RGBFormat, THREE.FloatType);
	            texture.needsUpdate = true;
	            return texture;
	        }
	    };

	    return GlitchPass;
	};

	exports["default"] = _GlitchPass;
	module.exports = exports["default"];

/***/ },
/* 217 */
/*!********************************!*\
  !*** ./static/js/materials.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _engine = __webpack_require__(/*! engine */ 194);

	var SLIPPERY = new _engine.CANNON.Material("slipperyMaterial", { friction: 0.0 });
	var NORMAL = new _engine.CANNON.Material("normalMaterial", { friction: 0.3 });

	exports["default"] = {
	    SLIPPERY: SLIPPERY,
	    NORMAL: NORMAL
	};
	module.exports = exports["default"];

/***/ },
/* 218 */
/*!****************************!*\
  !*** ./static/js/props.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 1)["default"];

	exports.__esModule = true;

	var _engine = __webpack_require__(/*! engine */ 194);

	var _constMaterial = __webpack_require__(/*! const/material */ 219);

	var _constMaterial2 = _interopRequireDefault(_constMaterial);

	var Sun = function Sun(radius) {
	    var segments = arguments.length <= 1 || arguments[1] === undefined ? 32 : arguments[1];

	    var light = new _engine.THREE.PointLight(_constMaterial2["default"].SUN.color.getHex(), 0.8, 10000);
	    var geometry = new _engine.THREE.SphereGeometry(radius, segments, segments);
	    var mesh = new _engine.THREE.Mesh(geometry, _constMaterial2["default"].SUN);
	    light.add(mesh);
	    return light;
	};

	exports.Sun = Sun;
	var Grid = function Grid(chunkSize, stepSize) {
	    var grid = new _engine.THREE.GridHelper(chunkSize, stepSize);
	    grid.position.set(-stepSize / 2, 0, -stepSize / 2);
	    return grid;
	};

	exports.Grid = Grid;
	// adapted from http://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/

	var LINE_WIDTH = 3;

	function buildAxis(dest, hex) {
	    var dashed = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

	    var geometry = new _engine.THREE.Geometry();
	    var material;

	    if (dashed) {
	        material = new _engine.THREE.LineDashedMaterial({ linewidth: LINE_WIDTH, color: hex, dashSize: LINE_WIDTH, gapSize: LINE_WIDTH });
	    } else {
	        material = new _engine.THREE.LineBasicMaterial({ linewidth: LINE_WIDTH, color: hex });
	    }

	    geometry.vertices.push(new _engine.THREE.Vector3(0, 0, 0));
	    geometry.vertices.push(dest.clone());
	    geometry.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

	    return new _engine.THREE.Line(geometry, material, _engine.THREE.LineSegments);
	};

	var Axes = function Axes(length) {
	    var axes = new _engine.THREE.Object3D();
	    axes.add(buildAxis(new _engine.THREE.Vector3(length, 0, 0), 0xFF0000, false)); // +X
	    axes.add(buildAxis(new _engine.THREE.Vector3(-length, 0, 0), 0xFF0000, true)); // -X
	    axes.add(buildAxis(new _engine.THREE.Vector3(0, length, 0), 0x00FF00, false)); // +Y
	    axes.add(buildAxis(new _engine.THREE.Vector3(0, -length, 0), 0x00FF00, true)); // -Y
	    axes.add(buildAxis(new _engine.THREE.Vector3(0, 0, length), 0x0000FF, false)); // +Z
	    axes.add(buildAxis(new _engine.THREE.Vector3(0, 0, -length), 0x0000FF, true)); // -Z
	    return axes;
	};
	exports.Axes = Axes;

/***/ },
/* 219 */
/*!*************************************!*\
  !*** ./static/js/const/material.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _engine = __webpack_require__(/*! engine */ 194);

	module.exports = {
	    GROUND: new _engine.THREE.MeshPhongMaterial({
	        color: 0x882244,
	        emissive: 0x002200,
	        side: _engine.THREE.DoubleSide,
	        shininess: 10,
	        shading: _engine.THREE.FlatShading
	    }),
	    WATER: new _engine.THREE.MeshPhongMaterial({
	        color: 0x8844AA,
	        transparent: true,
	        opacity: 0.6,
	        emissive: 0x004488,
	        side: _engine.THREE.DoubleSide,
	        shininess: 75,
	        shading: _engine.THREE.FlatShading
	    }),
	    SUN: new _engine.THREE.MeshLambertMaterial({
	        color: 0xFFAA66,
	        side: _engine.THREE.BackSide
	    }),
	    STAR: new _engine.THREE.MeshBasicMaterial({
	        color: 0xDDDDFF
	    })
	};

/***/ },
/* 220 */
/*!*******************************!*\
  !*** ./static/js/util/gui.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 1)["default"];

	exports.__esModule = true;

	var _vendorDatGui = __webpack_require__(/*! vendor/dat.gui */ 221);

	var _vendorDatGui2 = _interopRequireDefault(_vendorDatGui);

	var dat = _vendorDatGui2["default"];
	exports.dat = dat;
	var toggleObject = function toggleObject(name, config, scene) {
	    var autoAdd = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];

	    var callback = function callback(enabled) {
	        if (enabled) {
	            scene.add(config["_" + name]);
	        } else {
	            scene.remove(config["_" + name]);
	        }
	    };

	    if (autoAdd) {
	        callback(true);
	    }

	    return callback;
	};
	exports.toggleObject = toggleObject;

/***/ },
/* 221 */
/*!*************************************!*\
  !*** ./static/js/vendor/dat.gui.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * dat-gui JavaScript Controller Library
	 * http://code.google.com/p/dat-gui
	 *
	 * Copyright 2011 Data Arts Team, Google Creative Lab
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 */ /** @namespace */'use strict';var _Object$defineProperties=__webpack_require__(/*! babel-runtime/core-js/object/define-properties */ 222)['default'];var _Object$defineProperty=__webpack_require__(/*! babel-runtime/core-js/object/define-property */ 225)['default'];var dat=dat || {}; /** @namespace */dat.gui = dat.gui || {}; /** @namespace */dat.utils = dat.utils || {}; /** @namespace */dat.controllers = dat.controllers || {}; /** @namespace */dat.dom = dat.dom || {}; /** @namespace */dat.color = dat.color || {};dat.utils.css = (function(){return {load:function load(url,doc){doc = doc || document;var link=doc.createElement('link');link.type = 'text/css';link.rel = 'stylesheet';link.href = url;doc.getElementsByTagName('head')[0].appendChild(link);},inject:function inject(css,doc){doc = doc || document;var injected=document.createElement('style');injected.type = 'text/css';injected.innerHTML = css;doc.getElementsByTagName('head')[0].appendChild(injected);}};})();dat.utils.common = (function(){var ARR_EACH=Array.prototype.forEach;var ARR_SLICE=Array.prototype.slice; /**
	   * Band-aid methods for things that should be a lot easier in JavaScript.
	   * Implementation and structure inspired by underscore.js
	   * http://documentcloud.github.com/underscore/
	   */return {BREAK:{},extend:function extend(target){this.each(ARR_SLICE.call(arguments,1),function(obj){for(var key in obj) if(!this.isUndefined(obj[key]))target[key] = obj[key];},this);return target;},defaults:function defaults(target){this.each(ARR_SLICE.call(arguments,1),function(obj){for(var key in obj) if(this.isUndefined(target[key]))target[key] = obj[key];},this);return target;},compose:function compose(){var toCall=ARR_SLICE.call(arguments);return function(){var args=ARR_SLICE.call(arguments);for(var i=toCall.length - 1;i >= 0;i--) {args = [toCall[i].apply(this,args)];}return args[0];};},each:function each(obj,itr,scope){if(!obj)return;if(ARR_EACH && obj.forEach && obj.forEach === ARR_EACH){obj.forEach(itr,scope);}else if(obj.length === obj.length + 0){ // Is number but not NaN
	for(var key=0,l=obj.length;key < l;key++) if(key in obj && itr.call(scope,obj[key],key) === this.BREAK)return;}else {for(var key in obj) if(itr.call(scope,obj[key],key) === this.BREAK)return;}},defer:function defer(fnc){setTimeout(fnc,0);},toArray:function toArray(obj){if(obj.toArray)return obj.toArray();return ARR_SLICE.call(obj);},isUndefined:function isUndefined(obj){return obj === undefined;},isNull:function isNull(obj){return obj === null;},isNaN:function isNaN(obj){return obj !== obj;},isArray:Array.isArray || function(obj){return obj.constructor === Array;},isObject:function isObject(obj){return obj === Object(obj);},isNumber:function isNumber(obj){return obj === obj + 0;},isString:function isString(obj){return obj === obj + '';},isBoolean:function isBoolean(obj){return obj === false || obj === true;},isFunction:function isFunction(obj){return Object.prototype.toString.call(obj) === '[object Function]';}};})();dat.controllers.Controller = (function(common){ /**
	   * @class An "abstract" class that represents a given property of an object.
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   *
	   * @member dat.controllers
	   */var Controller=function Controller(object,property){this.initialValue = object[property]; /**
	     * Those who extend this class will put their DOM elements in here.
	     * @type {DOMElement}
	     */this.domElement = document.createElement('div'); /**
	     * The object to manipulate
	     * @type {Object}
	     */this.object = object; /**
	     * The name of the property to manipulate
	     * @type {String}
	     */this.property = property; /**
	     * The function to be called on change.
	     * @type {Function}
	     * @ignore
	     */this.__onChange = undefined; /**
	     * The function to be called on finishing change.
	     * @type {Function}
	     * @ignore
	     */this.__onFinishChange = undefined;};common.extend(Controller.prototype, /** @lends dat.controllers.Controller.prototype */{ /**
	         * Specify that a function fire every time someone changes the value with
	         * this Controller.
	         *
	         * @param {Function} fnc This function will be called whenever the value
	         * is modified via this Controller.
	         * @returns {dat.controllers.Controller} this
	         */onChange:function onChange(fnc){this.__onChange = fnc;return this;}, /**
	         * Specify that a function fire every time someone "finishes" changing
	         * the value wih this Controller. Useful for values that change
	         * incrementally like numbers or strings.
	         *
	         * @param {Function} fnc This function will be called whenever
	         * someone "finishes" changing the value via this Controller.
	         * @returns {dat.controllers.Controller} this
	         */onFinishChange:function onFinishChange(fnc){this.__onFinishChange = fnc;return this;}, /**
	         * Change the value of <code>object[property]</code>
	         *
	         * @param {Object} newValue The new value of <code>object[property]</code>
	         */setValue:function setValue(newValue){this.object[this.property] = newValue;if(this.__onChange){this.__onChange.call(this,newValue);}this.updateDisplay();return this;}, /**
	         * Gets the value of <code>object[property]</code>
	         *
	         * @returns {Object} The current value of <code>object[property]</code>
	         */getValue:function getValue(){return this.object[this.property];}, /**
	         * Refreshes the visual display of a Controller in order to keep sync
	         * with the object's current value.
	         * @returns {dat.controllers.Controller} this
	         */updateDisplay:function updateDisplay(){return this;}, /**
	         * @returns {Boolean} true if the value has deviated from initialValue
	         */isModified:function isModified(){return this.initialValue !== this.getValue();}});return Controller;})(dat.utils.common);dat.dom.dom = (function(common){var EVENT_MAP={'HTMLEvents':['change'],'MouseEvents':['click','mousemove','mousedown','mouseup','mouseover'],'KeyboardEvents':['keydown']};var EVENT_MAP_INV={};common.each(EVENT_MAP,function(v,k){common.each(v,function(e){EVENT_MAP_INV[e] = k;});});var CSS_VALUE_PIXELS=/(\d+(\.\d+)?)px/;function cssValueToPixels(val){if(val === '0' || common.isUndefined(val))return 0;var match=val.match(CSS_VALUE_PIXELS);if(!common.isNull(match)){return parseFloat(match[1]);} // TODO ...ems? %?
	return 0;} /**
	   * @namespace
	   * @member dat.dom
	   */var dom={ /**
	     * 
	     * @param elem
	     * @param selectable
	     */makeSelectable:function makeSelectable(elem,selectable){if(elem === undefined || elem.style === undefined)return;elem.onselectstart = selectable?function(){return false;}:function(){};elem.style.MozUserSelect = selectable?'auto':'none';elem.style.KhtmlUserSelect = selectable?'auto':'none';elem.unselectable = selectable?'on':'off';}, /**
	     *
	     * @param elem
	     * @param horizontal
	     * @param vertical
	     */makeFullscreen:function makeFullscreen(elem,horizontal,vertical){if(common.isUndefined(horizontal))horizontal = true;if(common.isUndefined(vertical))vertical = true;elem.style.position = 'absolute';if(horizontal){elem.style.left = 0;elem.style.right = 0;}if(vertical){elem.style.top = 0;elem.style.bottom = 0;}}, /**
	     *
	     * @param elem
	     * @param eventType
	     * @param params
	     */fakeEvent:function fakeEvent(elem,eventType,params,aux){params = params || {};var className=EVENT_MAP_INV[eventType];if(!className){throw new Error('Event type ' + eventType + ' not supported.');}var evt=document.createEvent(className);switch(className){case 'MouseEvents':var clientX=params.x || params.clientX || 0;var clientY=params.y || params.clientY || 0;evt.initMouseEvent(eventType,params.bubbles || false,params.cancelable || true,window,params.clickCount || 1,0, //screen X
	0, //screen Y
	clientX, //client X
	clientY, //client Y
	false,false,false,false,0,null);break;case 'KeyboardEvents':var init=evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
	common.defaults(params,{cancelable:true,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false,keyCode:undefined,charCode:undefined});init(eventType,params.bubbles || false,params.cancelable,window,params.ctrlKey,params.altKey,params.shiftKey,params.metaKey,params.keyCode,params.charCode);break;default:evt.initEvent(eventType,params.bubbles || false,params.cancelable || true);break;}common.defaults(evt,aux);elem.dispatchEvent(evt);}, /**
	     *
	     * @param elem
	     * @param event
	     * @param func
	     * @param bool
	     */bind:function bind(elem,event,func,bool){bool = bool || false;if(elem.addEventListener)elem.addEventListener(event,func,bool);else if(elem.attachEvent)elem.attachEvent('on' + event,func);return dom;}, /**
	     *
	     * @param elem
	     * @param event
	     * @param func
	     * @param bool
	     */unbind:function unbind(elem,event,func,bool){bool = bool || false;if(elem.removeEventListener)elem.removeEventListener(event,func,bool);else if(elem.detachEvent)elem.detachEvent('on' + event,func);return dom;}, /**
	     *
	     * @param elem
	     * @param className
	     */addClass:function addClass(elem,className){if(elem.className === undefined){elem.className = className;}else if(elem.className !== className){var classes=elem.className.split(/ +/);if(classes.indexOf(className) == -1){classes.push(className);elem.className = classes.join(' ').replace(/^\s+/,'').replace(/\s+$/,'');}}return dom;}, /**
	     *
	     * @param elem
	     * @param className
	     */removeClass:function removeClass(elem,className){if(className){if(elem.className === undefined){ // elem.className = className;
	}else if(elem.className === className){elem.removeAttribute('class');}else {var classes=elem.className.split(/ +/);var index=classes.indexOf(className);if(index != -1){classes.splice(index,1);elem.className = classes.join(' ');}}}else {elem.className = undefined;}return dom;},hasClass:function hasClass(elem,className){return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;}, /**
	     *
	     * @param elem
	     */getWidth:function getWidth(elem){var style=getComputedStyle(elem);return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style['width']);}, /**
	     *
	     * @param elem
	     */getHeight:function getHeight(elem){var style=getComputedStyle(elem);return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style['height']);}, /**
	     *
	     * @param elem
	     */getOffset:function getOffset(elem){var offset={left:0,top:0};if(elem.offsetParent){do {offset.left += elem.offsetLeft;offset.top += elem.offsetTop;}while(elem = elem.offsetParent);}return offset;}, // http://stackoverflow.com/posts/2684561/revisions
	/**
	     * 
	     * @param elem
	     */isActive:function isActive(elem){return elem === document.activeElement && (elem.type || elem.href);}};return dom;})(dat.utils.common);dat.controllers.OptionController = (function(Controller,dom,common){ /**
	   * @class Provides a select input to alter the property of an object, using a
	   * list of accepted values.
	   *
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   * @param {Object|string[]} options A map of labels to acceptable values, or
	   * a list of acceptable string values.
	   *
	   * @member dat.controllers
	   */var OptionController=function OptionController(object,property,options){OptionController.superclass.call(this,object,property);var _this=this; /**
	     * The drop down menu
	     * @ignore
	     */this.__select = document.createElement('select');if(common.isArray(options)){var map={};common.each(options,function(element){map[element] = element;});options = map;}common.each(options,function(value,key){var opt=document.createElement('option');opt.innerHTML = key;opt.setAttribute('value',value);_this.__select.appendChild(opt);}); // Acknowledge original value
	this.updateDisplay();dom.bind(this.__select,'change',function(){var desiredValue=this.options[this.selectedIndex].value;_this.setValue(desiredValue);});this.domElement.appendChild(this.__select);};OptionController.superclass = Controller;common.extend(OptionController.prototype,Controller.prototype,{setValue:function setValue(v){var toReturn=OptionController.superclass.prototype.setValue.call(this,v);if(this.__onFinishChange){this.__onFinishChange.call(this,this.getValue());}return toReturn;},updateDisplay:function updateDisplay(){this.__select.value = this.getValue();return OptionController.superclass.prototype.updateDisplay.call(this);}});return OptionController;})(dat.controllers.Controller,dat.dom.dom,dat.utils.common);dat.controllers.NumberController = (function(Controller,common){ /**
	   * @class Represents a given property of an object that is a number.
	   *
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   * @param {Object} [params] Optional parameters
	   * @param {Number} [params.min] Minimum allowed value
	   * @param {Number} [params.max] Maximum allowed value
	   * @param {Number} [params.step] Increment by which to change value
	   *
	   * @member dat.controllers
	   */var NumberController=function NumberController(object,property,params){NumberController.superclass.call(this,object,property);params = params || {};this.__min = params.min;this.__max = params.max;this.__step = params.step;if(common.isUndefined(this.__step)){if(this.initialValue == 0){this.__impliedStep = 1; // What are we, psychics?
	}else { // Hey Doug, check this out.
	this.__impliedStep = Math.pow(10,Math.floor(Math.log(Math.abs(this.initialValue)) / Math.LN10)) / 10;}}else {this.__impliedStep = this.__step;}this.__precision = numDecimals(this.__impliedStep);};NumberController.superclass = Controller;common.extend(NumberController.prototype,Controller.prototype, /** @lends dat.controllers.NumberController.prototype */{setValue:function setValue(v){if(this.__min !== undefined && v < this.__min){v = this.__min;}else if(this.__max !== undefined && v > this.__max){v = this.__max;}if(this.__step !== undefined && v % this.__step != 0){v = Math.round(v / this.__step) * this.__step;}return NumberController.superclass.prototype.setValue.call(this,v);}, /**
	         * Specify a minimum value for <code>object[property]</code>.
	         *
	         * @param {Number} minValue The minimum value for
	         * <code>object[property]</code>
	         * @returns {dat.controllers.NumberController} this
	         */min:function min(v){this.__min = v;return this;}, /**
	         * Specify a maximum value for <code>object[property]</code>.
	         *
	         * @param {Number} maxValue The maximum value for
	         * <code>object[property]</code>
	         * @returns {dat.controllers.NumberController} this
	         */max:function max(v){this.__max = v;return this;}, /**
	         * Specify a step value that dat.controllers.NumberController
	         * increments by.
	         *
	         * @param {Number} stepValue The step value for
	         * dat.controllers.NumberController
	         * @default if minimum and maximum specified increment is 1% of the
	         * difference otherwise stepValue is 1
	         * @returns {dat.controllers.NumberController} this
	         */step:function step(v){this.__step = v;this.__impliedStep = v;this.__precision = numDecimals(v);return this;}});function numDecimals(x){x = x.toString();if(x.indexOf('.') > -1){return x.length - x.indexOf('.') - 1;}else {return 0;}}return NumberController;})(dat.controllers.Controller,dat.utils.common);dat.controllers.NumberControllerBox = (function(NumberController,dom,common){ /**
	   * @class Represents a given property of an object that is a number and
	   * provides an input element with which to manipulate it.
	   *
	   * @extends dat.controllers.Controller
	   * @extends dat.controllers.NumberController
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   * @param {Object} [params] Optional parameters
	   * @param {Number} [params.min] Minimum allowed value
	   * @param {Number} [params.max] Maximum allowed value
	   * @param {Number} [params.step] Increment by which to change value
	   *
	   * @member dat.controllers
	   */var NumberControllerBox=function NumberControllerBox(object,property,params){this.__truncationSuspended = false;NumberControllerBox.superclass.call(this,object,property,params);var _this=this; /**
	     * {Number} Previous mouse y position
	     * @ignore
	     */var prev_y;this.__input = document.createElement('input');this.__input.setAttribute('type','text'); // Makes it so manually specified values are not truncated.
	dom.bind(this.__input,'change',onChange);dom.bind(this.__input,'blur',onBlur);dom.bind(this.__input,'mousedown',onMouseDown);dom.bind(this.__input,'keydown',function(e){ // When pressing entire, you can be as precise as you want.
	if(e.keyCode === 13){_this.__truncationSuspended = true;this.blur();_this.__truncationSuspended = false;}});function onChange(){var attempted=parseFloat(_this.__input.value);if(!common.isNaN(attempted))_this.setValue(attempted);}function onBlur(){onChange();if(_this.__onFinishChange){_this.__onFinishChange.call(_this,_this.getValue());}}function onMouseDown(e){dom.bind(window,'mousemove',onMouseDrag);dom.bind(window,'mouseup',onMouseUp);prev_y = e.clientY;}function onMouseDrag(e){var diff=prev_y - e.clientY;_this.setValue(_this.getValue() + diff * _this.__impliedStep);prev_y = e.clientY;}function onMouseUp(){dom.unbind(window,'mousemove',onMouseDrag);dom.unbind(window,'mouseup',onMouseUp);}this.updateDisplay();this.domElement.appendChild(this.__input);};NumberControllerBox.superclass = NumberController;common.extend(NumberControllerBox.prototype,NumberController.prototype,{updateDisplay:function updateDisplay(){this.__input.value = this.__truncationSuspended?this.getValue():roundToDecimal(this.getValue(),this.__precision);return NumberControllerBox.superclass.prototype.updateDisplay.call(this);}});function roundToDecimal(value,decimals){var tenTo=Math.pow(10,decimals);return Math.round(value * tenTo) / tenTo;}return NumberControllerBox;})(dat.controllers.NumberController,dat.dom.dom,dat.utils.common);dat.controllers.NumberControllerSlider = (function(NumberController,dom,css,common,styleSheet){ /**
	   * @class Represents a given property of an object that is a number, contains
	   * a minimum and maximum, and provides a slider element with which to
	   * manipulate it. It should be noted that the slider element is made up of
	   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
	   * <code>&lt;slider&gt;</code> element.
	   *
	   * @extends dat.controllers.Controller
	   * @extends dat.controllers.NumberController
	   * 
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   * @param {Number} minValue Minimum allowed value
	   * @param {Number} maxValue Maximum allowed value
	   * @param {Number} stepValue Increment by which to change value
	   *
	   * @member dat.controllers
	   */var NumberControllerSlider=function NumberControllerSlider(object,property,min,max,step){NumberControllerSlider.superclass.call(this,object,property,{min:min,max:max,step:step});var _this=this;this.__background = document.createElement('div');this.__foreground = document.createElement('div');dom.bind(this.__background,'mousedown',onMouseDown);dom.addClass(this.__background,'slider');dom.addClass(this.__foreground,'slider-fg');function onMouseDown(e){dom.bind(window,'mousemove',onMouseDrag);dom.bind(window,'mouseup',onMouseUp);onMouseDrag(e);}function onMouseDrag(e){e.preventDefault();var offset=dom.getOffset(_this.__background);var width=dom.getWidth(_this.__background);_this.setValue(map(e.clientX,offset.left,offset.left + width,_this.__min,_this.__max));return false;}function onMouseUp(){dom.unbind(window,'mousemove',onMouseDrag);dom.unbind(window,'mouseup',onMouseUp);if(_this.__onFinishChange){_this.__onFinishChange.call(_this,_this.getValue());}}this.updateDisplay();this.__background.appendChild(this.__foreground);this.domElement.appendChild(this.__background);};NumberControllerSlider.superclass = NumberController; /**
	   * Injects default stylesheet for slider elements.
	   */NumberControllerSlider.useDefaultStyles = function(){css.inject(styleSheet);};common.extend(NumberControllerSlider.prototype,NumberController.prototype,{updateDisplay:function updateDisplay(){var pct=(this.getValue() - this.__min) / (this.__max - this.__min);this.__foreground.style.width = pct * 100 + '%';return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);}});function map(v,i1,i2,o1,o2){return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));}return NumberControllerSlider;})(dat.controllers.NumberController,dat.dom.dom,dat.utils.css,dat.utils.common,"/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n.slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");dat.controllers.FunctionController = (function(Controller,dom,common){ /**
	   * @class Provides a GUI interface to fire a specified method, a property of an object.
	   *
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   *
	   * @member dat.controllers
	   */var FunctionController=function FunctionController(object,property,text){FunctionController.superclass.call(this,object,property);var _this=this;this.__button = document.createElement('div');this.__button.innerHTML = text === undefined?'Fire':text;dom.bind(this.__button,'click',function(e){e.preventDefault();_this.fire();return false;});dom.addClass(this.__button,'button');this.domElement.appendChild(this.__button);};FunctionController.superclass = Controller;common.extend(FunctionController.prototype,Controller.prototype,{fire:function fire(){if(this.__onChange){this.__onChange.call(this);}this.getValue().call(this.object);if(this.__onFinishChange){this.__onFinishChange.call(this,this.getValue());}}});return FunctionController;})(dat.controllers.Controller,dat.dom.dom,dat.utils.common);dat.controllers.BooleanController = (function(Controller,dom,common){ /**
	   * @class Provides a checkbox input to alter the boolean property of an object.
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   *
	   * @member dat.controllers
	   */var BooleanController=function BooleanController(object,property){BooleanController.superclass.call(this,object,property);var _this=this;this.__prev = this.getValue();this.__checkbox = document.createElement('input');this.__checkbox.setAttribute('type','checkbox');dom.bind(this.__checkbox,'change',onChange,false);this.domElement.appendChild(this.__checkbox); // Match original value
	this.updateDisplay();function onChange(){_this.setValue(!_this.__prev);}};BooleanController.superclass = Controller;common.extend(BooleanController.prototype,Controller.prototype,{setValue:function setValue(v){var toReturn=BooleanController.superclass.prototype.setValue.call(this,v);if(this.__onFinishChange){this.__onFinishChange.call(this,this.getValue());}this.__prev = this.getValue();return toReturn;},updateDisplay:function updateDisplay(){if(this.getValue() === true){this.__checkbox.setAttribute('checked','checked');this.__checkbox.checked = true;}else {this.__checkbox.checked = false;}return BooleanController.superclass.prototype.updateDisplay.call(this);}});return BooleanController;})(dat.controllers.Controller,dat.dom.dom,dat.utils.common);dat.color.toString = (function(common){return function(color){if(color.a == 1 || common.isUndefined(color.a)){var s=color.hex.toString(16);while(s.length < 6) {s = '0' + s;}return '#' + s;}else {return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';}};})(dat.utils.common);dat.color.interpret = (function(toString,common){var result,toReturn;var interpret=function interpret(){toReturn = false;var original=arguments.length > 1?common.toArray(arguments):arguments[0];common.each(INTERPRETATIONS,function(family){if(family.litmus(original)){common.each(family.conversions,function(conversion,conversionName){result = conversion.read(original);if(toReturn === false && result !== false){toReturn = result;result.conversionName = conversionName;result.conversion = conversion;return common.BREAK;}});return common.BREAK;}});return toReturn;};var INTERPRETATIONS=[ // Strings
	{litmus:common.isString,conversions:{THREE_CHAR_HEX:{read:function read(original){var test=original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);if(test === null)return false;return {space:'HEX',hex:parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString())};},write:toString},SIX_CHAR_HEX:{read:function read(original){var test=original.match(/^#([A-F0-9]{6})$/i);if(test === null)return false;return {space:'HEX',hex:parseInt('0x' + test[1].toString())};},write:toString},CSS_RGB:{read:function read(original){var test=original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);if(test === null)return false;return {space:'RGB',r:parseFloat(test[1]),g:parseFloat(test[2]),b:parseFloat(test[3])};},write:toString},CSS_RGBA:{read:function read(original){var test=original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);if(test === null)return false;return {space:'RGB',r:parseFloat(test[1]),g:parseFloat(test[2]),b:parseFloat(test[3]),a:parseFloat(test[4])};},write:toString}}}, // Numbers
	{litmus:common.isNumber,conversions:{HEX:{read:function read(original){return {space:'HEX',hex:original,conversionName:'HEX'};},write:function write(color){return color.hex;}}}}, // Arrays
	{litmus:common.isArray,conversions:{RGB_ARRAY:{read:function read(original){if(original.length != 3)return false;return {space:'RGB',r:original[0],g:original[1],b:original[2]};},write:function write(color){return [color.r,color.g,color.b];}},RGBA_ARRAY:{read:function read(original){if(original.length != 4)return false;return {space:'RGB',r:original[0],g:original[1],b:original[2],a:original[3]};},write:function write(color){return [color.r,color.g,color.b,color.a];}}}}, // Objects
	{litmus:common.isObject,conversions:{RGBA_OBJ:{read:function read(original){if(common.isNumber(original.r) && common.isNumber(original.g) && common.isNumber(original.b) && common.isNumber(original.a)){return {space:'RGB',r:original.r,g:original.g,b:original.b,a:original.a};}return false;},write:function write(color){return {r:color.r,g:color.g,b:color.b,a:color.a};}},RGB_OBJ:{read:function read(original){if(common.isNumber(original.r) && common.isNumber(original.g) && common.isNumber(original.b)){return {space:'RGB',r:original.r,g:original.g,b:original.b};}return false;},write:function write(color){return {r:color.r,g:color.g,b:color.b};}},HSVA_OBJ:{read:function read(original){if(common.isNumber(original.h) && common.isNumber(original.s) && common.isNumber(original.v) && common.isNumber(original.a)){return {space:'HSV',h:original.h,s:original.s,v:original.v,a:original.a};}return false;},write:function write(color){return {h:color.h,s:color.s,v:color.v,a:color.a};}},HSV_OBJ:{read:function read(original){if(common.isNumber(original.h) && common.isNumber(original.s) && common.isNumber(original.v)){return {space:'HSV',h:original.h,s:original.s,v:original.v};}return false;},write:function write(color){return {h:color.h,s:color.s,v:color.v};}}}}];return interpret;})(dat.color.toString,dat.utils.common);dat.GUI = dat.gui.GUI = (function(css,saveDialogueContents,styleSheet,controllerFactory,Controller,BooleanController,FunctionController,NumberControllerBox,NumberControllerSlider,OptionController,ColorController,requestAnimationFrame,CenteredDiv,dom,common){css.inject(styleSheet); /** Outer-most className for GUI's */var CSS_NAMESPACE='dg';var HIDE_KEY_CODE=72; /** The only value shared between the JS and SCSS. Use caution. */var CLOSE_BUTTON_HEIGHT=20;var DEFAULT_DEFAULT_PRESET_NAME='Default';var SUPPORTS_LOCAL_STORAGE=(function(){try{return 'localStorage' in window && window['localStorage'] !== null;}catch(e) {return false;}})();var SAVE_DIALOGUE; /** Have we yet to create an autoPlace GUI? */var auto_place_virgin=true; /** Fixed position div that auto place GUI's go inside */var auto_place_container; /** Are we hiding the GUI's ? */var hide=false; /** GUI's which should be hidden */var hideable_guis=[]; /**
	   * A lightweight controller library for JavaScript. It allows you to easily
	   * manipulate variables and fire functions on the fly.
	   * @class
	   *
	   * @member dat.gui
	   *
	   * @param {Object} [params]
	   * @param {String} [params.name] The name of this GUI.
	   * @param {Object} [params.load] JSON object representing the saved state of
	   * this GUI.
	   * @param {Boolean} [params.auto=true]
	   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
	   * @param {Boolean} [params.closed] If true, starts closed
	   */var GUI=function GUI(params){var _this=this; /**
	     * Outermost DOM Element
	     * @type DOMElement
	     */this.domElement = document.createElement('div');this.__ul = document.createElement('ul');this.domElement.appendChild(this.__ul);dom.addClass(this.domElement,CSS_NAMESPACE); /**
	     * Nested GUI's by name
	     * @ignore
	     */this.__folders = {};this.__controllers = []; /**
	     * List of objects I'm remembering for save, only used in top level GUI
	     * @ignore
	     */this.__rememberedObjects = []; /**
	     * Maps the index of remembered objects to a map of controllers, only used
	     * in top level GUI.
	     *
	     * @private
	     * @ignore
	     *
	     * @example
	     * [
	     *  {
	     *    propertyName: Controller,
	     *    anotherPropertyName: Controller
	     *  },
	     *  {
	     *    propertyName: Controller
	     *  }
	     * ]
	     */this.__rememberedObjectIndecesToControllers = [];this.__listening = [];params = params || {}; // Default parameters
	params = common.defaults(params,{autoPlace:true,width:GUI.DEFAULT_WIDTH});params = common.defaults(params,{resizable:params.autoPlace,hideable:params.autoPlace});if(!common.isUndefined(params.load)){ // Explicit preset
	if(params.preset)params.load.preset = params.preset;}else {params.load = {preset:DEFAULT_DEFAULT_PRESET_NAME};}if(common.isUndefined(params.parent) && params.hideable){hideable_guis.push(this);} // Only root level GUI's are resizable.
	params.resizable = common.isUndefined(params.parent) && params.resizable;if(params.autoPlace && common.isUndefined(params.scrollable)){params.scrollable = true;} //    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;
	// Not part of params because I don't want people passing this in via
	// constructor. Should be a 'remembered' value.
	var use_local_storage=SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this,'isLocal')) === 'true';var saveToLocalStorage;_Object$defineProperties(this, /** @lends dat.gui.GUI.prototype */{ /**
	           * The parent <code>GUI</code>
	           * @type dat.gui.GUI
	           */parent:{get:function get(){return params.parent;}},scrollable:{get:function get(){return params.scrollable;}}, /**
	           * Handles <code>GUI</code>'s element placement for you
	           * @type Boolean
	           */autoPlace:{get:function get(){return params.autoPlace;}}, /**
	           * The identifier for a set of saved values
	           * @type String
	           */preset:{get:function get(){if(_this.parent){return _this.getRoot().preset;}else {return params.load.preset;}},set:function set(v){if(_this.parent){_this.getRoot().preset = v;}else {params.load.preset = v;}setPresetSelectIndex(this);_this.revert();}}, /**
	           * The width of <code>GUI</code> element
	           * @type Number
	           */width:{get:function get(){return params.width;},set:function set(v){params.width = v;setWidth(_this,v);}}, /**
	           * The name of <code>GUI</code>. Used for folders. i.e
	           * a folder's name
	           * @type String
	           */name:{get:function get(){return params.name;},set:function set(v){ // TODO Check for collisions among sibling folders
	params.name = v;if(title_row_name){title_row_name.innerHTML = params.name;}}}, /**
	           * Whether the <code>GUI</code> is collapsed or not
	           * @type Boolean
	           */closed:{get:function get(){return params.closed;},set:function set(v){params.closed = v;if(params.closed){dom.addClass(_this.__ul,GUI.CLASS_CLOSED);}else {dom.removeClass(_this.__ul,GUI.CLASS_CLOSED);} // For browsers that aren't going to respect the CSS transition,
	// Lets just check our height against the window height right off
	// the bat.
	this.onResize();if(_this.__closeButton){_this.__closeButton.innerHTML = v?GUI.TEXT_OPEN:GUI.TEXT_CLOSED;}}}, /**
	           * Contains all presets
	           * @type Object
	           */load:{get:function get(){return params.load;}}, /**
	           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
	           * <code>remember</code>ing
	           * @type Boolean
	           */useLocalStorage:{get:function get(){return use_local_storage;},set:function set(bool){if(SUPPORTS_LOCAL_STORAGE){use_local_storage = bool;if(bool){dom.bind(window,'unload',saveToLocalStorage);}else {dom.unbind(window,'unload',saveToLocalStorage);}localStorage.setItem(getLocalStorageHash(_this,'isLocal'),bool);}}}}); // Are we a root level GUI?
	if(common.isUndefined(params.parent)){params.closed = false;dom.addClass(this.domElement,GUI.CLASS_MAIN);dom.makeSelectable(this.domElement,false); // Are we supposed to be loading locally?
	if(SUPPORTS_LOCAL_STORAGE){if(use_local_storage){_this.useLocalStorage = true;var saved_gui=localStorage.getItem(getLocalStorageHash(this,'gui'));if(saved_gui){params.load = JSON.parse(saved_gui);}}}this.__closeButton = document.createElement('div');this.__closeButton.innerHTML = GUI.TEXT_CLOSED;dom.addClass(this.__closeButton,GUI.CLASS_CLOSE_BUTTON);this.domElement.appendChild(this.__closeButton);dom.bind(this.__closeButton,'click',function(){_this.closed = !_this.closed;}); // Oh, you're a nested GUI!
	}else {if(params.closed === undefined){params.closed = true;}var title_row_name=document.createTextNode(params.name);dom.addClass(title_row_name,'controller-name');var title_row=addRow(_this,title_row_name);var on_click_title=function on_click_title(e){e.preventDefault();_this.closed = !_this.closed;return false;};dom.addClass(this.__ul,GUI.CLASS_CLOSED);dom.addClass(title_row,'title');dom.bind(title_row,'click',on_click_title);if(!params.closed){this.closed = false;}}if(params.autoPlace){if(common.isUndefined(params.parent)){if(auto_place_virgin){auto_place_container = document.createElement('div');dom.addClass(auto_place_container,CSS_NAMESPACE);dom.addClass(auto_place_container,GUI.CLASS_AUTO_PLACE_CONTAINER);document.body.appendChild(auto_place_container);auto_place_virgin = false;} // Put it in the dom for you.
	auto_place_container.appendChild(this.domElement); // Apply the auto styles
	dom.addClass(this.domElement,GUI.CLASS_AUTO_PLACE);} // Make it not elastic.
	if(!this.parent)setWidth(_this,params.width);}dom.bind(window,'resize',function(){_this.onResize();});dom.bind(this.__ul,'webkitTransitionEnd',function(){_this.onResize();});dom.bind(this.__ul,'transitionend',function(){_this.onResize();});dom.bind(this.__ul,'oTransitionEnd',function(){_this.onResize();});this.onResize();if(params.resizable){addResizeHandle(this);}saveToLocalStorage = function(){if(SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this,'isLocal')) === 'true'){localStorage.setItem(getLocalStorageHash(_this,'gui'),JSON.stringify(_this.getSaveObject()));}}; // expose this method publicly
	this.saveToLocalStorageIfPossible = saveToLocalStorage;var root=_this.getRoot();function resetWidth(){var root=_this.getRoot();root.width += 1;common.defer(function(){root.width -= 1;});}if(!params.parent){resetWidth();}};GUI.toggleHide = function(){hide = !hide;common.each(hideable_guis,function(gui){gui.domElement.style.zIndex = hide?-999:999;gui.domElement.style.opacity = hide?0:1;});};GUI.CLASS_AUTO_PLACE = 'a';GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';GUI.CLASS_MAIN = 'main';GUI.CLASS_CONTROLLER_ROW = 'cr';GUI.CLASS_TOO_TALL = 'taller-than-window';GUI.CLASS_CLOSED = 'closed';GUI.CLASS_CLOSE_BUTTON = 'close-button';GUI.CLASS_DRAG = 'drag';GUI.DEFAULT_WIDTH = 245;GUI.TEXT_CLOSED = 'Close Controls';GUI.TEXT_OPEN = 'Open Controls';dom.bind(window,'keydown',function(e){if(document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)){GUI.toggleHide();}},false);common.extend(GUI.prototype, /** @lends dat.gui.GUI */{ /**
	         * @param object
	         * @param property
	         * @returns {dat.controllers.Controller} The new controller that was added.
	         * @instance
	         */add:function add(object,property){return _add(this,object,property,{factoryArgs:Array.prototype.slice.call(arguments,2)});}, /**
	         * @param object
	         * @param property
	         * @returns {dat.controllers.ColorController} The new controller that was added.
	         * @instance
	         */addColor:function addColor(object,property){return _add(this,object,property,{color:true});}, /**
	         * @param controller
	         * @instance
	         */remove:function remove(controller){ // TODO listening?
	this.__ul.removeChild(controller.__li);this.__controllers.splice(this.__controllers.indexOf(controller),1);var _this=this;common.defer(function(){_this.onResize();});},destroy:function destroy(){if(this.autoPlace){auto_place_container.removeChild(this.domElement);}}, /**
	         * @param name
	         * @returns {dat.gui.GUI} The new folder.
	         * @throws {Error} if this GUI already has a folder by the specified
	         * name
	         * @instance
	         */addFolder:function addFolder(name){ // We have to prevent collisions on names in order to have a key
	// by which to remember saved values
	if(this.__folders[name] !== undefined){throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');}var new_gui_params={name:name,parent:this}; // We need to pass down the autoPlace trait so that we can
	// attach event listeners to open/close folder actions to
	// ensure that a scrollbar appears if the window is too short.
	new_gui_params.autoPlace = this.autoPlace; // Do we have saved appearance data for this folder?
	if(this.load &&  // Anything loaded?
	this.load.folders &&  // Was my parent a dead-end?
	this.load.folders[name]){ // Did daddy remember me?
	// Start me closed if I was closed
	new_gui_params.closed = this.load.folders[name].closed; // Pass down the loaded data
	new_gui_params.load = this.load.folders[name];}var gui=new GUI(new_gui_params);this.__folders[name] = gui;var li=addRow(this,gui.domElement);dom.addClass(li,'folder');return gui;},open:function open(){this.closed = false;},close:function close(){this.closed = true;},onResize:function onResize(){var root=this.getRoot();if(root.scrollable){var top=dom.getOffset(root.__ul).top;var h=0;common.each(root.__ul.childNodes,function(node){if(!(root.autoPlace && node === root.__save_row))h += dom.getHeight(node);});if(window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h){dom.addClass(root.domElement,GUI.CLASS_TOO_TALL);root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';}else {dom.removeClass(root.domElement,GUI.CLASS_TOO_TALL);root.__ul.style.height = 'auto';}}if(root.__resize_handle){common.defer(function(){root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';});}if(root.__closeButton){root.__closeButton.style.width = root.width + 'px';}}, /**
	         * Mark objects for saving. The order of these objects cannot change as
	         * the GUI grows. When remembering new objects, append them to the end
	         * of the list.
	         *
	         * @param {Object...} objects
	         * @throws {Error} if not called on a top level GUI.
	         * @instance
	         */remember:function remember(){if(common.isUndefined(SAVE_DIALOGUE)){SAVE_DIALOGUE = new CenteredDiv();SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;}if(this.parent){throw new Error("You can only call remember on a top level GUI.");}var _this=this;common.each(Array.prototype.slice.call(arguments),function(object){if(_this.__rememberedObjects.length == 0){addSaveMenu(_this);}if(_this.__rememberedObjects.indexOf(object) == -1){_this.__rememberedObjects.push(object);}});if(this.autoPlace){ // Set save row width
	setWidth(this,this.width);}}, /**
	         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
	         * @instance
	         */getRoot:function getRoot(){var gui=this;while(gui.parent) {gui = gui.parent;}return gui;}, /**
	         * @returns {Object} a JSON object representing the current state of
	         * this GUI as well as its remembered properties.
	         * @instance
	         */getSaveObject:function getSaveObject(){var toReturn=this.load;toReturn.closed = this.closed; // Am I remembering any values?
	if(this.__rememberedObjects.length > 0){toReturn.preset = this.preset;if(!toReturn.remembered){toReturn.remembered = {};}toReturn.remembered[this.preset] = getCurrentPreset(this);}toReturn.folders = {};common.each(this.__folders,function(element,key){toReturn.folders[key] = element.getSaveObject();});return toReturn;},save:function save(){if(!this.load.remembered){this.load.remembered = {};}this.load.remembered[this.preset] = getCurrentPreset(this);markPresetModified(this,false);this.saveToLocalStorageIfPossible();},saveAs:function saveAs(presetName){if(!this.load.remembered){ // Retain default values upon first save
	this.load.remembered = {};this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this,true);}this.load.remembered[presetName] = getCurrentPreset(this);this.preset = presetName;addPresetOption(this,presetName,true);this.saveToLocalStorageIfPossible();},revert:function revert(gui){common.each(this.__controllers,function(controller){ // Make revert work on Default.
	if(!this.getRoot().load.remembered){controller.setValue(controller.initialValue);}else {recallSavedValue(gui || this.getRoot(),controller);}},this);common.each(this.__folders,function(folder){folder.revert(folder);});if(!gui){markPresetModified(this.getRoot(),false);}},listen:function listen(controller){var init=this.__listening.length == 0;this.__listening.push(controller);if(init)updateDisplays(this.__listening);}});function _add(gui,object,property,params){if(object[property] === undefined){throw new Error("Object " + object + " has no property \"" + property + "\"");}var controller;if(params.color){controller = new ColorController(object,property);}else {var factoryArgs=[object,property].concat(params.factoryArgs);controller = controllerFactory.apply(gui,factoryArgs);}if(params.before instanceof Controller){params.before = params.before.__li;}recallSavedValue(gui,controller);dom.addClass(controller.domElement,'c');var name=document.createElement('span');dom.addClass(name,'property-name');name.innerHTML = controller.property;var container=document.createElement('div');container.appendChild(name);container.appendChild(controller.domElement);var li=addRow(gui,container,params.before);dom.addClass(li,GUI.CLASS_CONTROLLER_ROW);dom.addClass(li,typeof controller.getValue());augmentController(gui,li,controller);gui.__controllers.push(controller);return controller;} /**
	   * Add a row to the end of the GUI or before another row.
	   *
	   * @param gui
	   * @param [dom] If specified, inserts the dom content in the new row
	   * @param [liBefore] If specified, places the new row before another row
	   */function addRow(gui,dom,liBefore){var li=document.createElement('li');if(dom)li.appendChild(dom);if(liBefore){gui.__ul.insertBefore(li,params.before);}else {gui.__ul.appendChild(li);}gui.onResize();return li;}function augmentController(gui,li,controller){controller.__li = li;controller.__gui = gui;common.extend(controller,{options:function options(_options){if(arguments.length > 1){controller.remove();return _add(gui,controller.object,controller.property,{before:controller.__li.nextElementSibling,factoryArgs:[common.toArray(arguments)]});}if(common.isArray(_options) || common.isObject(_options)){controller.remove();return _add(gui,controller.object,controller.property,{before:controller.__li.nextElementSibling,factoryArgs:[_options]});}},name:function name(v){controller.__li.firstElementChild.firstElementChild.innerHTML = v;return controller;},listen:function listen(){controller.__gui.listen(controller);return controller;},remove:function remove(){controller.__gui.remove(controller);return controller;}}); // All sliders should be accompanied by a box.
	if(controller instanceof NumberControllerSlider){var box=new NumberControllerBox(controller.object,controller.property,{min:controller.__min,max:controller.__max,step:controller.__step});common.each(['updateDisplay','onChange','onFinishChange'],function(method){var pc=controller[method];var pb=box[method];controller[method] = box[method] = function(){var args=Array.prototype.slice.call(arguments);pc.apply(controller,args);return pb.apply(box,args);};});dom.addClass(li,'has-slider');controller.domElement.insertBefore(box.domElement,controller.domElement.firstElementChild);}else if(controller instanceof NumberControllerBox){var r=function r(returned){ // Have we defined both boundaries?
	if(common.isNumber(controller.__min) && common.isNumber(controller.__max)){ // Well, then lets just replace this with a slider.
	controller.remove();return _add(gui,controller.object,controller.property,{before:controller.__li.nextElementSibling,factoryArgs:[controller.__min,controller.__max,controller.__step]});}return returned;};controller.min = common.compose(r,controller.min);controller.max = common.compose(r,controller.max);}else if(controller instanceof BooleanController){dom.bind(li,'click',function(){dom.fakeEvent(controller.__checkbox,'click');});dom.bind(controller.__checkbox,'click',function(e){e.stopPropagation(); // Prevents double-toggle
	});}else if(controller instanceof FunctionController){dom.bind(li,'click',function(){dom.fakeEvent(controller.__button,'click');});dom.bind(li,'mouseover',function(){dom.addClass(controller.__button,'hover');});dom.bind(li,'mouseout',function(){dom.removeClass(controller.__button,'hover');});}else if(controller instanceof ColorController){dom.addClass(li,'color');controller.updateDisplay = common.compose(function(r){li.style.borderLeftColor = controller.__color.toString();return r;},controller.updateDisplay);controller.updateDisplay();}controller.setValue = common.compose(function(r){if(gui.getRoot().__preset_select && controller.isModified()){markPresetModified(gui.getRoot(),true);}return r;},controller.setValue);}function recallSavedValue(gui,controller){ // Find the topmost GUI, that's where remembered objects live.
	var root=gui.getRoot(); // Does the object we're controlling match anything we've been told to
	// remember?
	var matched_index=root.__rememberedObjects.indexOf(controller.object); // Why yes, it does!
	if(matched_index != -1){ // Let me fetch a map of controllers for thcommon.isObject.
	var controller_map=root.__rememberedObjectIndecesToControllers[matched_index]; // Ohp, I believe this is the first controller we've created for this
	// object. Lets make the map fresh.
	if(controller_map === undefined){controller_map = {};root.__rememberedObjectIndecesToControllers[matched_index] = controller_map;} // Keep track of this controller
	controller_map[controller.property] = controller; // Okay, now have we saved any values for this controller?
	if(root.load && root.load.remembered){var preset_map=root.load.remembered; // Which preset are we trying to load?
	var preset;if(preset_map[gui.preset]){preset = preset_map[gui.preset];}else if(preset_map[DEFAULT_DEFAULT_PRESET_NAME]){ // Uhh, you can have the default instead?
	preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];}else { // Nada.
	return;} // Did the loaded object remember thcommon.isObject?
	if(preset[matched_index] &&  // Did we remember this particular property?
	preset[matched_index][controller.property] !== undefined){ // We did remember something for this guy ...
	var value=preset[matched_index][controller.property]; // And that's what it is.
	controller.initialValue = value;controller.setValue(value);}}}}function getLocalStorageHash(gui,key){ // TODO how does this deal with multiple GUI's?
	return document.location.href + '.' + key;}function addSaveMenu(gui){var div=gui.__save_row = document.createElement('li');dom.addClass(gui.domElement,'has-save');gui.__ul.insertBefore(div,gui.__ul.firstChild);dom.addClass(div,'save-row');var gears=document.createElement('span');gears.innerHTML = '&nbsp;';dom.addClass(gears,'button gears'); // TODO replace with FunctionController
	var button=document.createElement('span');button.innerHTML = 'Save';dom.addClass(button,'button');dom.addClass(button,'save');var button2=document.createElement('span');button2.innerHTML = 'New';dom.addClass(button2,'button');dom.addClass(button2,'save-as');var button3=document.createElement('span');button3.innerHTML = 'Revert';dom.addClass(button3,'button');dom.addClass(button3,'revert');var select=gui.__preset_select = document.createElement('select');if(gui.load && gui.load.remembered){common.each(gui.load.remembered,function(value,key){addPresetOption(gui,key,key == gui.preset);});}else {addPresetOption(gui,DEFAULT_DEFAULT_PRESET_NAME,false);}dom.bind(select,'change',function(){for(var index=0;index < gui.__preset_select.length;index++) {gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;}gui.preset = this.value;});div.appendChild(select);div.appendChild(gears);div.appendChild(button);div.appendChild(button2);div.appendChild(button3);if(SUPPORTS_LOCAL_STORAGE){var saveLocally;var explain;var localStorageCheckBox;(function(){var showHideExplain=function showHideExplain(){explain.style.display = gui.useLocalStorage?'block':'none';};saveLocally = document.getElementById('dg-save-locally');explain = document.getElementById('dg-local-explain');saveLocally.style.display = 'block';localStorageCheckBox = document.getElementById('dg-local-storage');if(localStorage.getItem(getLocalStorageHash(gui,'isLocal')) === 'true'){localStorageCheckBox.setAttribute('checked','checked');}showHideExplain(); // TODO: Use a boolean controller, fool!
	dom.bind(localStorageCheckBox,'change',function(){gui.useLocalStorage = !gui.useLocalStorage;showHideExplain();});})();}var newConstructorTextArea=document.getElementById('dg-new-constructor');dom.bind(newConstructorTextArea,'keydown',function(e){if(e.metaKey && (e.which === 67 || e.keyCode == 67)){SAVE_DIALOGUE.hide();}});dom.bind(gears,'click',function(){newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(),undefined,2);SAVE_DIALOGUE.show();newConstructorTextArea.focus();newConstructorTextArea.select();});dom.bind(button,'click',function(){gui.save();});dom.bind(button2,'click',function(){var presetName=prompt('Enter a new preset name.');if(presetName)gui.saveAs(presetName);});dom.bind(button3,'click',function(){gui.revert();}); //    div.appendChild(button2);
	}function addResizeHandle(gui){gui.__resize_handle = document.createElement('div');common.extend(gui.__resize_handle.style,{width:'6px',marginLeft:'-3px',height:'200px',cursor:'ew-resize',position:'absolute' //      border: '1px solid blue'
	});var pmouseX;dom.bind(gui.__resize_handle,'mousedown',dragStart);dom.bind(gui.__closeButton,'mousedown',dragStart);gui.domElement.insertBefore(gui.__resize_handle,gui.domElement.firstElementChild);function dragStart(e){e.preventDefault();pmouseX = e.clientX;dom.addClass(gui.__closeButton,GUI.CLASS_DRAG);dom.bind(window,'mousemove',drag);dom.bind(window,'mouseup',dragStop);return false;}function drag(e){e.preventDefault();gui.width += pmouseX - e.clientX;gui.onResize();pmouseX = e.clientX;return false;}function dragStop(){dom.removeClass(gui.__closeButton,GUI.CLASS_DRAG);dom.unbind(window,'mousemove',drag);dom.unbind(window,'mouseup',dragStop);}}function setWidth(gui,w){gui.domElement.style.width = w + 'px'; // Auto placed save-rows are position fixed, so we have to
	// set the width manually if we want it to bleed to the edge
	if(gui.__save_row && gui.autoPlace){gui.__save_row.style.width = w + 'px';}if(gui.__closeButton){gui.__closeButton.style.width = w + 'px';}}function getCurrentPreset(gui,useInitialValues){var toReturn={}; // For each object I'm remembering
	common.each(gui.__rememberedObjects,function(val,index){var saved_values={}; // The controllers I've made for thcommon.isObject by property
	var controller_map=gui.__rememberedObjectIndecesToControllers[index]; // Remember each value for each property
	common.each(controller_map,function(controller,property){saved_values[property] = useInitialValues?controller.initialValue:controller.getValue();}); // Save the values for thcommon.isObject
	toReturn[index] = saved_values;});return toReturn;}function addPresetOption(gui,name,setSelected){var opt=document.createElement('option');opt.innerHTML = name;opt.value = name;gui.__preset_select.appendChild(opt);if(setSelected){gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;}}function setPresetSelectIndex(gui){for(var index=0;index < gui.__preset_select.length;index++) {if(gui.__preset_select[index].value == gui.preset){gui.__preset_select.selectedIndex = index;}}}function markPresetModified(gui,modified){var opt=gui.__preset_select[gui.__preset_select.selectedIndex]; //    console.log('mark', modified, opt);
	if(modified){opt.innerHTML = opt.value + "*";}else {opt.innerHTML = opt.value;}}function updateDisplays(controllerArray){if(controllerArray.length != 0){requestAnimationFrame(function(){updateDisplays(controllerArray);});}common.each(controllerArray,function(c){c.updateDisplay();});}return GUI;})(dat.utils.css,"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",".dg {\n  /** Clear list styles */\n  /* Auto-place container */\n  /* Auto-placed GUI's */\n  /* Line items that don't contain folders. */\n  /** Folder names */\n  /** Hides closed items */\n  /** Controller row */\n  /** Name-half (left) */\n  /** Controller-half (right) */\n  /** Controller placement */\n  /** Shorter number boxes when slider is present. */\n  /** Ensure the entire boolean and function row shows a hand */ }\n  .dg ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    clear: both; }\n  .dg.ac {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 0;\n    z-index: 0; }\n  .dg:not(.ac) .main {\n    /** Exclude mains in ac so that we don't hide close button */\n    overflow: hidden; }\n  .dg.main {\n    -webkit-transition: opacity 0.1s linear;\n    -o-transition: opacity 0.1s linear;\n    -moz-transition: opacity 0.1s linear;\n    transition: opacity 0.1s linear; }\n    .dg.main.taller-than-window {\n      overflow-y: auto; }\n      .dg.main.taller-than-window .close-button {\n        opacity: 1;\n        /* TODO, these are style notes */\n        margin-top: -1px;\n        border-top: 1px solid #2c2c2c; }\n    .dg.main ul.closed .close-button {\n      opacity: 1 !important; }\n    .dg.main:hover .close-button,\n    .dg.main .close-button.drag {\n      opacity: 1; }\n    .dg.main .close-button {\n      /*opacity: 0;*/\n      -webkit-transition: opacity 0.1s linear;\n      -o-transition: opacity 0.1s linear;\n      -moz-transition: opacity 0.1s linear;\n      transition: opacity 0.1s linear;\n      border: 0;\n      position: absolute;\n      line-height: 19px;\n      height: 20px;\n      /* TODO, these are style notes */\n      cursor: pointer;\n      text-align: center;\n      background-color: #000; }\n      .dg.main .close-button:hover {\n        background-color: #111; }\n  .dg.a {\n    float: right;\n    margin-right: 15px;\n    overflow-x: hidden; }\n    .dg.a.has-save > ul {\n      margin-top: 27px; }\n      .dg.a.has-save > ul.closed {\n        margin-top: 0; }\n    .dg.a .save-row {\n      position: fixed;\n      top: 0;\n      z-index: 1002; }\n  .dg li {\n    -webkit-transition: height 0.1s ease-out;\n    -o-transition: height 0.1s ease-out;\n    -moz-transition: height 0.1s ease-out;\n    transition: height 0.1s ease-out; }\n  .dg li:not(.folder) {\n    cursor: auto;\n    height: 27px;\n    line-height: 27px;\n    overflow: hidden;\n    padding: 0 4px 0 5px; }\n  .dg li.folder {\n    padding: 0;\n    border-left: 4px solid rgba(0, 0, 0, 0); }\n  .dg li.title {\n    cursor: pointer;\n    margin-left: -4px; }\n  .dg .closed li:not(.title),\n  .dg .closed ul li,\n  .dg .closed ul li > * {\n    height: 0;\n    overflow: hidden;\n    border: 0; }\n  .dg .cr {\n    clear: both;\n    padding-left: 3px;\n    height: 27px; }\n  .dg .property-name {\n    cursor: default;\n    float: left;\n    clear: left;\n    width: 40%;\n    overflow: hidden;\n    text-overflow: ellipsis; }\n  .dg .c {\n    float: left;\n    width: 60%; }\n  .dg .c input[type=text] {\n    border: 0;\n    margin-top: 4px;\n    padding: 3px;\n    width: 100%;\n    float: right; }\n  .dg .has-slider input[type=text] {\n    width: 30%;\n    /*display: none;*/\n    margin-left: 0; }\n  .dg .slider {\n    float: left;\n    width: 66%;\n    margin-left: -5px;\n    margin-right: 0;\n    height: 19px;\n    margin-top: 4px; }\n  .dg .slider-fg {\n    height: 100%; }\n  .dg .c input[type=checkbox] {\n    margin-top: 9px; }\n  .dg .c select {\n    margin-top: 5px; }\n  .dg .cr.function,\n  .dg .cr.function .property-name,\n  .dg .cr.function *,\n  .dg .cr.boolean,\n  .dg .cr.boolean * {\n    cursor: pointer; }\n  .dg .selector {\n    display: none;\n    position: absolute;\n    margin-left: -9px;\n    margin-top: 23px;\n    z-index: 10; }\n  .dg .c:hover .selector,\n  .dg .selector.drag {\n    display: block; }\n  .dg li.save-row {\n    padding: 0; }\n    .dg li.save-row .button {\n      display: inline-block;\n      padding: 0px 6px; }\n  .dg.dialogue {\n    background-color: #222;\n    width: 460px;\n    padding: 15px;\n    font-size: 13px;\n    line-height: 15px; }\n\n/* TODO Separate style and structure */\n#dg-new-constructor {\n  padding: 10px;\n  color: #222;\n  font-family: Monaco, monospace;\n  font-size: 10px;\n  border: 0;\n  resize: none;\n  box-shadow: inset 1px 1px 1px #888;\n  word-wrap: break-word;\n  margin: 12px 0;\n  display: block;\n  width: 440px;\n  overflow-y: scroll;\n  height: 100px;\n  position: relative; }\n\n#dg-local-explain {\n  display: none;\n  font-size: 11px;\n  line-height: 17px;\n  border-radius: 3px;\n  background-color: #333;\n  padding: 8px;\n  margin-top: 10px; }\n  #dg-local-explain code {\n    font-size: 10px; }\n\n#dat-gui-save-locally {\n  display: none; }\n\n/** Main type */\n.dg {\n  color: #eee;\n  font: 11px 'Lucida Grande', sans-serif;\n  text-shadow: 0 -1px 0 #111;\n  /** Auto place */\n  /* Controller row, <li> */\n  /** Controllers */ }\n  .dg.main {\n    /** Scrollbar */ }\n    .dg.main::-webkit-scrollbar {\n      width: 5px;\n      background: #1a1a1a; }\n    .dg.main::-webkit-scrollbar-corner {\n      height: 0;\n      display: none; }\n    .dg.main::-webkit-scrollbar-thumb {\n      border-radius: 5px;\n      background: #676767; }\n  .dg li:not(.folder) {\n    background: #1a1a1a;\n    border-bottom: 1px solid #2c2c2c; }\n  .dg li.save-row {\n    line-height: 25px;\n    background: #dad5cb;\n    border: 0; }\n    .dg li.save-row select {\n      margin-left: 5px;\n      width: 108px; }\n    .dg li.save-row .button {\n      margin-left: 5px;\n      margin-top: 1px;\n      border-radius: 2px;\n      font-size: 9px;\n      line-height: 7px;\n      padding: 4px 4px 5px 4px;\n      background: #c5bdad;\n      color: #fff;\n      text-shadow: 0 1px 0 #b0a58f;\n      box-shadow: 0 -1px 0 #b0a58f;\n      cursor: pointer; }\n      .dg li.save-row .button.gears {\n        background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;\n        height: 7px;\n        width: 8px; }\n      .dg li.save-row .button:hover {\n        background-color: #bab19e;\n        box-shadow: 0 -1px 0 #b0a58f; }\n  .dg li.folder {\n    border-bottom: 0; }\n  .dg li.title {\n    padding-left: 16px;\n    background: black url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\n    cursor: pointer;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2); }\n  .dg .closed li.title {\n    background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==); }\n  .dg .cr.boolean {\n    border-left: 3px solid #806787; }\n  .dg .cr.function {\n    border-left: 3px solid #e61d5f; }\n  .dg .cr.number {\n    border-left: 3px solid #2fa1d6; }\n    .dg .cr.number input[type=text] {\n      color: #2fa1d6; }\n  .dg .cr.string {\n    border-left: 3px solid #1ed36f; }\n    .dg .cr.string input[type=text] {\n      color: #1ed36f; }\n  .dg .cr.function:hover, .dg .cr.boolean:hover {\n    background: #111; }\n  .dg .c input[type=text] {\n    background: #303030;\n    outline: none; }\n    .dg .c input[type=text]:hover {\n      background: #3c3c3c; }\n    .dg .c input[type=text]:focus {\n      background: #494949;\n      color: #fff; }\n  .dg .c .slider {\n    background: #303030;\n    cursor: ew-resize; }\n  .dg .c .slider-fg {\n    background: #2fa1d6; }\n  .dg .c .slider:hover {\n    background: #3c3c3c; }\n    .dg .c .slider:hover .slider-fg {\n      background: #44abda; }\n",dat.controllers.factory = (function(OptionController,NumberControllerBox,NumberControllerSlider,StringController,FunctionController,BooleanController,common){return function(object,property){var initialValue=object[property]; // Providing options?
	if(common.isArray(arguments[2]) || common.isObject(arguments[2])){return new OptionController(object,property,arguments[2]);} // Providing a map?
	if(common.isNumber(initialValue)){if(common.isNumber(arguments[2]) && common.isNumber(arguments[3])){ // Has min and max.
	return new NumberControllerSlider(object,property,arguments[2],arguments[3]);}else {return new NumberControllerBox(object,property,{min:arguments[2],max:arguments[3]});}}if(common.isString(initialValue)){return new StringController(object,property);}if(common.isFunction(initialValue)){return new FunctionController(object,property,'');}if(common.isBoolean(initialValue)){return new BooleanController(object,property);}};})(dat.controllers.OptionController,dat.controllers.NumberControllerBox,dat.controllers.NumberControllerSlider,dat.controllers.StringController = (function(Controller,dom,common){ /**
	   * @class Provides a text input to alter the string property of an object.
	   *
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   *
	   * @member dat.controllers
	   */var StringController=function StringController(object,property){StringController.superclass.call(this,object,property);var _this=this;this.__input = document.createElement('input');this.__input.setAttribute('type','text');dom.bind(this.__input,'keyup',onChange);dom.bind(this.__input,'change',onChange);dom.bind(this.__input,'blur',onBlur);dom.bind(this.__input,'keydown',function(e){if(e.keyCode === 13){this.blur();}});function onChange(){_this.setValue(_this.__input.value);}function onBlur(){if(_this.__onFinishChange){_this.__onFinishChange.call(_this,_this.getValue());}}this.updateDisplay();this.domElement.appendChild(this.__input);};StringController.superclass = Controller;common.extend(StringController.prototype,Controller.prototype,{updateDisplay:function updateDisplay(){ // Stops the caret from moving on account of:
	// keyup -> setValue -> updateDisplay
	if(!dom.isActive(this.__input)){this.__input.value = this.getValue();}return StringController.superclass.prototype.updateDisplay.call(this);}});return StringController;})(dat.controllers.Controller,dat.dom.dom,dat.utils.common),dat.controllers.FunctionController,dat.controllers.BooleanController,dat.utils.common),dat.controllers.Controller,dat.controllers.BooleanController,dat.controllers.FunctionController,dat.controllers.NumberControllerBox,dat.controllers.NumberControllerSlider,dat.controllers.OptionController,dat.controllers.ColorController = (function(Controller,dom,Color,interpret,common){var ColorController=function ColorController(object,property){ColorController.superclass.call(this,object,property);this.__color = new Color(this.getValue());this.__temp = new Color(0);var _this=this;this.domElement = document.createElement('div');dom.makeSelectable(this.domElement,false);this.__selector = document.createElement('div');this.__selector.className = 'selector';this.__saturation_field = document.createElement('div');this.__saturation_field.className = 'saturation-field';this.__field_knob = document.createElement('div');this.__field_knob.className = 'field-knob';this.__field_knob_border = '2px solid ';this.__hue_knob = document.createElement('div');this.__hue_knob.className = 'hue-knob';this.__hue_field = document.createElement('div');this.__hue_field.className = 'hue-field';this.__input = document.createElement('input');this.__input.type = 'text';this.__input_textShadow = '0 1px 1px ';dom.bind(this.__input,'keydown',function(e){if(e.keyCode === 13){ // on enter
	onBlur.call(this);}});dom.bind(this.__input,'blur',onBlur);dom.bind(this.__selector,'mousedown',function(e){dom.addClass(this,'drag').bind(window,'mouseup',function(e){dom.removeClass(_this.__selector,'drag');});});var value_field=document.createElement('div');common.extend(this.__selector.style,{width:'122px',height:'102px',padding:'3px',backgroundColor:'#222',boxShadow:'0px 1px 3px rgba(0,0,0,0.3)'});common.extend(this.__field_knob.style,{position:'absolute',width:'12px',height:'12px',border:this.__field_knob_border + (this.__color.v < .5?'#fff':'#000'),boxShadow:'0px 1px 3px rgba(0,0,0,0.5)',borderRadius:'12px',zIndex:1});common.extend(this.__hue_knob.style,{position:'absolute',width:'15px',height:'2px',borderRight:'4px solid #fff',zIndex:1});common.extend(this.__saturation_field.style,{width:'100px',height:'100px',border:'1px solid #555',marginRight:'3px',display:'inline-block',cursor:'pointer'});common.extend(value_field.style,{width:'100%',height:'100%',background:'none'});linearGradient(value_field,'top','rgba(0,0,0,0)','#000');common.extend(this.__hue_field.style,{width:'15px',height:'100px',display:'inline-block',border:'1px solid #555',cursor:'ns-resize'});hueGradient(this.__hue_field);common.extend(this.__input.style,{outline:'none', //      width: '120px',
	textAlign:'center', //      padding: '4px',
	//      marginBottom: '6px',
	color:'#fff',border:0,fontWeight:'bold',textShadow:this.__input_textShadow + 'rgba(0,0,0,0.7)'});dom.bind(this.__saturation_field,'mousedown',fieldDown);dom.bind(this.__field_knob,'mousedown',fieldDown);dom.bind(this.__hue_field,'mousedown',function(e){setH(e);dom.bind(window,'mousemove',setH);dom.bind(window,'mouseup',unbindH);});function fieldDown(e){setSV(e); // document.body.style.cursor = 'none';
	dom.bind(window,'mousemove',setSV);dom.bind(window,'mouseup',unbindSV);}function unbindSV(){dom.unbind(window,'mousemove',setSV);dom.unbind(window,'mouseup',unbindSV); // document.body.style.cursor = 'default';
	}function onBlur(){var i=interpret(this.value);if(i !== false){_this.__color.__state = i;_this.setValue(_this.__color.toOriginal());}else {this.value = _this.__color.toString();}}function unbindH(){dom.unbind(window,'mousemove',setH);dom.unbind(window,'mouseup',unbindH);}this.__saturation_field.appendChild(value_field);this.__selector.appendChild(this.__field_knob);this.__selector.appendChild(this.__saturation_field);this.__selector.appendChild(this.__hue_field);this.__hue_field.appendChild(this.__hue_knob);this.domElement.appendChild(this.__input);this.domElement.appendChild(this.__selector);this.updateDisplay();function setSV(e){e.preventDefault();var w=dom.getWidth(_this.__saturation_field);var o=dom.getOffset(_this.__saturation_field);var s=(e.clientX - o.left + document.body.scrollLeft) / w;var v=1 - (e.clientY - o.top + document.body.scrollTop) / w;if(v > 1)v = 1;else if(v < 0)v = 0;if(s > 1)s = 1;else if(s < 0)s = 0;_this.__color.v = v;_this.__color.s = s;_this.setValue(_this.__color.toOriginal());return false;}function setH(e){e.preventDefault();var s=dom.getHeight(_this.__hue_field);var o=dom.getOffset(_this.__hue_field);var h=1 - (e.clientY - o.top + document.body.scrollTop) / s;if(h > 1)h = 1;else if(h < 0)h = 0;_this.__color.h = h * 360;_this.setValue(_this.__color.toOriginal());return false;}};ColorController.superclass = Controller;common.extend(ColorController.prototype,Controller.prototype,{updateDisplay:function updateDisplay(){var i=interpret(this.getValue());if(i !== false){var mismatch=false; // Check for mismatch on the interpreted value.
	common.each(Color.COMPONENTS,function(component){if(!common.isUndefined(i[component]) && !common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]){mismatch = true;return {}; // break
	}},this); // If nothing diverges, we keep our previous values
	// for statefulness, otherwise we recalculate fresh
	if(mismatch){common.extend(this.__color.__state,i);}}common.extend(this.__temp.__state,this.__color.__state);this.__temp.a = 1;var flip=this.__color.v < .5 || this.__color.s > .5?255:0;var _flip=255 - flip;common.extend(this.__field_knob.style,{marginLeft:100 * this.__color.s - 7 + 'px',marginTop:100 * (1 - this.__color.v) - 7 + 'px',backgroundColor:this.__temp.toString(),border:this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'});this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';this.__temp.s = 1;this.__temp.v = 1;linearGradient(this.__saturation_field,'left','#fff',this.__temp.toString());common.extend(this.__input.style,{backgroundColor:this.__input.value = this.__color.toString(),color:'rgb(' + flip + ',' + flip + ',' + flip + ')',textShadow:this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'});}});var vendors=['-moz-','-o-','-webkit-','-ms-',''];function linearGradient(elem,x,a,b){elem.style.background = '';common.each(vendors,function(vendor){elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';});}function hueGradient(elem){elem.style.background = '';elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';}return ColorController;})(dat.controllers.Controller,dat.dom.dom,dat.color.Color = (function(interpret,math,_toString,common){var Color=function Color(){this.__state = interpret.apply(this,arguments);if(this.__state === false){throw 'Failed to interpret color arguments';}this.__state.a = this.__state.a || 1;};Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];common.extend(Color.prototype,{toString:function toString(){return _toString(this);},toOriginal:function toOriginal(){return this.__state.conversion.write(this);}});defineRGBComponent(Color.prototype,'r',2);defineRGBComponent(Color.prototype,'g',1);defineRGBComponent(Color.prototype,'b',0);defineHSVComponent(Color.prototype,'h');defineHSVComponent(Color.prototype,'s');defineHSVComponent(Color.prototype,'v');Object.defineProperty(Color.prototype,'a',{get:function get(){return this.__state.a;},set:function set(v){this.__state.a = v;}});Object.defineProperty(Color.prototype,'hex',{get:function get(){if(!this.__state.space !== 'HEX'){this.__state.hex = math.rgb_to_hex(this.r,this.g,this.b);}return this.__state.hex;},set:function set(v){this.__state.space = 'HEX';this.__state.hex = v;}});function defineRGBComponent(target,component,componentHexIndex){_Object$defineProperty(target,component,{get:function get(){if(this.__state.space === 'RGB'){return this.__state[component];}recalculateRGB(this,component,componentHexIndex);return this.__state[component];},set:function set(v){if(this.__state.space !== 'RGB'){recalculateRGB(this,component,componentHexIndex);this.__state.space = 'RGB';}this.__state[component] = v;}});}function defineHSVComponent(target,component){_Object$defineProperty(target,component,{get:function get(){if(this.__state.space === 'HSV')return this.__state[component];recalculateHSV(this);return this.__state[component];},set:function set(v){if(this.__state.space !== 'HSV'){recalculateHSV(this);this.__state.space = 'HSV';}this.__state[component] = v;}});}function recalculateRGB(color,component,componentHexIndex){if(color.__state.space === 'HEX'){color.__state[component] = math.component_from_hex(color.__state.hex,componentHexIndex);}else if(color.__state.space === 'HSV'){common.extend(color.__state,math.hsv_to_rgb(color.__state.h,color.__state.s,color.__state.v));}else {throw 'Corrupted color state';}}function recalculateHSV(color){var result=math.rgb_to_hsv(color.r,color.g,color.b);common.extend(color.__state,{s:result.s,v:result.v});if(!common.isNaN(result.h)){color.__state.h = result.h;}else if(common.isUndefined(color.__state.h)){color.__state.h = 0;}}return Color;})(dat.color.interpret,dat.color.math = (function(){var tmpComponent;return {hsv_to_rgb:function hsv_to_rgb(h,s,v){var hi=Math.floor(h / 60) % 6;var f=h / 60 - Math.floor(h / 60);var p=v * (1.0 - s);var q=v * (1.0 - f * s);var t=v * (1.0 - (1.0 - f) * s);var c=[[v,t,p],[q,v,p],[p,v,t],[p,q,v],[t,p,v],[v,p,q]][hi];return {r:c[0] * 255,g:c[1] * 255,b:c[2] * 255};},rgb_to_hsv:function rgb_to_hsv(r,g,b){var min=Math.min(r,g,b),max=Math.max(r,g,b),delta=max - min,h,s;if(max != 0){s = delta / max;}else {return {h:NaN,s:0,v:0};}if(r == max){h = (g - b) / delta;}else if(g == max){h = 2 + (b - r) / delta;}else {h = 4 + (r - g) / delta;}h /= 6;if(h < 0){h += 1;}return {h:h * 360,s:s,v:max / 255};},rgb_to_hex:function rgb_to_hex(r,g,b){var hex=this.hex_with_component(0,2,r);hex = this.hex_with_component(hex,1,g);hex = this.hex_with_component(hex,0,b);return hex;},component_from_hex:function component_from_hex(hex,componentIndex){return hex >> componentIndex * 8 & 0xFF;},hex_with_component:function hex_with_component(hex,componentIndex,value){return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);}};})(),dat.color.toString,dat.utils.common),dat.color.interpret,dat.utils.common),dat.utils.requestAnimationFrame = (function(){ /**
	   * requirejs version of Paul Irish's RequestAnimationFrame
	   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	   */return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback,element){window.setTimeout(callback,1000 / 60);};})(),dat.dom.CenteredDiv = (function(dom,common){var CenteredDiv=function CenteredDiv(){this.backgroundElement = document.createElement('div');common.extend(this.backgroundElement.style,{backgroundColor:'rgba(0,0,0,0.8)',top:0,left:0,display:'none',zIndex:'1000',opacity:0,WebkitTransition:'opacity 0.2s linear',transition:'opacity 0.2s linear'});dom.makeFullscreen(this.backgroundElement);this.backgroundElement.style.position = 'fixed';this.domElement = document.createElement('div');common.extend(this.domElement.style,{position:'fixed',display:'none',zIndex:'1001',opacity:0,WebkitTransition:'-webkit-transform 0.2s ease-out, opacity 0.2s linear',transition:'transform 0.2s ease-out, opacity 0.2s linear'});document.body.appendChild(this.backgroundElement);document.body.appendChild(this.domElement);var _this=this;dom.bind(this.backgroundElement,'click',function(){_this.hide();});};CenteredDiv.prototype.show = function(){var _this=this;this.backgroundElement.style.display = 'block';this.domElement.style.display = 'block';this.domElement.style.opacity = 0; //    this.domElement.style.top = '52%';
	this.domElement.style.webkitTransform = 'scale(1.1)';this.layout();common.defer(function(){_this.backgroundElement.style.opacity = 1;_this.domElement.style.opacity = 1;_this.domElement.style.webkitTransform = 'scale(1)';});};CenteredDiv.prototype.hide = function(){var _this=this;var hide=function hide(){_this.domElement.style.display = 'none';_this.backgroundElement.style.display = 'none';dom.unbind(_this.domElement,'webkitTransitionEnd',hide);dom.unbind(_this.domElement,'transitionend',hide);dom.unbind(_this.domElement,'oTransitionEnd',hide);};dom.bind(this.domElement,'webkitTransitionEnd',hide);dom.bind(this.domElement,'transitionend',hide);dom.bind(this.domElement,'oTransitionEnd',hide);this.backgroundElement.style.opacity = 0; //    this.domElement.style.top = '48%';
	this.domElement.style.opacity = 0;this.domElement.style.webkitTransform = 'scale(1.1)';};CenteredDiv.prototype.layout = function(){this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';};function lockScroll(e){console.log(e);}return CenteredDiv;})(dat.dom.dom,dat.utils.common),dat.dom.dom,dat.utils.common);module.exports = dat;

/***/ },
/* 222 */
/*!*************************************************************!*\
  !*** ./~/babel-runtime/core-js/object/define-properties.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-properties */ 223), __esModule: true };

/***/ },
/* 223 */
/*!**************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/define-properties.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(/*! ../../modules/$ */ 224);
	module.exports = function defineProperties(T, D){
	  return $.setDescs(T, D);
	};

/***/ },
/* 224 */
/*!********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.js ***!
  \********************************************************/
/***/ function(module, exports) {

	var $Object = Object;
	module.exports = {
	  create:     $Object.create,
	  getProto:   $Object.getPrototypeOf,
	  isEnum:     {}.propertyIsEnumerable,
	  getDesc:    $Object.getOwnPropertyDescriptor,
	  setDesc:    $Object.defineProperty,
	  setDescs:   $Object.defineProperties,
	  getKeys:    $Object.keys,
	  getNames:   $Object.getOwnPropertyNames,
	  getSymbols: $Object.getOwnPropertySymbols,
	  each:       [].forEach
	};

/***/ },
/* 225 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/core-js/object/define-property.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-property */ 226), __esModule: true };

/***/ },
/* 226 */
/*!************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/object/define-property.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(/*! ../../modules/$ */ 224);
	module.exports = function defineProperty(it, key, desc){
	  return $.setDesc(it, key, desc);
	};

/***/ },
/* 227 */
/*!*****************************************!*\
  !*** ./static/js/procedural/terrain.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 1)["default"];

	exports.__esModule = true;

	var _engine = __webpack_require__(/*! engine */ 194);

	var _proceduralNoise = __webpack_require__(/*! procedural/noise */ 228);

	var _utilNdarray = __webpack_require__(/*! util/ndarray */ 230);

	var _utilNdarray2 = _interopRequireDefault(_utilNdarray);

	var _constMaterial = __webpack_require__(/*! const/material */ 219);

	var _constMaterial2 = _interopRequireDefault(_constMaterial);

	function generateHeightmap(chunkSize, tileSize, chunkX, chunkY, func) {
	    var size = chunkSize / tileSize + 1;
	    var mid = size / 2 | 0;

	    var data = _utilNdarray2["default"].fill(size, size, function (i, j) {
	        var x = i + chunkX * (size - 1);
	        var y = j + chunkY * (size - 1);
	        var z = func(x, y);

	        return new _engine.THREE.Vector3((i - mid) * tileSize, z, (j - mid) * tileSize);
	    });

	    return data;
	}

	function buildGeometry(data) {
	    var sample = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

	    var size = Math.sqrt(data.size);
	    var mid = (size - 1) / 2 | 0;
	    var geometry = new _engine.THREE.Geometry();

	    var c = 0;
	    for (var i = 0; i < size - 1; i += sample) {
	        for (var j = 0; j < size - 1; j += sample) {
	            var i2 = Math.min(i + sample, size - 1);
	            var j2 = Math.min(j + sample, size - 1);

	            var v1 = data.get(i, j);
	            var v2 = data.get(i2, j);
	            var v3 = data.get(i, j2);
	            var v4 = data.get(i2, j2);

	            //TODO dont alternate face sides
	            geometry.vertices.push(v1, v2, v3, v4);
	            geometry.faces.push(new _engine.THREE.Face3(c, c + 1, c + 2), new _engine.THREE.Face3(c + 1, c + 2, c + 3));
	            c += 4;
	        }
	    }

	    geometry.mergeVertices();
	    geometry.computeFaceNormals();
	    return geometry;
	}

	function buildLOD(data, material, distance, samples) {
	    var lod = new _engine.THREE.LOD();

	    for (var i = 0; i < samples; i++) {
	        var geometry = buildGeometry(data, Math.pow(2, i));
	        var mesh = new _engine.THREE.Mesh(geometry, material);
	        lod.addLevel(mesh, distance * i * 2);
	    }

	    return lod;
	}

	exports["default"] = {
	    Ground: function Ground(chunkSize, chunkX, chunkY) {
	        var tileSize = 1;
	        var data = generateHeightmap(chunkSize, tileSize, chunkX, chunkY, function (x, y) {
	            var z = 0;

	            var p0 = 8 * _proceduralNoise.noise.perlin2(x * 0.01, y * 0.01);
	            var p1 = 5 * _proceduralNoise.noise.perlin2(x * 0.03, y * 0.03);
	            var p2 = 2 * _proceduralNoise.noise.perlin2(x * 0.1, y * 0.1);
	            var p3 = 0.2 * _proceduralNoise.noise.perlin2(x * 0.9, y * 0.9);

	            z += (p0 > 0 ? 1 : -1) * Math.pow(p0, 2);
	            z += (p1 > 0 ? 1 : -1) * Math.pow(p1, 2);
	            z += p2 > 0 ? p2 : Math.pow(2, p2) - 1;
	            z += p3 > 0 ? p3 : Math.pow(2, p3) - 1;

	            return z;
	        });

	        var lod = buildLOD(data, _constMaterial2["default"].GROUND, chunkSize, 7);
	        lod.position.x = chunkX * chunkSize;
	        lod.position.z = chunkY * chunkSize;
	        lod.updateMatrixWorld();

	        return lod;
	    },

	    Water: function Water(chunkSize, chunkX, chunkY) {
	        var tileSize = 4;
	        var data = generateHeightmap(chunkSize, tileSize, chunkX, chunkY, function (x, y) {
	            return 2 * Math.pow(_proceduralNoise.noise.perlin2(0.3 * x, 0.3 * y));
	        });
	        var geometry = buildGeometry(data);
	        var mesh = new _engine.THREE.Mesh(geometry, _constMaterial2["default"].WATER);
	        mesh.position.x = chunkX * chunkSize;
	        mesh.position.y = -5;
	        mesh.position.z = chunkY * chunkSize;
	        return mesh;
	    },

	    DiamondSquare: function DiamondSquare(chunkSize, chunkX, chunkY, initializer) {
	        var size = chunkSize + 1;
	        var mid = size / 2 | 0;
	        var data = _utilNdarray2["default"].array(size, size);

	        if (initializer) {
	            initializer(data, size);
	        } else {
	            data.set(0, 0, new _engine.THREE.Vector3(0, size / 2 * (Math.random() - 0.5), 0));
	            data.set(size - 1, 0, new _engine.THREE.Vector3(size - 1, size / 2 * (Math.random() - 0.5), 0));
	            data.set(0, size - 1, new _engine.THREE.Vector3(0, size / 2 * (Math.random() - 0.5), size - 1));
	            data.set(size - 1, size - 1, new _engine.THREE.Vector3(size - 1, size / 2 * (Math.random() - 0.5), size - 1));
	        }

	        var q = [];
	        q.enqueue = function (x, y, iter) {
	            //TODO do this efficiently
	            var s = size >>> 1 + (iter >>> 1);
	            if (x >= 0 && x < size && y >= 0 && y < size && s >= 1) {
	                var seen = false;
	                for (var i = 0; i < q.length; i++) {
	                    if (q[i].x === x && q[i].y === y && q[i].iter === iter) {
	                        seen = true;
	                        break;
	                    }
	                }

	                if (!seen) {
	                    this.push({ x: x, y: y, iter: iter });
	                }
	            }
	        };

	        q.enqueue(size >>> 1, size >>> 1, 0);

	        while (q.length > 0) {
	            var length = q.length;
	            for (var l = 0; l < length; l++) {
	                var ctx = q.shift();
	                var x = ctx.x,
	                    y = ctx.y,
	                    iter = ctx.iter;
	                var s = size >>> 1 + (iter >>> 1);

	                if (iter % 2 == 0) {
	                    if (data.get(x, y) === undefined) {
	                        var z1 = data.get(x - s, y - s).y;
	                        var z2 = data.get(x + s, y - s).y;
	                        var z3 = data.get(x - s, y + s).y;
	                        var z4 = data.get(x + s, y + s).y;

	                        var z = (z1 + z2 + z3 + z4) / 4 + 2 * s * (Math.random() - 0.5);
	                        data.set(x, y, new _engine.THREE.Vector3(x, z, y));
	                    }

	                    q.enqueue(x - s, y, iter + 1);
	                    q.enqueue(x + s, y, iter + 1);
	                    q.enqueue(x, y - s, iter + 1);
	                    q.enqueue(x, y + s, iter + 1);
	                } else {
	                    if (data.get(x, y) === undefined) {
	                        var zs = 0;
	                        var zc = 0;

	                        if (x - s >= 0) {
	                            zs += data.get(x - s, y).y;zc++;
	                        }
	                        if (x + s < size) {
	                            zs += data.get(x + s, y).y;zc++;
	                        }
	                        if (y - s >= 0) {
	                            zs += data.get(x, y - s).y;zc++;
	                        }
	                        if (y + s < size) {
	                            zs += data.get(x, y + s).y;zc++;
	                        }

	                        var z = zs / zc + (s >>> 0) * (Math.random() - 0.5);
	                        data.set(x, y, new _engine.THREE.Vector3(x, z, y));
	                    }

	                    var s2 = s >>> 1;
	                    q.enqueue(x + s2, y + s2, iter + 1);
	                    q.enqueue(x + s2, y - s2, iter + 1);
	                    q.enqueue(x - s2, y + s2, iter + 1);
	                    q.enqueue(x - s2, y - s2, iter + 1);
	                }
	            }
	        }

	        // now center the vertices
	        data.data.forEach(function (v) {
	            v.x -= mid;v.z -= mid;
	        });

	        var lod = buildLOD(data, _constMaterial2["default"].GROUND, chunkSize, 4);
	        lod.position.x = chunkX * chunkSize;
	        lod.position.z = chunkY * chunkSize;
	        lod.updateMatrixWorld();

	        return lod;
	    }
	};
	module.exports = exports["default"];

/***/ },
/* 228 */
/*!***************************************!*\
  !*** ./static/js/procedural/noise.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 1)["default"];

	var _noisejs = __webpack_require__(/*! noisejs */ 229);

	var _noisejs2 = _interopRequireDefault(_noisejs);

	var noise = new _noisejs2["default"].Noise(Math.random());

	function perlin(x, y) {
	    var octaves = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];

	    var z = 0;
	    var s = 0;
	    for (var i = 0; i < octaves; i++) {
	        var pp = 1 / (1 << i); // (1 << i) same as Math.pow(2,i)
	        var e = Math.PI / 2 * pp; // rotate angle
	        var ss = Math.sin(e);
	        var cc = Math.cos(e);
	        var xx = x * ss + y * cc; // rotation
	        var yy = -x * cc + y * ss;
	        s += pp; // total amplitude
	        var res = pp * noise.perlin2(xx / pp, yy / pp);
	        if (i < 4) {
	            z += (res > 0 ? 1 : -1) * Math.pow(res, 2);
	        } else {
	            z += res;
	        }
	    }
	    return 2 * z / s;
	}

	module.exports = {
	    noise: noise,
	    perlin: perlin
	};

/***/ },
/* 229 */
/*!****************************!*\
  !*** ./~/noisejs/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A speed-improved perlin and simplex noise algorithms for 2D.
	 *
	 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
	 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
	 * Better rank ordering method by Stefan Gustavson in 2012.
	 * Converted to Javascript by Joseph Gentle.
	 *
	 * Version 2012-03-09
	 *
	 * This code was placed in the public domain by its original author,
	 * Stefan Gustavson. You may use it as you see fit, but
	 * attribution is appreciated.
	 *
	 */

	(function(global){

	  // Passing in seed will seed this Noise instance
	  function Noise(seed) {
	    function Grad(x, y, z) {
	      this.x = x; this.y = y; this.z = z;
	    }

	    Grad.prototype.dot2 = function(x, y) {
	      return this.x*x + this.y*y;
	    };

	    Grad.prototype.dot3 = function(x, y, z) {
	      return this.x*x + this.y*y + this.z*z;
	    };

	    this.grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),
	                 new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),
	                 new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];

	    this.p = [151,160,137,91,90,15,
	    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
	    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
	    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
	    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
	    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
	    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
	    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
	    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
	    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
	    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
	    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
	    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
	    // To remove the need for index wrapping, double the permutation table length
	    this.perm = new Array(512);
	    this.gradP = new Array(512);

	    this.seed(seed || 0);
	  }

	  // This isn't a very good seeding function, but it works ok. It supports 2^16
	  // different seed values. Write something better if you need more seeds.
	  Noise.prototype.seed = function(seed) {
	    if(seed > 0 && seed < 1) {
	      // Scale the seed out
	      seed *= 65536;
	    }

	    seed = Math.floor(seed);
	    if(seed < 256) {
	      seed |= seed << 8;
	    }

	    var p = this.p;
	    for(var i = 0; i < 256; i++) {
	      var v;
	      if (i & 1) {
	        v = p[i] ^ (seed & 255);
	      } else {
	        v = p[i] ^ ((seed>>8) & 255);
	      }

	      var perm = this.perm;
	      var gradP = this.gradP;
	      perm[i] = perm[i + 256] = v;
	      gradP[i] = gradP[i + 256] = this.grad3[v % 12];
	    }
	  };

	  /*
	  for(var i=0; i<256; i++) {
	    perm[i] = perm[i + 256] = p[i];
	    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
	  }*/

	  // Skewing and unskewing factors for 2, 3, and 4 dimensions
	  var F2 = 0.5*(Math.sqrt(3)-1);
	  var G2 = (3-Math.sqrt(3))/6;

	  var F3 = 1/3;
	  var G3 = 1/6;

	  // 2D simplex noise
	  Noise.prototype.simplex2 = function(xin, yin) {
	    var n0, n1, n2; // Noise contributions from the three corners
	    // Skew the input space to determine which simplex cell we're in
	    var s = (xin+yin)*F2; // Hairy factor for 2D
	    var i = Math.floor(xin+s);
	    var j = Math.floor(yin+s);
	    var t = (i+j)*G2;
	    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
	    var y0 = yin-j+t;
	    // For the 2D case, the simplex shape is an equilateral triangle.
	    // Determine which simplex we are in.
	    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
	    if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
	      i1=1; j1=0;
	    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)
	      i1=0; j1=1;
	    }
	    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
	    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
	    // c = (3-sqrt(3))/6
	    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
	    var y1 = y0 - j1 + G2;
	    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
	    var y2 = y0 - 1 + 2 * G2;
	    // Work out the hashed gradient indices of the three simplex corners
	    i &= 255;
	    j &= 255;

	    var perm = this.perm;
	    var gradP = this.gradP;
	    var gi0 = gradP[i+perm[j]];
	    var gi1 = gradP[i+i1+perm[j+j1]];
	    var gi2 = gradP[i+1+perm[j+1]];
	    // Calculate the contribution from the three corners
	    var t0 = 0.5 - x0*x0-y0*y0;
	    if(t0<0) {
	      n0 = 0;
	    } else {
	      t0 *= t0;
	      n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient
	    }
	    var t1 = 0.5 - x1*x1-y1*y1;
	    if(t1<0) {
	      n1 = 0;
	    } else {
	      t1 *= t1;
	      n1 = t1 * t1 * gi1.dot2(x1, y1);
	    }
	    var t2 = 0.5 - x2*x2-y2*y2;
	    if(t2<0) {
	      n2 = 0;
	    } else {
	      t2 *= t2;
	      n2 = t2 * t2 * gi2.dot2(x2, y2);
	    }
	    // Add contributions from each corner to get the final noise value.
	    // The result is scaled to return values in the interval [-1,1].
	    return 70 * (n0 + n1 + n2);
	  };

	  // 3D simplex noise
	  Noise.prototype.simplex3 = function(xin, yin, zin) {
	    var n0, n1, n2, n3; // Noise contributions from the four corners

	    // Skew the input space to determine which simplex cell we're in
	    var s = (xin+yin+zin)*F3; // Hairy factor for 2D
	    var i = Math.floor(xin+s);
	    var j = Math.floor(yin+s);
	    var k = Math.floor(zin+s);

	    var t = (i+j+k)*G3;
	    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
	    var y0 = yin-j+t;
	    var z0 = zin-k+t;

	    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
	    // Determine which simplex we are in.
	    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
	    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
	    if(x0 >= y0) {
	      if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
	      else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
	      else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
	    } else {
	      if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
	      else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
	      else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
	    }
	    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
	    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
	    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
	    // c = 1/6.
	    var x1 = x0 - i1 + G3; // Offsets for second corner
	    var y1 = y0 - j1 + G3;
	    var z1 = z0 - k1 + G3;

	    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
	    var y2 = y0 - j2 + 2 * G3;
	    var z2 = z0 - k2 + 2 * G3;

	    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
	    var y3 = y0 - 1 + 3 * G3;
	    var z3 = z0 - 1 + 3 * G3;

	    // Work out the hashed gradient indices of the four simplex corners
	    i &= 255;
	    j &= 255;
	    k &= 255;

	    var perm = this.perm;
	    var gradP = this.gradP;
	    var gi0 = gradP[i+   perm[j+   perm[k   ]]];
	    var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];
	    var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];
	    var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];

	    // Calculate the contribution from the four corners
	    var t0 = 0.5 - x0*x0-y0*y0-z0*z0;
	    if(t0<0) {
	      n0 = 0;
	    } else {
	      t0 *= t0;
	      n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient
	    }
	    var t1 = 0.5 - x1*x1-y1*y1-z1*z1;
	    if(t1<0) {
	      n1 = 0;
	    } else {
	      t1 *= t1;
	      n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
	    }
	    var t2 = 0.5 - x2*x2-y2*y2-z2*z2;
	    if(t2<0) {
	      n2 = 0;
	    } else {
	      t2 *= t2;
	      n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
	    }
	    var t3 = 0.5 - x3*x3-y3*y3-z3*z3;
	    if(t3<0) {
	      n3 = 0;
	    } else {
	      t3 *= t3;
	      n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
	    }
	    // Add contributions from each corner to get the final noise value.
	    // The result is scaled to return values in the interval [-1,1].
	    return 32 * (n0 + n1 + n2 + n3);

	  };

	  // ##### Perlin noise stuff

	  function fade(t) {
	    return t*t*t*(t*(t*6-15)+10);
	  }

	  function lerp(a, b, t) {
	    return (1-t)*a + t*b;
	  }

	  // 2D Perlin Noise
	  Noise.prototype.perlin2 = function(x, y) {
	    // Find unit grid cell containing point
	    var X = Math.floor(x), Y = Math.floor(y);
	    // Get relative xy coordinates of point within that cell
	    x = x - X; y = y - Y;
	    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
	    X = X & 255; Y = Y & 255;

	    // Calculate noise contributions from each of the four corners
	    var perm = this.perm;
	    var gradP = this.gradP;
	    var n00 = gradP[X+perm[Y]].dot2(x, y);
	    var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);
	    var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);
	    var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);

	    // Compute the fade curve value for x
	    var u = fade(x);

	    // Interpolate the four results
	    return lerp(
	        lerp(n00, n10, u),
	        lerp(n01, n11, u),
	       fade(y));
	  };

	  // 3D Perlin Noise
	  Noise.prototype.perlin3 = function(x, y, z) {
	    // Find unit grid cell containing point
	    var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);
	    // Get relative xyz coordinates of point within that cell
	    x = x - X; y = y - Y; z = z - Z;
	    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
	    X = X & 255; Y = Y & 255; Z = Z & 255;

	    // Calculate noise contributions from each of the eight corners
	    var perm = this.perm;
	    var gradP = this.gradP;
	    var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);
	    var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);
	    var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);
	    var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);
	    var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);
	    var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);
	    var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);
	    var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);

	    // Compute the fade curve value for x, y, z
	    var u = fade(x);
	    var v = fade(y);
	    var w = fade(z);

	    // Interpolate
	    return lerp(
	        lerp(
	          lerp(n000, n100, u),
	          lerp(n001, n101, u), w),
	        lerp(
	          lerp(n010, n110, u),
	          lerp(n011, n111, u), w),
	       v);
	  };

	  global.Noise = Noise;

	})( false ? this : module.exports);


/***/ },
/* 230 */
/*!***********************************!*\
  !*** ./static/js/util/ndarray.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 1)["default"];

	var _ndarray = __webpack_require__(/*! ndarray */ 231);

	var _ndarray2 = _interopRequireDefault(_ndarray);

	var _ndarrayFill = __webpack_require__(/*! ndarray-fill */ 234);

	var _ndarrayFill2 = _interopRequireDefault(_ndarrayFill);

	function array(width, height) {
	    return _ndarray2["default"](new Array(width * height), [width, height]);
	}

	function fill(width, height, filler) {
	    return _ndarrayFill2["default"](array(width, height), filler);
	}

	module.exports = { array: array, fill: fill };

/***/ },
/* 231 */
/*!******************************!*\
  !*** ./~/ndarray/ndarray.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	var iota = __webpack_require__(/*! iota-array */ 232)
	var isBuffer = __webpack_require__(/*! is-buffer */ 233)

	var hasTypedArrays  = ((typeof Float64Array) !== "undefined")

	function compare1st(a, b) {
	  return a[0] - b[0]
	}

	function order() {
	  var stride = this.stride
	  var terms = new Array(stride.length)
	  var i
	  for(i=0; i<terms.length; ++i) {
	    terms[i] = [Math.abs(stride[i]), i]
	  }
	  terms.sort(compare1st)
	  var result = new Array(terms.length)
	  for(i=0; i<result.length; ++i) {
	    result[i] = terms[i][1]
	  }
	  return result
	}

	function compileConstructor(dtype, dimension) {
	  var className = ["View", dimension, "d", dtype].join("")
	  if(dimension < 0) {
	    className = "View_Nil" + dtype
	  }
	  var useGetters = (dtype === "generic")

	  if(dimension === -1) {
	    //Special case for trivial arrays
	    var code =
	      "function "+className+"(a){this.data=a;};\
	var proto="+className+".prototype;\
	proto.dtype='"+dtype+"';\
	proto.index=function(){return -1};\
	proto.size=0;\
	proto.dimension=-1;\
	proto.shape=proto.stride=proto.order=[];\
	proto.lo=proto.hi=proto.transpose=proto.step=\
	function(){return new "+className+"(this.data);};\
	proto.get=proto.set=function(){};\
	proto.pick=function(){return null};\
	return function construct_"+className+"(a){return new "+className+"(a);}"
	    var procedure = new Function(code)
	    return procedure()
	  } else if(dimension === 0) {
	    //Special case for 0d arrays
	    var code =
	      "function "+className+"(a,d) {\
	this.data = a;\
	this.offset = d\
	};\
	var proto="+className+".prototype;\
	proto.dtype='"+dtype+"';\
	proto.index=function(){return this.offset};\
	proto.dimension=0;\
	proto.size=1;\
	proto.shape=\
	proto.stride=\
	proto.order=[];\
	proto.lo=\
	proto.hi=\
	proto.transpose=\
	proto.step=function "+className+"_copy() {\
	return new "+className+"(this.data,this.offset)\
	};\
	proto.pick=function "+className+"_pick(){\
	return TrivialArray(this.data);\
	};\
	proto.valueOf=proto.get=function "+className+"_get(){\
	return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
	"};\
	proto.set=function "+className+"_set(v){\
	return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
	};\
	return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
	    var procedure = new Function("TrivialArray", code)
	    return procedure(CACHED_CONSTRUCTORS[dtype][0])
	  }

	  var code = ["'use strict'"]

	  //Create constructor for view
	  var indices = iota(dimension)
	  var args = indices.map(function(i) { return "i"+i })
	  var index_str = "this.offset+" + indices.map(function(i) {
	        return "this.stride[" + i + "]*i" + i
	      }).join("+")
	  var shapeArg = indices.map(function(i) {
	      return "b"+i
	    }).join(",")
	  var strideArg = indices.map(function(i) {
	      return "c"+i
	    }).join(",")
	  code.push(
	    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
	      "this.shape=[" + shapeArg + "]",
	      "this.stride=[" + strideArg + "]",
	      "this.offset=d|0}",
	    "var proto="+className+".prototype",
	    "proto.dtype='"+dtype+"'",
	    "proto.dimension="+dimension)

	  //view.size:
	  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
	return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
	"}})")

	  //view.order:
	  if(dimension === 1) {
	    code.push("proto.order=[0]")
	  } else {
	    code.push("Object.defineProperty(proto,'order',{get:")
	    if(dimension < 4) {
	      code.push("function "+className+"_order(){")
	      if(dimension === 2) {
	        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
	      } else if(dimension === 3) {
	        code.push(
	"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
	if(s0>s1){\
	if(s1>s2){\
	return [2,1,0];\
	}else if(s0>s2){\
	return [1,2,0];\
	}else{\
	return [1,0,2];\
	}\
	}else if(s0>s2){\
	return [2,0,1];\
	}else if(s2>s1){\
	return [0,1,2];\
	}else{\
	return [0,2,1];\
	}}})")
	      }
	    } else {
	      code.push("ORDER})")
	    }
	  }

	  //view.set(i0, ..., v):
	  code.push(
	"proto.set=function "+className+"_set("+args.join(",")+",v){")
	  if(useGetters) {
	    code.push("return this.data.set("+index_str+",v)}")
	  } else {
	    code.push("return this.data["+index_str+"]=v}")
	  }

	  //view.get(i0, ...):
	  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
	  if(useGetters) {
	    code.push("return this.data.get("+index_str+")}")
	  } else {
	    code.push("return this.data["+index_str+"]}")
	  }

	  //view.index:
	  code.push(
	    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

	  //view.hi():
	  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
	    indices.map(function(i) {
	      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
	    }).join(",")+","+
	    indices.map(function(i) {
	      return "this.stride["+i + "]"
	    }).join(",")+",this.offset)}")

	  //view.lo():
	  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
	  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
	  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
	  for(var i=0; i<dimension; ++i) {
	    code.push(
	"if(typeof i"+i+"==='number'&&i"+i+">=0){\
	d=i"+i+"|0;\
	b+=c"+i+"*d;\
	a"+i+"-=d}")
	  }
	  code.push("return new "+className+"(this.data,"+
	    indices.map(function(i) {
	      return "a"+i
	    }).join(",")+","+
	    indices.map(function(i) {
	      return "c"+i
	    }).join(",")+",b)}")

	  //view.step():
	  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
	    indices.map(function(i) {
	      return "a"+i+"=this.shape["+i+"]"
	    }).join(",")+","+
	    indices.map(function(i) {
	      return "b"+i+"=this.stride["+i+"]"
	    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
	  for(var i=0; i<dimension; ++i) {
	    code.push(
	"if(typeof i"+i+"==='number'){\
	d=i"+i+"|0;\
	if(d<0){\
	c+=b"+i+"*(a"+i+"-1);\
	a"+i+"=ceil(-a"+i+"/d)\
	}else{\
	a"+i+"=ceil(a"+i+"/d)\
	}\
	b"+i+"*=d\
	}")
	  }
	  code.push("return new "+className+"(this.data,"+
	    indices.map(function(i) {
	      return "a" + i
	    }).join(",")+","+
	    indices.map(function(i) {
	      return "b" + i
	    }).join(",")+",c)}")

	  //view.transpose():
	  var tShape = new Array(dimension)
	  var tStride = new Array(dimension)
	  for(var i=0; i<dimension; ++i) {
	    tShape[i] = "a[i"+i+"]"
	    tStride[i] = "b[i"+i+"]"
	  }
	  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
	    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
	    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")

	  //view.pick():
	  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
	  for(var i=0; i<dimension; ++i) {
	    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
	  }
	  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

	  //Add return statement
	  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
	    indices.map(function(i) {
	      return "shape["+i+"]"
	    }).join(",")+","+
	    indices.map(function(i) {
	      return "stride["+i+"]"
	    }).join(",")+",offset)}")

	  //Compile procedure
	  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
	  return procedure(CACHED_CONSTRUCTORS[dtype], order)
	}

	function arrayDType(data) {
	  if(isBuffer(data)) {
	    return "buffer"
	  }
	  if(hasTypedArrays) {
	    switch(Object.prototype.toString.call(data)) {
	      case "[object Float64Array]":
	        return "float64"
	      case "[object Float32Array]":
	        return "float32"
	      case "[object Int8Array]":
	        return "int8"
	      case "[object Int16Array]":
	        return "int16"
	      case "[object Int32Array]":
	        return "int32"
	      case "[object Uint8Array]":
	        return "uint8"
	      case "[object Uint16Array]":
	        return "uint16"
	      case "[object Uint32Array]":
	        return "uint32"
	      case "[object Uint8ClampedArray]":
	        return "uint8_clamped"
	    }
	  }
	  if(Array.isArray(data)) {
	    return "array"
	  }
	  return "generic"
	}

	var CACHED_CONSTRUCTORS = {
	  "float32":[],
	  "float64":[],
	  "int8":[],
	  "int16":[],
	  "int32":[],
	  "uint8":[],
	  "uint16":[],
	  "uint32":[],
	  "array":[],
	  "uint8_clamped":[],
	  "buffer":[],
	  "generic":[]
	}

	;(function() {
	  for(var id in CACHED_CONSTRUCTORS) {
	    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
	  }
	});

	function wrappedNDArrayCtor(data, shape, stride, offset) {
	  if(data === undefined) {
	    var ctor = CACHED_CONSTRUCTORS.array[0]
	    return ctor([])
	  } else if(typeof data === "number") {
	    data = [data]
	  }
	  if(shape === undefined) {
	    shape = [ data.length ]
	  }
	  var d = shape.length
	  if(stride === undefined) {
	    stride = new Array(d)
	    for(var i=d-1, sz=1; i>=0; --i) {
	      stride[i] = sz
	      sz *= shape[i]
	    }
	  }
	  if(offset === undefined) {
	    offset = 0
	    for(var i=0; i<d; ++i) {
	      if(stride[i] < 0) {
	        offset -= (shape[i]-1)*stride[i]
	      }
	    }
	  }
	  var dtype = arrayDType(data)
	  var ctor_list = CACHED_CONSTRUCTORS[dtype]
	  while(ctor_list.length <= d+1) {
	    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
	  }
	  var ctor = ctor_list[d+1]
	  return ctor(data, shape, stride, offset)
	}

	module.exports = wrappedNDArrayCtor


/***/ },
/* 232 */
/*!****************************************!*\
  !*** ./~/ndarray/~/iota-array/iota.js ***!
  \****************************************/
/***/ function(module, exports) {

	"use strict"

	function iota(n) {
	  var result = new Array(n)
	  for(var i=0; i<n; ++i) {
	    result[i] = i
	  }
	  return result
	}

	module.exports = iota

/***/ },
/* 233 */
/*!****************************************!*\
  !*** ./~/ndarray/~/is-buffer/index.js ***!
  \****************************************/
/***/ function(module, exports) {

	/**
	 * Determine if an object is Buffer
	 *
	 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * License:  MIT
	 *
	 * `npm install is-buffer`
	 */

	module.exports = function (obj) {
	  return !!(obj != null &&
	    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
	      (obj.constructor &&
	      typeof obj.constructor.isBuffer === 'function' &&
	      obj.constructor.isBuffer(obj))
	    ))
	}


/***/ },
/* 234 */
/*!*********************************!*\
  !*** ./~/ndarray-fill/index.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict"

	var cwise = __webpack_require__(/*! cwise */ 235)

	var fill = cwise({
	  args: ["index", "array", "scalar"],
	  body: function(idx, out, f) {
	    out = f.apply(undefined, idx)
	  }
	})

	module.exports = function(array, f) {
	  fill(array, f)
	  return array
	}


/***/ },
/* 235 */
/*!*****************************************************!*\
  !*** ./~/ndarray-fill/~/cwise/lib/cwise-esprima.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict"

	var parse   = __webpack_require__(/*! cwise-parser */ 236)
	var compile = __webpack_require__(/*! cwise-compiler */ 239)

	var REQUIRED_FIELDS = [ "args", "body" ]
	var OPTIONAL_FIELDS = [ "pre", "post", "printCode", "funcName", "blockSize" ]

	function createCWise(user_args) {
	  //Check parameters
	  for(var id in user_args) {
	    if(REQUIRED_FIELDS.indexOf(id) < 0 &&
	       OPTIONAL_FIELDS.indexOf(id) < 0) {
	      console.warn("cwise: Unknown argument '"+id+"' passed to expression compiler")
	    }
	  }
	  for(var i=0; i<REQUIRED_FIELDS.length; ++i) {
	    if(!user_args[REQUIRED_FIELDS[i]]) {
	      throw new Error("cwise: Missing argument: " + REQUIRED_FIELDS[i])
	    }
	  }
	  
	  //Parse blocks
	  return compile({
	    args:       user_args.args,
	    pre:        parse(user_args.pre || function(){}),
	    body:       parse(user_args.body),
	    post:       parse(user_args.post || function(){}),
	    debug:      !!user_args.printCode,
	    funcName:   user_args.funcName || user_args.body.name || "cwise",
	    blockSize:  user_args.blockSize || 64
	  })
	}

	module.exports = createCWise


/***/ },
/* 236 */
/*!********************************************************!*\
  !*** ./~/ndarray-fill/~/cwise/~/cwise-parser/index.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict"

	var esprima = __webpack_require__(/*! esprima */ 237)
	var uniq = __webpack_require__(/*! uniq */ 238)

	var PREFIX_COUNTER = 0

	function CompiledArgument(name, lvalue, rvalue) {
	  this.name = name
	  this.lvalue = lvalue
	  this.rvalue = rvalue
	  this.count = 0
	}

	function CompiledRoutine(body, args, thisVars, localVars) {
	  this.body = body
	  this.args = args
	  this.thisVars = thisVars
	  this.localVars = localVars
	}

	function isGlobal(identifier) {
	  if(identifier === "eval") {
	    throw new Error("cwise-parser: eval() not allowed")
	  }
	  if(typeof window !== "undefined") {
	    return identifier in window
	  } else if(typeof GLOBAL !== "undefined") {
	    return identifier in GLOBAL
	  } else if(typeof self !== "undefined") {
	    return identifier in self
	  } else {
	    return false
	  }
	}

	function getArgNames(ast) {
	  var params = ast.body[0].expression.callee.params
	  var names = new Array(params.length)
	  for(var i=0; i<params.length; ++i) {
	    names[i] = params[i].name
	  }
	  return names
	}

	function preprocess(func) {
	  var src = ["(", func, ")()"].join("")
	  var ast = esprima.parse(src, { range: true })
	  
	  //Compute new prefix
	  var prefix = "_inline_" + (PREFIX_COUNTER++) + "_"
	  
	  //Parse out arguments
	  var argNames = getArgNames(ast)
	  var compiledArgs = new Array(argNames.length)
	  for(var i=0; i<argNames.length; ++i) {
	    compiledArgs[i] = new CompiledArgument([prefix, "arg", i, "_"].join(""), false, false)
	  }
	  
	  //Create temporary data structure for source rewriting
	  var exploded = new Array(src.length)
	  for(var i=0, n=src.length; i<n; ++i) {
	    exploded[i] = src.charAt(i)
	  }
	  
	  //Local variables
	  var localVars = []
	  var thisVars = []
	  var computedThis = false
	  
	  //Retrieves a local variable
	  function createLocal(id) {
	    var nstr = prefix + id.replace(/\_/g, "__")
	    localVars.push(nstr)
	    return nstr
	  }
	  
	  //Creates a this variable
	  function createThisVar(id) {
	    var nstr = "this_" + id.replace(/\_/g, "__")
	    thisVars.push(nstr)
	    return nstr
	  }
	  
	  //Rewrites an ast node
	  function rewrite(node, nstr) {
	    var lo = node.range[0], hi = node.range[1]
	    for(var i=lo+1; i<hi; ++i) {
	      exploded[i] = ""
	    }
	    exploded[lo] = nstr
	  }
	  
	  //Remove any underscores
	  function escapeString(str) {
	    return "'"+(str.replace(/\_/g, "\\_").replace(/\'/g, "\'"))+"'"
	  }
	  
	  //Returns the source of an identifier
	  function source(node) {
	    return exploded.slice(node.range[0], node.range[1]).join("")
	  }
	  
	  //Computes the usage of a node
	  var LVALUE = 1
	  var RVALUE = 2
	  function getUsage(node) {
	    if(node.parent.type === "AssignmentExpression") {
	      if(node.parent.left === node) {
	        if(node.parent.operator === "=") {
	          return LVALUE
	        }
	        return LVALUE|RVALUE
	      }
	    }
	    if(node.parent.type === "UpdateExpression") {
	      return LVALUE|RVALUE
	    }
	    return RVALUE
	  }
	  
	  //Handle visiting a node
	  (function visit(node, parent) {
	    node.parent = parent
	    if(node.type === "MemberExpression") {
	      //Handle member expression
	      if(node.computed) {
	        visit(node.object, node)
	        visit(node.property, node)
	      } else if(node.object.type === "ThisExpression") {
	        rewrite(node, createThisVar(node.property.name))
	      } else {
	        visit(node.object, node)
	      }
	    } else if(node.type === "ThisExpression") {
	      throw new Error("cwise-parser: Computed this is not allowed")
	    } else if(node.type === "Identifier") {
	      //Handle identifier
	      var name = node.name
	      var argNo = argNames.indexOf(name)
	      if(argNo >= 0) {
	        var carg = compiledArgs[argNo]
	        var usage = getUsage(node)
	        if(usage & LVALUE) {
	          carg.lvalue = true
	        }
	        if(usage & RVALUE) {
	          carg.rvalue = true
	        }
	        ++carg.count
	        rewrite(node, carg.name)
	      } else if(isGlobal(name)) {
	        //Don't rewrite globals
	      } else {
	        rewrite(node, createLocal(name))
	      }
	    } else if(node.type === "Literal") {
	      if(typeof node.value === "string") {
	        rewrite(node, escapeString(node.value))
	      }
	    } else if(node.type === "WithStatement") {
	      throw new Error("cwise-parser: with() statements not allowed")
	    } else {
	      //Visit all children
	      var keys = Object.keys(node)
	      for(var i=0, n=keys.length; i<n; ++i) {
	        if(keys[i] === "parent") {
	          continue
	        }
	        var value = node[keys[i]]
	        if(value) {
	          if(value instanceof Array) {
	            for(var j=0; j<value.length; ++j) {
	              if(value[j] && typeof value[j].type === "string") {
	                visit(value[j], node)
	              }
	            }
	          } else if(typeof value.type === "string") {
	            visit(value, node)
	          }
	        }
	      }
	    }
	  })(ast.body[0].expression.callee.body, undefined)
	  
	  //Remove duplicate variables
	  uniq(localVars)
	  uniq(thisVars)
	  
	  //Return body
	  var routine = new CompiledRoutine(source(ast.body[0].expression.callee.body), compiledArgs, thisVars, localVars)
	  return routine
	}

	module.exports = preprocess

/***/ },
/* 237 */
/*!********************************************************************!*\
  !*** ./~/ndarray-fill/~/cwise/~/cwise-parser/~/esprima/esprima.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
	  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
	  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
	  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
	  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
	  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
	  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
	  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	/*jslint bitwise:true plusplus:true */
	/*global esprima:true, define:true, exports:true, window: true,
	throwErrorTolerant: true,
	throwError: true, generateStatement: true, peek: true,
	parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
	parseFunctionDeclaration: true, parseFunctionExpression: true,
	parseFunctionSourceElements: true, parseVariableIdentifier: true,
	parseLeftHandSideExpression: true,
	parseUnaryExpression: true,
	parseStatement: true, parseSourceElement: true */

	(function (root, factory) {
	    'use strict';

	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	    // Rhino, and plain browser loading.

	    /* istanbul ignore next */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== 'undefined') {
	        factory(exports);
	    } else {
	        factory((root.esprima = {}));
	    }
	}(this, function (exports) {
	    'use strict';

	    var Token,
	        TokenName,
	        FnExprTokens,
	        Syntax,
	        PropertyKind,
	        Messages,
	        Regex,
	        SyntaxTreeDelegate,
	        source,
	        strict,
	        index,
	        lineNumber,
	        lineStart,
	        length,
	        delegate,
	        lookahead,
	        state,
	        extra;

	    Token = {
	        BooleanLiteral: 1,
	        EOF: 2,
	        Identifier: 3,
	        Keyword: 4,
	        NullLiteral: 5,
	        NumericLiteral: 6,
	        Punctuator: 7,
	        StringLiteral: 8,
	        RegularExpression: 9
	    };

	    TokenName = {};
	    TokenName[Token.BooleanLiteral] = 'Boolean';
	    TokenName[Token.EOF] = '<end>';
	    TokenName[Token.Identifier] = 'Identifier';
	    TokenName[Token.Keyword] = 'Keyword';
	    TokenName[Token.NullLiteral] = 'Null';
	    TokenName[Token.NumericLiteral] = 'Numeric';
	    TokenName[Token.Punctuator] = 'Punctuator';
	    TokenName[Token.StringLiteral] = 'String';
	    TokenName[Token.RegularExpression] = 'RegularExpression';

	    // A function following one of those tokens is an expression.
	    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	                    'return', 'case', 'delete', 'throw', 'void',
	                    // assignment operators
	                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
	                    '&=', '|=', '^=', ',',
	                    // binary/unary operators
	                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	                    '<=', '<', '>', '!=', '!=='];

	    Syntax = {
	        AssignmentExpression: 'AssignmentExpression',
	        ArrayExpression: 'ArrayExpression',
	        BlockStatement: 'BlockStatement',
	        BinaryExpression: 'BinaryExpression',
	        BreakStatement: 'BreakStatement',
	        CallExpression: 'CallExpression',
	        CatchClause: 'CatchClause',
	        ConditionalExpression: 'ConditionalExpression',
	        ContinueStatement: 'ContinueStatement',
	        DoWhileStatement: 'DoWhileStatement',
	        DebuggerStatement: 'DebuggerStatement',
	        EmptyStatement: 'EmptyStatement',
	        ExpressionStatement: 'ExpressionStatement',
	        ForStatement: 'ForStatement',
	        ForInStatement: 'ForInStatement',
	        FunctionDeclaration: 'FunctionDeclaration',
	        FunctionExpression: 'FunctionExpression',
	        Identifier: 'Identifier',
	        IfStatement: 'IfStatement',
	        Literal: 'Literal',
	        LabeledStatement: 'LabeledStatement',
	        LogicalExpression: 'LogicalExpression',
	        MemberExpression: 'MemberExpression',
	        NewExpression: 'NewExpression',
	        ObjectExpression: 'ObjectExpression',
	        Program: 'Program',
	        Property: 'Property',
	        ReturnStatement: 'ReturnStatement',
	        SequenceExpression: 'SequenceExpression',
	        SwitchStatement: 'SwitchStatement',
	        SwitchCase: 'SwitchCase',
	        ThisExpression: 'ThisExpression',
	        ThrowStatement: 'ThrowStatement',
	        TryStatement: 'TryStatement',
	        UnaryExpression: 'UnaryExpression',
	        UpdateExpression: 'UpdateExpression',
	        VariableDeclaration: 'VariableDeclaration',
	        VariableDeclarator: 'VariableDeclarator',
	        WhileStatement: 'WhileStatement',
	        WithStatement: 'WithStatement'
	    };

	    PropertyKind = {
	        Data: 1,
	        Get: 2,
	        Set: 4
	    };

	    // Error messages should be identical to V8.
	    Messages = {
	        UnexpectedToken:  'Unexpected token %0',
	        UnexpectedNumber:  'Unexpected number',
	        UnexpectedString:  'Unexpected string',
	        UnexpectedIdentifier:  'Unexpected identifier',
	        UnexpectedReserved:  'Unexpected reserved word',
	        UnexpectedEOS:  'Unexpected end of input',
	        NewlineAfterThrow:  'Illegal newline after throw',
	        InvalidRegExp: 'Invalid regular expression',
	        UnterminatedRegExp:  'Invalid regular expression: missing /',
	        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
	        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
	        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	        NoCatchOrFinally:  'Missing catch or finally after try',
	        UnknownLabel: 'Undefined label \'%0\'',
	        Redeclaration: '%0 \'%1\' has already been declared',
	        IllegalContinue: 'Illegal continue statement',
	        IllegalBreak: 'Illegal break statement',
	        IllegalReturn: 'Illegal return statement',
	        StrictModeWith:  'Strict mode code may not include a with statement',
	        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
	        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
	        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
	        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
	        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
	        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
	        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
	        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
	        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
	        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
	        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictReservedWord:  'Use of future reserved word in strict mode'
	    };

	    // See also tools/generate-unicode-regex.py.
	    Regex = {
	        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
	        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
	    };

	    // Ensure the condition is true, otherwise throw an error.
	    // This is only to have a better contract semantic, i.e. another safety net
	    // to catch a logic error. The condition shall be fulfilled in normal case.
	    // Do NOT use this to enforce a certain condition on any user input.

	    function assert(condition, message) {
	        /* istanbul ignore if */
	        if (!condition) {
	            throw new Error('ASSERT: ' + message);
	        }
	    }

	    function isDecimalDigit(ch) {
	        return (ch >= 48 && ch <= 57);   // 0..9
	    }

	    function isHexDigit(ch) {
	        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
	    }

	    function isOctalDigit(ch) {
	        return '01234567'.indexOf(ch) >= 0;
	    }


	    // 7.2 White Space

	    function isWhiteSpace(ch) {
	        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
	            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
	    }

	    // 7.3 Line Terminators

	    function isLineTerminator(ch) {
	        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
	    }

	    // 7.6 Identifier Names and Identifiers

	    function isIdentifierStart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
	    }

	    function isIdentifierPart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
	    }

	    // 7.6.1.2 Future Reserved Words

	    function isFutureReservedWord(id) {
	        switch (id) {
	        case 'class':
	        case 'enum':
	        case 'export':
	        case 'extends':
	        case 'import':
	        case 'super':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isStrictModeReservedWord(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'yield':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }

	    // 7.6.1.1 Keywords

	    function isKeyword(id) {
	        if (strict && isStrictModeReservedWord(id)) {
	            return true;
	        }

	        // 'const' is specialized as Keyword in V8.
	        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
	        // Some others are from future reserved words.

	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') ||
	                (id === 'try') || (id === 'let');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }

	    // 7.4 Comments

	    function addComment(type, value, start, end, loc) {
	        var comment, attacher;

	        assert(typeof start === 'number', 'Comment must have valid position');

	        // Because the way the actual token is scanned, often the comments
	        // (if any) are skipped twice during the lexical analysis.
	        // Thus, we need to skip adding a comment if the comment array already
	        // handled it.
	        if (state.lastCommentStart >= start) {
	            return;
	        }
	        state.lastCommentStart = start;

	        comment = {
	            type: type,
	            value: value
	        };
	        if (extra.range) {
	            comment.range = [start, end];
	        }
	        if (extra.loc) {
	            comment.loc = loc;
	        }
	        extra.comments.push(comment);
	        if (extra.attachComment) {
	            extra.leadingComments.push(comment);
	            extra.trailingComments.push(comment);
	        }
	    }

	    function skipSingleLineComment(offset) {
	        var start, loc, ch, comment;

	        start = index - offset;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart - offset
	            }
	        };

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            ++index;
	            if (isLineTerminator(ch)) {
	                if (extra.comments) {
	                    comment = source.slice(start + offset, index - 1);
	                    loc.end = {
	                        line: lineNumber,
	                        column: index - lineStart - 1
	                    };
	                    addComment('Line', comment, start, index - 1, loc);
	                }
	                if (ch === 13 && source.charCodeAt(index) === 10) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                return;
	            }
	        }

	        if (extra.comments) {
	            comment = source.slice(start + offset, index);
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            addComment('Line', comment, start, index, loc);
	        }
	    }

	    function skipMultiLineComment() {
	        var start, loc, ch, comment;

	        if (extra.comments) {
	            start = index - 2;
	            loc = {
	                start: {
	                    line: lineNumber,
	                    column: index - lineStart - 2
	                }
	            };
	        }

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (isLineTerminator(ch)) {
	                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
	                    ++index;
	                }
	                ++lineNumber;
	                ++index;
	                lineStart = index;
	                if (index >= length) {
	                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	            } else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (source.charCodeAt(index + 1) === 0x2F) {
	                    ++index;
	                    ++index;
	                    if (extra.comments) {
	                        comment = source.slice(start + 2, index - 2);
	                        loc.end = {
	                            line: lineNumber,
	                            column: index - lineStart
	                        };
	                        addComment('Block', comment, start, index, loc);
	                    }
	                    return;
	                }
	                ++index;
	            } else {
	                ++index;
	            }
	        }

	        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	    }

	    function skipComment() {
	        var ch, start;

	        start = (index === 0);
	        while (index < length) {
	            ch = source.charCodeAt(index);

	            if (isWhiteSpace(ch)) {
	                ++index;
	            } else if (isLineTerminator(ch)) {
	                ++index;
	                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                start = true;
	            } else if (ch === 0x2F) { // U+002F is '/'
	                ch = source.charCodeAt(index + 1);
	                if (ch === 0x2F) {
	                    ++index;
	                    ++index;
	                    skipSingleLineComment(2);
	                    start = true;
	                } else if (ch === 0x2A) {  // U+002A is '*'
	                    ++index;
	                    ++index;
	                    skipMultiLineComment();
	                } else {
	                    break;
	                }
	            } else if (start && ch === 0x2D) { // U+002D is '-'
	                // U+003E is '>'
	                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    index += 3;
	                    skipSingleLineComment(3);
	                } else {
	                    break;
	                }
	            } else if (ch === 0x3C) { // U+003C is '<'
	                if (source.slice(index + 1, index + 4) === '!--') {
	                    ++index; // `<`
	                    ++index; // `!`
	                    ++index; // `-`
	                    ++index; // `-`
	                    skipSingleLineComment(4);
	                } else {
	                    break;
	                }
	            } else {
	                break;
	            }
	        }
	    }

	    function scanHexEscape(prefix) {
	        var i, len, ch, code = 0;

	        len = (prefix === 'u') ? 4 : 2;
	        for (i = 0; i < len; ++i) {
	            if (index < length && isHexDigit(source[index])) {
	                ch = source[index++];
	                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	            } else {
	                return '';
	            }
	        }
	        return String.fromCharCode(code);
	    }

	    function getEscapedIdentifier() {
	        var ch, id;

	        ch = source.charCodeAt(index++);
	        id = String.fromCharCode(ch);

	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        if (ch === 0x5C) {
	            if (source.charCodeAt(index) !== 0x75) {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	            ++index;
	            ch = scanHexEscape('u');
	            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	            id = ch;
	        }

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (!isIdentifierPart(ch)) {
	                break;
	            }
	            ++index;
	            id += String.fromCharCode(ch);

	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (ch === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (source.charCodeAt(index) !== 0x75) {
	                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	                ++index;
	                ch = scanHexEscape('u');
	                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
	                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	                id += ch;
	            }
	        }

	        return id;
	    }

	    function getIdentifier() {
	        var start, ch;

	        start = index++;
	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                index = start;
	                return getEscapedIdentifier();
	            }
	            if (isIdentifierPart(ch)) {
	                ++index;
	            } else {
	                break;
	            }
	        }

	        return source.slice(start, index);
	    }

	    function scanIdentifier() {
	        var start, id, type;

	        start = index;

	        // Backslash (U+005C) starts an escaped character.
	        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = Token.Identifier;
	        } else if (isKeyword(id)) {
	            type = Token.Keyword;
	        } else if (id === 'null') {
	            type = Token.NullLiteral;
	        } else if (id === 'true' || id === 'false') {
	            type = Token.BooleanLiteral;
	        } else {
	            type = Token.Identifier;
	        }

	        return {
	            type: type,
	            value: id,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }


	    // 7.7 Punctuators

	    function scanPunctuator() {
	        var start = index,
	            code = source.charCodeAt(index),
	            code2,
	            ch1 = source[index],
	            ch2,
	            ch3,
	            ch4;

	        switch (code) {

	        // Check for most common single-character punctuators.
	        case 0x2E:  // . dot
	        case 0x28:  // ( open bracket
	        case 0x29:  // ) close bracket
	        case 0x3B:  // ; semicolon
	        case 0x2C:  // , comma
	        case 0x7B:  // { open curly brace
	        case 0x7D:  // } close curly brace
	        case 0x5B:  // [
	        case 0x5D:  // ]
	        case 0x3A:  // :
	        case 0x3F:  // ?
	        case 0x7E:  // ~
	            ++index;
	            if (extra.tokenize) {
	                if (code === 0x28) {
	                    extra.openParenToken = extra.tokens.length;
	                } else if (code === 0x7B) {
	                    extra.openCurlyToken = extra.tokens.length;
	                }
	            }
	            return {
	                type: Token.Punctuator,
	                value: String.fromCharCode(code),
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };

	        default:
	            code2 = source.charCodeAt(index + 1);

	            // '=' (U+003D) marks an assignment or comparison operator.
	            if (code2 === 0x3D) {
	                switch (code) {
	                case 0x2B:  // +
	                case 0x2D:  // -
	                case 0x2F:  // /
	                case 0x3C:  // <
	                case 0x3E:  // >
	                case 0x5E:  // ^
	                case 0x7C:  // |
	                case 0x25:  // %
	                case 0x26:  // &
	                case 0x2A:  // *
	                    index += 2;
	                    return {
	                        type: Token.Punctuator,
	                        value: String.fromCharCode(code) + String.fromCharCode(code2),
	                        lineNumber: lineNumber,
	                        lineStart: lineStart,
	                        start: start,
	                        end: index
	                    };

	                case 0x21: // !
	                case 0x3D: // =
	                    index += 2;

	                    // !== and ===
	                    if (source.charCodeAt(index) === 0x3D) {
	                        ++index;
	                    }
	                    return {
	                        type: Token.Punctuator,
	                        value: source.slice(start, index),
	                        lineNumber: lineNumber,
	                        lineStart: lineStart,
	                        start: start,
	                        end: index
	                    };
	                }
	            }
	        }

	        // 4-character punctuator: >>>=

	        ch4 = source.substr(index, 4);

	        if (ch4 === '>>>=') {
	            index += 4;
	            return {
	                type: Token.Punctuator,
	                value: ch4,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        // 3-character punctuators: === !== >>> <<= >>=

	        ch3 = ch4.substr(0, 3);

	        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
	            index += 3;
	            return {
	                type: Token.Punctuator,
	                value: ch3,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        // Other 2-character punctuators: ++ -- << >> && ||
	        ch2 = ch3.substr(0, 2);

	        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
	            index += 2;
	            return {
	                type: Token.Punctuator,
	                value: ch2,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        // 1-character punctuators: < > = ! + - * % & | ^ /
	        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
	            ++index;
	            return {
	                type: Token.Punctuator,
	                value: ch1,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	    }

	    // 7.8.3 Numeric Literals

	    function scanHexLiteral(start) {
	        var number = '';

	        while (index < length) {
	            if (!isHexDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }

	        if (number.length === 0) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt('0x' + number, 16),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function scanOctalLiteral(start) {
	        var number = '0' + source[index++];
	        while (index < length) {
	            if (!isOctalDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }

	        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 8),
	            octal: true,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function isImplicitOctalLiteral() {
	        var i, ch;

	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (i = index + 1; i < length; ++i) {
	            ch = source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!isOctalDigit(ch)) {
	                return true;
	            }
	        }

	        return true;
	    }

	    function scanNumericLiteral() {
	        var number, start, ch;

	        ch = source[index];
	        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
	            'Numeric literal must start with a decimal digit or a decimal point');

	        start = index;
	        number = '';
	        if (ch !== '.') {
	            number = source[index++];
	            ch = source[index];

	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            if (number === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++index;
	                    return scanHexLiteral(start);
	                }
	                if (isOctalDigit(ch)) {
	                    if (isImplicitOctalLiteral()) {
	                        return scanOctalLiteral(start);
	                    }
	                }
	            }

	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }

	        if (ch === '.') {
	            number += source[index++];
	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }

	        if (ch === 'e' || ch === 'E') {
	            number += source[index++];

	            ch = source[index];
	            if (ch === '+' || ch === '-') {
	                number += source[index++];
	            }
	            if (isDecimalDigit(source.charCodeAt(index))) {
	                while (isDecimalDigit(source.charCodeAt(index))) {
	                    number += source[index++];
	                }
	            } else {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	        }

	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseFloat(number),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    // 7.8.4 String Literals

	    function scanStringLiteral() {
	        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;

	        quote = source[index];
	        assert((quote === '\'' || quote === '"'),
	            'String literal must starts with a quote');

	        start = index;
	        ++index;

	        while (index < length) {
	            ch = source[index++];

	            if (ch === quote) {
	                quote = '';
	                break;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'u':
	                    case 'x':
	                        restore = index;
	                        unescaped = scanHexEscape(ch);
	                        if (unescaped) {
	                            str += unescaped;
	                        } else {
	                            index = restore;
	                            str += ch;
	                        }
	                        break;
	                    case 'n':
	                        str += '\n';
	                        break;
	                    case 'r':
	                        str += '\r';
	                        break;
	                    case 't':
	                        str += '\t';
	                        break;
	                    case 'b':
	                        str += '\b';
	                        break;
	                    case 'f':
	                        str += '\f';
	                        break;
	                    case 'v':
	                        str += '\x0B';
	                        break;

	                    default:
	                        if (isOctalDigit(ch)) {
	                            code = '01234567'.indexOf(ch);

	                            // \0 is not octal escape sequence
	                            if (code !== 0) {
	                                octal = true;
	                            }

	                            if (index < length && isOctalDigit(source[index])) {
	                                octal = true;
	                                code = code * 8 + '01234567'.indexOf(source[index++]);

	                                // 3 digits are only allowed when string starts
	                                // with 0, 1, 2, 3
	                                if ('0123'.indexOf(ch) >= 0 &&
	                                        index < length &&
	                                        isOctalDigit(source[index])) {
	                                    code = code * 8 + '01234567'.indexOf(source[index++]);
	                                }
	                            }
	                            str += String.fromCharCode(code);
	                        } else {
	                            str += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch ===  '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            } else {
	                str += ch;
	            }
	        }

	        if (quote !== '') {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        return {
	            type: Token.StringLiteral,
	            value: str,
	            octal: octal,
	            startLineNumber: startLineNumber,
	            startLineStart: startLineStart,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function testRegExp(pattern, flags) {
	        var value;
	        try {
	            value = new RegExp(pattern, flags);
	        } catch (e) {
	            throwError({}, Messages.InvalidRegExp);
	        }
	        return value;
	    }

	    function scanRegExpBody() {
	        var ch, str, classMarker, terminated, body;

	        ch = source[index];
	        assert(ch === '/', 'Regular expression literal must start with a slash');
	        str = source[index++];

	        classMarker = false;
	        terminated = false;
	        while (index < length) {
	            ch = source[index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = source[index++];
	                // ECMA-262 7.8.5
	                if (isLineTerminator(ch.charCodeAt(0))) {
	                    throwError({}, Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                throwError({}, Messages.UnterminatedRegExp);
	            } else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            } else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                } else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }

	        if (!terminated) {
	            throwError({}, Messages.UnterminatedRegExp);
	        }

	        // Exclude leading and trailing slash.
	        body = str.substr(1, str.length - 2);
	        return {
	            value: body,
	            literal: str
	        };
	    }

	    function scanRegExpFlags() {
	        var ch, str, flags, restore;

	        str = '';
	        flags = '';
	        while (index < length) {
	            ch = source[index];
	            if (!isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }

	            ++index;
	            if (ch === '\\' && index < length) {
	                ch = source[index];
	                if (ch === 'u') {
	                    ++index;
	                    restore = index;
	                    ch = scanHexEscape('u');
	                    if (ch) {
	                        flags += ch;
	                        for (str += '\\u'; restore < index; ++restore) {
	                            str += source[restore];
	                        }
	                    } else {
	                        index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
	                } else {
	                    str += '\\';
	                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	            } else {
	                flags += ch;
	                str += ch;
	            }
	        }

	        return {
	            value: flags,
	            literal: str
	        };
	    }

	    function scanRegExp() {
	        var start, body, flags, pattern, value;

	        lookahead = null;
	        skipComment();
	        start = index;

	        body = scanRegExpBody();
	        flags = scanRegExpFlags();
	        value = testRegExp(body.value, flags.value);

	        if (extra.tokenize) {
	            return {
	                type: Token.RegularExpression,
	                value: value,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        return {
	            literal: body.literal + flags.literal,
	            value: value,
	            start: start,
	            end: index
	        };
	    }

	    function collectRegex() {
	        var pos, loc, regex, token;

	        skipComment();

	        pos = index;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };

	        regex = scanRegExp();
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };

	        /* istanbul ignore next */
	        if (!extra.tokenize) {
	            // Pop the previous token, which is likely '/' or '/='
	            if (extra.tokens.length > 0) {
	                token = extra.tokens[extra.tokens.length - 1];
	                if (token.range[0] === pos && token.type === 'Punctuator') {
	                    if (token.value === '/' || token.value === '/=') {
	                        extra.tokens.pop();
	                    }
	                }
	            }

	            extra.tokens.push({
	                type: 'RegularExpression',
	                value: regex.literal,
	                range: [pos, index],
	                loc: loc
	            });
	        }

	        return regex;
	    }

	    function isIdentifierName(token) {
	        return token.type === Token.Identifier ||
	            token.type === Token.Keyword ||
	            token.type === Token.BooleanLiteral ||
	            token.type === Token.NullLiteral;
	    }

	    function advanceSlash() {
	        var prevToken,
	            checkToken;
	        // Using the following algorithm:
	        // https://github.com/mozilla/sweet.js/wiki/design
	        prevToken = extra.tokens[extra.tokens.length - 1];
	        if (!prevToken) {
	            // Nothing before that: it cannot be a division.
	            return collectRegex();
	        }
	        if (prevToken.type === 'Punctuator') {
	            if (prevToken.value === ']') {
	                return scanPunctuator();
	            }
	            if (prevToken.value === ')') {
	                checkToken = extra.tokens[extra.openParenToken - 1];
	                if (checkToken &&
	                        checkToken.type === 'Keyword' &&
	                        (checkToken.value === 'if' ||
	                         checkToken.value === 'while' ||
	                         checkToken.value === 'for' ||
	                         checkToken.value === 'with')) {
	                    return collectRegex();
	                }
	                return scanPunctuator();
	            }
	            if (prevToken.value === '}') {
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                if (extra.tokens[extra.openCurlyToken - 3] &&
	                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
	                    // Anonymous function.
	                    checkToken = extra.tokens[extra.openCurlyToken - 4];
	                    if (!checkToken) {
	                        return scanPunctuator();
	                    }
	                } else if (extra.tokens[extra.openCurlyToken - 4] &&
	                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
	                    // Named function.
	                    checkToken = extra.tokens[extra.openCurlyToken - 5];
	                    if (!checkToken) {
	                        return collectRegex();
	                    }
	                } else {
	                    return scanPunctuator();
	                }
	                // checkToken determines whether the function is
	                // a declaration or an expression.
	                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
	                    // It is an expression.
	                    return scanPunctuator();
	                }
	                // It is a declaration.
	                return collectRegex();
	            }
	            return collectRegex();
	        }
	        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
	            return collectRegex();
	        }
	        return scanPunctuator();
	    }

	    function advance() {
	        var ch;

	        skipComment();

	        if (index >= length) {
	            return {
	                type: Token.EOF,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: index,
	                end: index
	            };
	        }

	        ch = source.charCodeAt(index);

	        if (isIdentifierStart(ch)) {
	            return scanIdentifier();
	        }

	        // Very common: ( and ) and ;
	        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
	            return scanPunctuator();
	        }

	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (ch === 0x27 || ch === 0x22) {
	            return scanStringLiteral();
	        }


	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (ch === 0x2E) {
	            if (isDecimalDigit(source.charCodeAt(index + 1))) {
	                return scanNumericLiteral();
	            }
	            return scanPunctuator();
	        }

	        if (isDecimalDigit(ch)) {
	            return scanNumericLiteral();
	        }

	        // Slash (/) U+002F can also start a regex.
	        if (extra.tokenize && ch === 0x2F) {
	            return advanceSlash();
	        }

	        return scanPunctuator();
	    }

	    function collectToken() {
	        var loc, token, range, value;

	        skipComment();
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };

	        token = advance();
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };

	        if (token.type !== Token.EOF) {
	            value = source.slice(token.start, token.end);
	            extra.tokens.push({
	                type: TokenName[token.type],
	                value: value,
	                range: [token.start, token.end],
	                loc: loc
	            });
	        }

	        return token;
	    }

	    function lex() {
	        var token;

	        token = lookahead;
	        index = token.end;
	        lineNumber = token.lineNumber;
	        lineStart = token.lineStart;

	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();

	        index = token.end;
	        lineNumber = token.lineNumber;
	        lineStart = token.lineStart;

	        return token;
	    }

	    function peek() {
	        var pos, line, start;

	        pos = index;
	        line = lineNumber;
	        start = lineStart;
	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	        index = pos;
	        lineNumber = line;
	        lineStart = start;
	    }

	    function Position(line, column) {
	        this.line = line;
	        this.column = column;
	    }

	    function SourceLocation(startLine, startColumn, line, column) {
	        this.start = new Position(startLine, startColumn);
	        this.end = new Position(line, column);
	    }

	    SyntaxTreeDelegate = {

	        name: 'SyntaxTree',

	        processComment: function (node) {
	            var lastChild, trailingComments;

	            if (node.type === Syntax.Program) {
	                if (node.body.length > 0) {
	                    return;
	                }
	            }

	            if (extra.trailingComments.length > 0) {
	                if (extra.trailingComments[0].range[0] >= node.range[1]) {
	                    trailingComments = extra.trailingComments;
	                    extra.trailingComments = [];
	                } else {
	                    extra.trailingComments.length = 0;
	                }
	            } else {
	                if (extra.bottomRightStack.length > 0 &&
	                        extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments &&
	                        extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
	                    trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
	                    delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
	                }
	            }

	            // Eating the stack.
	            while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
	                lastChild = extra.bottomRightStack.pop();
	            }

	            if (lastChild) {
	                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
	                    node.leadingComments = lastChild.leadingComments;
	                    delete lastChild.leadingComments;
	                }
	            } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
	                node.leadingComments = extra.leadingComments;
	                extra.leadingComments = [];
	            }


	            if (trailingComments) {
	                node.trailingComments = trailingComments;
	            }

	            extra.bottomRightStack.push(node);
	        },

	        markEnd: function (node, startToken) {
	            if (extra.range) {
	                node.range = [startToken.start, index];
	            }
	            if (extra.loc) {
	                node.loc = new SourceLocation(
	                    startToken.startLineNumber === undefined ?  startToken.lineNumber : startToken.startLineNumber,
	                    startToken.start - (startToken.startLineStart === undefined ?  startToken.lineStart : startToken.startLineStart),
	                    lineNumber,
	                    index - lineStart
	                );
	                this.postProcess(node);
	            }

	            if (extra.attachComment) {
	                this.processComment(node);
	            }
	            return node;
	        },

	        postProcess: function (node) {
	            if (extra.source) {
	                node.loc.source = extra.source;
	            }
	            return node;
	        },

	        createArrayExpression: function (elements) {
	            return {
	                type: Syntax.ArrayExpression,
	                elements: elements
	            };
	        },

	        createAssignmentExpression: function (operator, left, right) {
	            return {
	                type: Syntax.AssignmentExpression,
	                operator: operator,
	                left: left,
	                right: right
	            };
	        },

	        createBinaryExpression: function (operator, left, right) {
	            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :
	                        Syntax.BinaryExpression;
	            return {
	                type: type,
	                operator: operator,
	                left: left,
	                right: right
	            };
	        },

	        createBlockStatement: function (body) {
	            return {
	                type: Syntax.BlockStatement,
	                body: body
	            };
	        },

	        createBreakStatement: function (label) {
	            return {
	                type: Syntax.BreakStatement,
	                label: label
	            };
	        },

	        createCallExpression: function (callee, args) {
	            return {
	                type: Syntax.CallExpression,
	                callee: callee,
	                'arguments': args
	            };
	        },

	        createCatchClause: function (param, body) {
	            return {
	                type: Syntax.CatchClause,
	                param: param,
	                body: body
	            };
	        },

	        createConditionalExpression: function (test, consequent, alternate) {
	            return {
	                type: Syntax.ConditionalExpression,
	                test: test,
	                consequent: consequent,
	                alternate: alternate
	            };
	        },

	        createContinueStatement: function (label) {
	            return {
	                type: Syntax.ContinueStatement,
	                label: label
	            };
	        },

	        createDebuggerStatement: function () {
	            return {
	                type: Syntax.DebuggerStatement
	            };
	        },

	        createDoWhileStatement: function (body, test) {
	            return {
	                type: Syntax.DoWhileStatement,
	                body: body,
	                test: test
	            };
	        },

	        createEmptyStatement: function () {
	            return {
	                type: Syntax.EmptyStatement
	            };
	        },

	        createExpressionStatement: function (expression) {
	            return {
	                type: Syntax.ExpressionStatement,
	                expression: expression
	            };
	        },

	        createForStatement: function (init, test, update, body) {
	            return {
	                type: Syntax.ForStatement,
	                init: init,
	                test: test,
	                update: update,
	                body: body
	            };
	        },

	        createForInStatement: function (left, right, body) {
	            return {
	                type: Syntax.ForInStatement,
	                left: left,
	                right: right,
	                body: body,
	                each: false
	            };
	        },

	        createFunctionDeclaration: function (id, params, defaults, body) {
	            return {
	                type: Syntax.FunctionDeclaration,
	                id: id,
	                params: params,
	                defaults: defaults,
	                body: body,
	                rest: null,
	                generator: false,
	                expression: false
	            };
	        },

	        createFunctionExpression: function (id, params, defaults, body) {
	            return {
	                type: Syntax.FunctionExpression,
	                id: id,
	                params: params,
	                defaults: defaults,
	                body: body,
	                rest: null,
	                generator: false,
	                expression: false
	            };
	        },

	        createIdentifier: function (name) {
	            return {
	                type: Syntax.Identifier,
	                name: name
	            };
	        },

	        createIfStatement: function (test, consequent, alternate) {
	            return {
	                type: Syntax.IfStatement,
	                test: test,
	                consequent: consequent,
	                alternate: alternate
	            };
	        },

	        createLabeledStatement: function (label, body) {
	            return {
	                type: Syntax.LabeledStatement,
	                label: label,
	                body: body
	            };
	        },

	        createLiteral: function (token) {
	            return {
	                type: Syntax.Literal,
	                value: token.value,
	                raw: source.slice(token.start, token.end)
	            };
	        },

	        createMemberExpression: function (accessor, object, property) {
	            return {
	                type: Syntax.MemberExpression,
	                computed: accessor === '[',
	                object: object,
	                property: property
	            };
	        },

	        createNewExpression: function (callee, args) {
	            return {
	                type: Syntax.NewExpression,
	                callee: callee,
	                'arguments': args
	            };
	        },

	        createObjectExpression: function (properties) {
	            return {
	                type: Syntax.ObjectExpression,
	                properties: properties
	            };
	        },

	        createPostfixExpression: function (operator, argument) {
	            return {
	                type: Syntax.UpdateExpression,
	                operator: operator,
	                argument: argument,
	                prefix: false
	            };
	        },

	        createProgram: function (body) {
	            return {
	                type: Syntax.Program,
	                body: body
	            };
	        },

	        createProperty: function (kind, key, value) {
	            return {
	                type: Syntax.Property,
	                key: key,
	                value: value,
	                kind: kind
	            };
	        },

	        createReturnStatement: function (argument) {
	            return {
	                type: Syntax.ReturnStatement,
	                argument: argument
	            };
	        },

	        createSequenceExpression: function (expressions) {
	            return {
	                type: Syntax.SequenceExpression,
	                expressions: expressions
	            };
	        },

	        createSwitchCase: function (test, consequent) {
	            return {
	                type: Syntax.SwitchCase,
	                test: test,
	                consequent: consequent
	            };
	        },

	        createSwitchStatement: function (discriminant, cases) {
	            return {
	                type: Syntax.SwitchStatement,
	                discriminant: discriminant,
	                cases: cases
	            };
	        },

	        createThisExpression: function () {
	            return {
	                type: Syntax.ThisExpression
	            };
	        },

	        createThrowStatement: function (argument) {
	            return {
	                type: Syntax.ThrowStatement,
	                argument: argument
	            };
	        },

	        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
	            return {
	                type: Syntax.TryStatement,
	                block: block,
	                guardedHandlers: guardedHandlers,
	                handlers: handlers,
	                finalizer: finalizer
	            };
	        },

	        createUnaryExpression: function (operator, argument) {
	            if (operator === '++' || operator === '--') {
	                return {
	                    type: Syntax.UpdateExpression,
	                    operator: operator,
	                    argument: argument,
	                    prefix: true
	                };
	            }
	            return {
	                type: Syntax.UnaryExpression,
	                operator: operator,
	                argument: argument,
	                prefix: true
	            };
	        },

	        createVariableDeclaration: function (declarations, kind) {
	            return {
	                type: Syntax.VariableDeclaration,
	                declarations: declarations,
	                kind: kind
	            };
	        },

	        createVariableDeclarator: function (id, init) {
	            return {
	                type: Syntax.VariableDeclarator,
	                id: id,
	                init: init
	            };
	        },

	        createWhileStatement: function (test, body) {
	            return {
	                type: Syntax.WhileStatement,
	                test: test,
	                body: body
	            };
	        },

	        createWithStatement: function (object, body) {
	            return {
	                type: Syntax.WithStatement,
	                object: object,
	                body: body
	            };
	        }
	    };

	    // Return true if there is a line terminator before the next token.

	    function peekLineTerminator() {
	        var pos, line, start, found;

	        pos = index;
	        line = lineNumber;
	        start = lineStart;
	        skipComment();
	        found = lineNumber !== line;
	        index = pos;
	        lineNumber = line;
	        lineStart = start;

	        return found;
	    }

	    // Throw an exception

	    function throwError(token, messageFormat) {
	        var error,
	            args = Array.prototype.slice.call(arguments, 2),
	            msg = messageFormat.replace(
	                /%(\d)/g,
	                function (whole, index) {
	                    assert(index < args.length, 'Message reference must be in range');
	                    return args[index];
	                }
	            );

	        if (typeof token.lineNumber === 'number') {
	            error = new Error('Line ' + token.lineNumber + ': ' + msg);
	            error.index = token.start;
	            error.lineNumber = token.lineNumber;
	            error.column = token.start - lineStart + 1;
	        } else {
	            error = new Error('Line ' + lineNumber + ': ' + msg);
	            error.index = index;
	            error.lineNumber = lineNumber;
	            error.column = index - lineStart + 1;
	        }

	        error.description = msg;
	        throw error;
	    }

	    function throwErrorTolerant() {
	        try {
	            throwError.apply(null, arguments);
	        } catch (e) {
	            if (extra.errors) {
	                extra.errors.push(e);
	            } else {
	                throw e;
	            }
	        }
	    }


	    // Throw an exception because of the token.

	    function throwUnexpected(token) {
	        if (token.type === Token.EOF) {
	            throwError(token, Messages.UnexpectedEOS);
	        }

	        if (token.type === Token.NumericLiteral) {
	            throwError(token, Messages.UnexpectedNumber);
	        }

	        if (token.type === Token.StringLiteral) {
	            throwError(token, Messages.UnexpectedString);
	        }

	        if (token.type === Token.Identifier) {
	            throwError(token, Messages.UnexpectedIdentifier);
	        }

	        if (token.type === Token.Keyword) {
	            if (isFutureReservedWord(token.value)) {
	                throwError(token, Messages.UnexpectedReserved);
	            } else if (strict && isStrictModeReservedWord(token.value)) {
	                throwErrorTolerant(token, Messages.StrictReservedWord);
	                return;
	            }
	            throwError(token, Messages.UnexpectedToken, token.value);
	        }

	        // BooleanLiteral, NullLiteral, or Punctuator.
	        throwError(token, Messages.UnexpectedToken, token.value);
	    }

	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.

	    function expect(value) {
	        var token = lex();
	        if (token.type !== Token.Punctuator || token.value !== value) {
	            throwUnexpected(token);
	        }
	    }

	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.

	    function expectKeyword(keyword) {
	        var token = lex();
	        if (token.type !== Token.Keyword || token.value !== keyword) {
	            throwUnexpected(token);
	        }
	    }

	    // Return true if the next token matches the specified punctuator.

	    function match(value) {
	        return lookahead.type === Token.Punctuator && lookahead.value === value;
	    }

	    // Return true if the next token matches the specified keyword

	    function matchKeyword(keyword) {
	        return lookahead.type === Token.Keyword && lookahead.value === keyword;
	    }

	    // Return true if the next token is an assignment operator

	    function matchAssign() {
	        var op;

	        if (lookahead.type !== Token.Punctuator) {
	            return false;
	        }
	        op = lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    }

	    function consumeSemicolon() {
	        var line, oldIndex = index, oldLineNumber = lineNumber,
	            oldLineStart = lineStart, oldLookahead = lookahead;

	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(index) === 0x3B || match(';')) {
	            lex();
	            return;
	        }

	        line = lineNumber;
	        skipComment();
	        if (lineNumber !== line) {
	            index = oldIndex;
	            lineNumber = oldLineNumber;
	            lineStart = oldLineStart;
	            lookahead = oldLookahead;
	            return;
	        }

	        if (lookahead.type !== Token.EOF && !match('}')) {
	            throwUnexpected(lookahead);
	        }
	    }

	    // Return true if provided expression is LeftHandSideExpression

	    function isLeftHandSide(expr) {
	        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
	    }

	    // 11.1.4 Array Initialiser

	    function parseArrayInitialiser() {
	        var elements = [], startToken;

	        startToken = lookahead;
	        expect('[');

	        while (!match(']')) {
	            if (match(',')) {
	                lex();
	                elements.push(null);
	            } else {
	                elements.push(parseAssignmentExpression());

	                if (!match(']')) {
	                    expect(',');
	                }
	            }
	        }

	        lex();

	        return delegate.markEnd(delegate.createArrayExpression(elements), startToken);
	    }

	    // 11.1.5 Object Initialiser

	    function parsePropertyFunction(param, first) {
	        var previousStrict, body, startToken;

	        previousStrict = strict;
	        startToken = lookahead;
	        body = parseFunctionSourceElements();
	        if (first && strict && isRestrictedWord(param[0].name)) {
	            throwErrorTolerant(first, Messages.StrictParamName);
	        }
	        strict = previousStrict;
	        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);
	    }

	    function parseObjectPropertyKey() {
	        var token, startToken;

	        startToken = lookahead;
	        token = lex();

	        // Note: This function is called only from parseObjectProperty(), where
	        // EOF and Punctuator tokens are already filtered out.

	        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
	            if (strict && token.octal) {
	                throwErrorTolerant(token, Messages.StrictOctalLiteral);
	            }
	            return delegate.markEnd(delegate.createLiteral(token), startToken);
	        }

	        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
	    }

	    function parseObjectProperty() {
	        var token, key, id, value, param, startToken;

	        token = lookahead;
	        startToken = lookahead;

	        if (token.type === Token.Identifier) {

	            id = parseObjectPropertyKey();

	            // Property Assignment: Getter and Setter.

	            if (token.value === 'get' && !match(':')) {
	                key = parseObjectPropertyKey();
	                expect('(');
	                expect(')');
	                value = parsePropertyFunction([]);
	                return delegate.markEnd(delegate.createProperty('get', key, value), startToken);
	            }
	            if (token.value === 'set' && !match(':')) {
	                key = parseObjectPropertyKey();
	                expect('(');
	                token = lookahead;
	                if (token.type !== Token.Identifier) {
	                    expect(')');
	                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
	                    value = parsePropertyFunction([]);
	                } else {
	                    param = [ parseVariableIdentifier() ];
	                    expect(')');
	                    value = parsePropertyFunction(param, token);
	                }
	                return delegate.markEnd(delegate.createProperty('set', key, value), startToken);
	            }
	            expect(':');
	            value = parseAssignmentExpression();
	            return delegate.markEnd(delegate.createProperty('init', id, value), startToken);
	        }
	        if (token.type === Token.EOF || token.type === Token.Punctuator) {
	            throwUnexpected(token);
	        } else {
	            key = parseObjectPropertyKey();
	            expect(':');
	            value = parseAssignmentExpression();
	            return delegate.markEnd(delegate.createProperty('init', key, value), startToken);
	        }
	    }

	    function parseObjectInitialiser() {
	        var properties = [], property, name, key, kind, map = {}, toString = String, startToken;

	        startToken = lookahead;

	        expect('{');

	        while (!match('}')) {
	            property = parseObjectProperty();

	            if (property.key.type === Syntax.Identifier) {
	                name = property.key.name;
	            } else {
	                name = toString(property.key.value);
	            }
	            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

	            key = '$' + name;
	            if (Object.prototype.hasOwnProperty.call(map, key)) {
	                if (map[key] === PropertyKind.Data) {
	                    if (strict && kind === PropertyKind.Data) {
	                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
	                    } else if (kind !== PropertyKind.Data) {
	                        throwErrorTolerant({}, Messages.AccessorDataProperty);
	                    }
	                } else {
	                    if (kind === PropertyKind.Data) {
	                        throwErrorTolerant({}, Messages.AccessorDataProperty);
	                    } else if (map[key] & kind) {
	                        throwErrorTolerant({}, Messages.AccessorGetSet);
	                    }
	                }
	                map[key] |= kind;
	            } else {
	                map[key] = kind;
	            }

	            properties.push(property);

	            if (!match('}')) {
	                expect(',');
	            }
	        }

	        expect('}');

	        return delegate.markEnd(delegate.createObjectExpression(properties), startToken);
	    }

	    // 11.1.6 The Grouping Operator

	    function parseGroupExpression() {
	        var expr;

	        expect('(');

	        expr = parseExpression();

	        expect(')');

	        return expr;
	    }


	    // 11.1 Primary Expressions

	    function parsePrimaryExpression() {
	        var type, token, expr, startToken;

	        if (match('(')) {
	            return parseGroupExpression();
	        }

	        if (match('[')) {
	            return parseArrayInitialiser();
	        }

	        if (match('{')) {
	            return parseObjectInitialiser();
	        }

	        type = lookahead.type;
	        startToken = lookahead;

	        if (type === Token.Identifier) {
	            expr =  delegate.createIdentifier(lex().value);
	        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
	            if (strict && lookahead.octal) {
	                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
	            }
	            expr = delegate.createLiteral(lex());
	        } else if (type === Token.Keyword) {
	            if (matchKeyword('function')) {
	                return parseFunctionExpression();
	            }
	            if (matchKeyword('this')) {
	                lex();
	                expr = delegate.createThisExpression();
	            } else {
	                throwUnexpected(lex());
	            }
	        } else if (type === Token.BooleanLiteral) {
	            token = lex();
	            token.value = (token.value === 'true');
	            expr = delegate.createLiteral(token);
	        } else if (type === Token.NullLiteral) {
	            token = lex();
	            token.value = null;
	            expr = delegate.createLiteral(token);
	        } else if (match('/') || match('/=')) {
	            if (typeof extra.tokens !== 'undefined') {
	                expr = delegate.createLiteral(collectRegex());
	            } else {
	                expr = delegate.createLiteral(scanRegExp());
	            }
	            peek();
	        } else {
	            throwUnexpected(lex());
	        }

	        return delegate.markEnd(expr, startToken);
	    }

	    // 11.2 Left-Hand-Side Expressions

	    function parseArguments() {
	        var args = [];

	        expect('(');

	        if (!match(')')) {
	            while (index < length) {
	                args.push(parseAssignmentExpression());
	                if (match(')')) {
	                    break;
	                }
	                expect(',');
	            }
	        }

	        expect(')');

	        return args;
	    }

	    function parseNonComputedProperty() {
	        var token, startToken;

	        startToken = lookahead;
	        token = lex();

	        if (!isIdentifierName(token)) {
	            throwUnexpected(token);
	        }

	        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
	    }

	    function parseNonComputedMember() {
	        expect('.');

	        return parseNonComputedProperty();
	    }

	    function parseComputedMember() {
	        var expr;

	        expect('[');

	        expr = parseExpression();

	        expect(']');

	        return expr;
	    }

	    function parseNewExpression() {
	        var callee, args, startToken;

	        startToken = lookahead;
	        expectKeyword('new');
	        callee = parseLeftHandSideExpression();
	        args = match('(') ? parseArguments() : [];

	        return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);
	    }

	    function parseLeftHandSideExpressionAllowCall() {
	        var expr, args, property, startToken, previousAllowIn = state.allowIn;

	        startToken = lookahead;
	        state.allowIn = true;
	        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

	        for (;;) {
	            if (match('.')) {
	                property = parseNonComputedMember();
	                expr = delegate.createMemberExpression('.', expr, property);
	            } else if (match('(')) {
	                args = parseArguments();
	                expr = delegate.createCallExpression(expr, args);
	            } else if (match('[')) {
	                property = parseComputedMember();
	                expr = delegate.createMemberExpression('[', expr, property);
	            } else {
	                break;
	            }
	            delegate.markEnd(expr, startToken);
	        }
	        state.allowIn = previousAllowIn;

	        return expr;
	    }

	    function parseLeftHandSideExpression() {
	        var expr, property, startToken;
	        assert(state.allowIn, 'callee of new expression always allow in keyword.');

	        startToken = lookahead;

	        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

	        while (match('.') || match('[')) {
	            if (match('[')) {
	                property = parseComputedMember();
	                expr = delegate.createMemberExpression('[', expr, property);
	            } else {
	                property = parseNonComputedMember();
	                expr = delegate.createMemberExpression('.', expr, property);
	            }
	            delegate.markEnd(expr, startToken);
	        }
	        return expr;
	    }

	    // 11.3 Postfix Expressions

	    function parsePostfixExpression() {
	        var expr, token, startToken = lookahead;

	        expr = parseLeftHandSideExpressionAllowCall();

	        if (lookahead.type === Token.Punctuator) {
	            if ((match('++') || match('--')) && !peekLineTerminator()) {
	                // 11.3.1, 11.3.2
	                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                    throwErrorTolerant({}, Messages.StrictLHSPostfix);
	                }

	                if (!isLeftHandSide(expr)) {
	                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	                }

	                token = lex();
	                expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);
	            }
	        }

	        return expr;
	    }

	    // 11.4 Unary Operators

	    function parseUnaryExpression() {
	        var token, expr, startToken;

	        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
	            expr = parsePostfixExpression();
	        } else if (match('++') || match('--')) {
	            startToken = lookahead;
	            token = lex();
	            expr = parseUnaryExpression();
	            // 11.4.4, 11.4.5
	            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                throwErrorTolerant({}, Messages.StrictLHSPrefix);
	            }

	            if (!isLeftHandSide(expr)) {
	                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	            }

	            expr = delegate.createUnaryExpression(token.value, expr);
	            expr = delegate.markEnd(expr, startToken);
	        } else if (match('+') || match('-') || match('~') || match('!')) {
	            startToken = lookahead;
	            token = lex();
	            expr = parseUnaryExpression();
	            expr = delegate.createUnaryExpression(token.value, expr);
	            expr = delegate.markEnd(expr, startToken);
	        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
	            startToken = lookahead;
	            token = lex();
	            expr = parseUnaryExpression();
	            expr = delegate.createUnaryExpression(token.value, expr);
	            expr = delegate.markEnd(expr, startToken);
	            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
	                throwErrorTolerant({}, Messages.StrictDelete);
	            }
	        } else {
	            expr = parsePostfixExpression();
	        }

	        return expr;
	    }

	    function binaryPrecedence(token, allowIn) {
	        var prec = 0;

	        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
	            return 0;
	        }

	        switch (token.value) {
	        case '||':
	            prec = 1;
	            break;

	        case '&&':
	            prec = 2;
	            break;

	        case '|':
	            prec = 3;
	            break;

	        case '^':
	            prec = 4;
	            break;

	        case '&':
	            prec = 5;
	            break;

	        case '==':
	        case '!=':
	        case '===':
	        case '!==':
	            prec = 6;
	            break;

	        case '<':
	        case '>':
	        case '<=':
	        case '>=':
	        case 'instanceof':
	            prec = 7;
	            break;

	        case 'in':
	            prec = allowIn ? 7 : 0;
	            break;

	        case '<<':
	        case '>>':
	        case '>>>':
	            prec = 8;
	            break;

	        case '+':
	        case '-':
	            prec = 9;
	            break;

	        case '*':
	        case '/':
	        case '%':
	            prec = 11;
	            break;

	        default:
	            break;
	        }

	        return prec;
	    }

	    // 11.5 Multiplicative Operators
	    // 11.6 Additive Operators
	    // 11.7 Bitwise Shift Operators
	    // 11.8 Relational Operators
	    // 11.9 Equality Operators
	    // 11.10 Binary Bitwise Operators
	    // 11.11 Binary Logical Operators

	    function parseBinaryExpression() {
	        var marker, markers, expr, token, prec, stack, right, operator, left, i;

	        marker = lookahead;
	        left = parseUnaryExpression();

	        token = lookahead;
	        prec = binaryPrecedence(token, state.allowIn);
	        if (prec === 0) {
	            return left;
	        }
	        token.prec = prec;
	        lex();

	        markers = [marker, lookahead];
	        right = parseUnaryExpression();

	        stack = [left, token, right];

	        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

	            // Reduce: make a binary expression from the three topmost entries.
	            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
	                right = stack.pop();
	                operator = stack.pop().value;
	                left = stack.pop();
	                expr = delegate.createBinaryExpression(operator, left, right);
	                markers.pop();
	                marker = markers[markers.length - 1];
	                delegate.markEnd(expr, marker);
	                stack.push(expr);
	            }

	            // Shift.
	            token = lex();
	            token.prec = prec;
	            stack.push(token);
	            markers.push(lookahead);
	            expr = parseUnaryExpression();
	            stack.push(expr);
	        }

	        // Final reduce to clean-up the stack.
	        i = stack.length - 1;
	        expr = stack[i];
	        markers.pop();
	        while (i > 1) {
	            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
	            i -= 2;
	            marker = markers.pop();
	            delegate.markEnd(expr, marker);
	        }

	        return expr;
	    }


	    // 11.12 Conditional Operator

	    function parseConditionalExpression() {
	        var expr, previousAllowIn, consequent, alternate, startToken;

	        startToken = lookahead;

	        expr = parseBinaryExpression();

	        if (match('?')) {
	            lex();
	            previousAllowIn = state.allowIn;
	            state.allowIn = true;
	            consequent = parseAssignmentExpression();
	            state.allowIn = previousAllowIn;
	            expect(':');
	            alternate = parseAssignmentExpression();

	            expr = delegate.createConditionalExpression(expr, consequent, alternate);
	            delegate.markEnd(expr, startToken);
	        }

	        return expr;
	    }

	    // 11.13 Assignment Operators

	    function parseAssignmentExpression() {
	        var token, left, right, node, startToken;

	        token = lookahead;
	        startToken = lookahead;

	        node = left = parseConditionalExpression();

	        if (matchAssign()) {
	            // LeftHandSideExpression
	            if (!isLeftHandSide(left)) {
	                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	            }

	            // 11.13.1
	            if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
	                throwErrorTolerant(token, Messages.StrictLHSAssignment);
	            }

	            token = lex();
	            right = parseAssignmentExpression();
	            node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);
	        }

	        return node;
	    }

	    // 11.14 Comma Operator

	    function parseExpression() {
	        var expr, startToken = lookahead;

	        expr = parseAssignmentExpression();

	        if (match(',')) {
	            expr = delegate.createSequenceExpression([ expr ]);

	            while (index < length) {
	                if (!match(',')) {
	                    break;
	                }
	                lex();
	                expr.expressions.push(parseAssignmentExpression());
	            }

	            delegate.markEnd(expr, startToken);
	        }

	        return expr;
	    }

	    // 12.1 Block

	    function parseStatementList() {
	        var list = [],
	            statement;

	        while (index < length) {
	            if (match('}')) {
	                break;
	            }
	            statement = parseSourceElement();
	            if (typeof statement === 'undefined') {
	                break;
	            }
	            list.push(statement);
	        }

	        return list;
	    }

	    function parseBlock() {
	        var block, startToken;

	        startToken = lookahead;
	        expect('{');

	        block = parseStatementList();

	        expect('}');

	        return delegate.markEnd(delegate.createBlockStatement(block), startToken);
	    }

	    // 12.2 Variable Statement

	    function parseVariableIdentifier() {
	        var token, startToken;

	        startToken = lookahead;
	        token = lex();

	        if (token.type !== Token.Identifier) {
	            throwUnexpected(token);
	        }

	        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
	    }

	    function parseVariableDeclaration(kind) {
	        var init = null, id, startToken;

	        startToken = lookahead;
	        id = parseVariableIdentifier();

	        // 12.2.1
	        if (strict && isRestrictedWord(id.name)) {
	            throwErrorTolerant({}, Messages.StrictVarName);
	        }

	        if (kind === 'const') {
	            expect('=');
	            init = parseAssignmentExpression();
	        } else if (match('=')) {
	            lex();
	            init = parseAssignmentExpression();
	        }

	        return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);
	    }

	    function parseVariableDeclarationList(kind) {
	        var list = [];

	        do {
	            list.push(parseVariableDeclaration(kind));
	            if (!match(',')) {
	                break;
	            }
	            lex();
	        } while (index < length);

	        return list;
	    }

	    function parseVariableStatement() {
	        var declarations;

	        expectKeyword('var');

	        declarations = parseVariableDeclarationList();

	        consumeSemicolon();

	        return delegate.createVariableDeclaration(declarations, 'var');
	    }

	    // kind may be `const` or `let`
	    // Both are experimental and not in the specification yet.
	    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
	    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
	    function parseConstLetDeclaration(kind) {
	        var declarations, startToken;

	        startToken = lookahead;

	        expectKeyword(kind);

	        declarations = parseVariableDeclarationList(kind);

	        consumeSemicolon();

	        return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);
	    }

	    // 12.3 Empty Statement

	    function parseEmptyStatement() {
	        expect(';');
	        return delegate.createEmptyStatement();
	    }

	    // 12.4 Expression Statement

	    function parseExpressionStatement() {
	        var expr = parseExpression();
	        consumeSemicolon();
	        return delegate.createExpressionStatement(expr);
	    }

	    // 12.5 If statement

	    function parseIfStatement() {
	        var test, consequent, alternate;

	        expectKeyword('if');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        consequent = parseStatement();

	        if (matchKeyword('else')) {
	            lex();
	            alternate = parseStatement();
	        } else {
	            alternate = null;
	        }

	        return delegate.createIfStatement(test, consequent, alternate);
	    }

	    // 12.6 Iteration Statements

	    function parseDoWhileStatement() {
	        var body, test, oldInIteration;

	        expectKeyword('do');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        expectKeyword('while');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        if (match(';')) {
	            lex();
	        }

	        return delegate.createDoWhileStatement(body, test);
	    }

	    function parseWhileStatement() {
	        var test, body, oldInIteration;

	        expectKeyword('while');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        return delegate.createWhileStatement(test, body);
	    }

	    function parseForVariableDeclaration() {
	        var token, declarations, startToken;

	        startToken = lookahead;
	        token = lex();
	        declarations = parseVariableDeclarationList();

	        return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);
	    }

	    function parseForStatement() {
	        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;

	        init = test = update = null;

	        expectKeyword('for');

	        expect('(');

	        if (match(';')) {
	            lex();
	        } else {
	            if (matchKeyword('var') || matchKeyword('let')) {
	                state.allowIn = false;
	                init = parseForVariableDeclaration();
	                state.allowIn = previousAllowIn;

	                if (init.declarations.length === 1 && matchKeyword('in')) {
	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                }
	            } else {
	                state.allowIn = false;
	                init = parseExpression();
	                state.allowIn = previousAllowIn;

	                if (matchKeyword('in')) {
	                    // LeftHandSideExpression
	                    if (!isLeftHandSide(init)) {
	                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);
	                    }

	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                }
	            }

	            if (typeof left === 'undefined') {
	                expect(';');
	            }
	        }

	        if (typeof left === 'undefined') {

	            if (!match(';')) {
	                test = parseExpression();
	            }
	            expect(';');

	            if (!match(')')) {
	                update = parseExpression();
	            }
	        }

	        expect(')');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        return (typeof left === 'undefined') ?
	                delegate.createForStatement(init, test, update, body) :
	                delegate.createForInStatement(left, right, body);
	    }

	    // 12.7 The continue statement

	    function parseContinueStatement() {
	        var label = null, key;

	        expectKeyword('continue');

	        // Optimize the most common form: 'continue;'.
	        if (source.charCodeAt(index) === 0x3B) {
	            lex();

	            if (!state.inIteration) {
	                throwError({}, Messages.IllegalContinue);
	            }

	            return delegate.createContinueStatement(null);
	        }

	        if (peekLineTerminator()) {
	            if (!state.inIteration) {
	                throwError({}, Messages.IllegalContinue);
	            }

	            return delegate.createContinueStatement(null);
	        }

	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();

	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError({}, Messages.UnknownLabel, label.name);
	            }
	        }

	        consumeSemicolon();

	        if (label === null && !state.inIteration) {
	            throwError({}, Messages.IllegalContinue);
	        }

	        return delegate.createContinueStatement(label);
	    }

	    // 12.8 The break statement

	    function parseBreakStatement() {
	        var label = null, key;

	        expectKeyword('break');

	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(index) === 0x3B) {
	            lex();

	            if (!(state.inIteration || state.inSwitch)) {
	                throwError({}, Messages.IllegalBreak);
	            }

	            return delegate.createBreakStatement(null);
	        }

	        if (peekLineTerminator()) {
	            if (!(state.inIteration || state.inSwitch)) {
	                throwError({}, Messages.IllegalBreak);
	            }

	            return delegate.createBreakStatement(null);
	        }

	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();

	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError({}, Messages.UnknownLabel, label.name);
	            }
	        }

	        consumeSemicolon();

	        if (label === null && !(state.inIteration || state.inSwitch)) {
	            throwError({}, Messages.IllegalBreak);
	        }

	        return delegate.createBreakStatement(label);
	    }

	    // 12.9 The return statement

	    function parseReturnStatement() {
	        var argument = null;

	        expectKeyword('return');

	        if (!state.inFunctionBody) {
	            throwErrorTolerant({}, Messages.IllegalReturn);
	        }

	        // 'return' followed by a space and an identifier is very common.
	        if (source.charCodeAt(index) === 0x20) {
	            if (isIdentifierStart(source.charCodeAt(index + 1))) {
	                argument = parseExpression();
	                consumeSemicolon();
	                return delegate.createReturnStatement(argument);
	            }
	        }

	        if (peekLineTerminator()) {
	            return delegate.createReturnStatement(null);
	        }

	        if (!match(';')) {
	            if (!match('}') && lookahead.type !== Token.EOF) {
	                argument = parseExpression();
	            }
	        }

	        consumeSemicolon();

	        return delegate.createReturnStatement(argument);
	    }

	    // 12.10 The with statement

	    function parseWithStatement() {
	        var object, body;

	        if (strict) {
	            // TODO(ikarienator): Should we update the test cases instead?
	            skipComment();
	            throwErrorTolerant({}, Messages.StrictModeWith);
	        }

	        expectKeyword('with');

	        expect('(');

	        object = parseExpression();

	        expect(')');

	        body = parseStatement();

	        return delegate.createWithStatement(object, body);
	    }

	    // 12.10 The swith statement

	    function parseSwitchCase() {
	        var test, consequent = [], statement, startToken;

	        startToken = lookahead;
	        if (matchKeyword('default')) {
	            lex();
	            test = null;
	        } else {
	            expectKeyword('case');
	            test = parseExpression();
	        }
	        expect(':');

	        while (index < length) {
	            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
	                break;
	            }
	            statement = parseStatement();
	            consequent.push(statement);
	        }

	        return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);
	    }

	    function parseSwitchStatement() {
	        var discriminant, cases, clause, oldInSwitch, defaultFound;

	        expectKeyword('switch');

	        expect('(');

	        discriminant = parseExpression();

	        expect(')');

	        expect('{');

	        cases = [];

	        if (match('}')) {
	            lex();
	            return delegate.createSwitchStatement(discriminant, cases);
	        }

	        oldInSwitch = state.inSwitch;
	        state.inSwitch = true;
	        defaultFound = false;

	        while (index < length) {
	            if (match('}')) {
	                break;
	            }
	            clause = parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    throwError({}, Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }

	        state.inSwitch = oldInSwitch;

	        expect('}');

	        return delegate.createSwitchStatement(discriminant, cases);
	    }

	    // 12.13 The throw statement

	    function parseThrowStatement() {
	        var argument;

	        expectKeyword('throw');

	        if (peekLineTerminator()) {
	            throwError({}, Messages.NewlineAfterThrow);
	        }

	        argument = parseExpression();

	        consumeSemicolon();

	        return delegate.createThrowStatement(argument);
	    }

	    // 12.14 The try statement

	    function parseCatchClause() {
	        var param, body, startToken;

	        startToken = lookahead;
	        expectKeyword('catch');

	        expect('(');
	        if (match(')')) {
	            throwUnexpected(lookahead);
	        }

	        param = parseVariableIdentifier();
	        // 12.14.1
	        if (strict && isRestrictedWord(param.name)) {
	            throwErrorTolerant({}, Messages.StrictCatchVariable);
	        }

	        expect(')');
	        body = parseBlock();
	        return delegate.markEnd(delegate.createCatchClause(param, body), startToken);
	    }

	    function parseTryStatement() {
	        var block, handlers = [], finalizer = null;

	        expectKeyword('try');

	        block = parseBlock();

	        if (matchKeyword('catch')) {
	            handlers.push(parseCatchClause());
	        }

	        if (matchKeyword('finally')) {
	            lex();
	            finalizer = parseBlock();
	        }

	        if (handlers.length === 0 && !finalizer) {
	            throwError({}, Messages.NoCatchOrFinally);
	        }

	        return delegate.createTryStatement(block, [], handlers, finalizer);
	    }

	    // 12.15 The debugger statement

	    function parseDebuggerStatement() {
	        expectKeyword('debugger');

	        consumeSemicolon();

	        return delegate.createDebuggerStatement();
	    }

	    // 12 Statements

	    function parseStatement() {
	        var type = lookahead.type,
	            expr,
	            labeledBody,
	            key,
	            startToken;

	        if (type === Token.EOF) {
	            throwUnexpected(lookahead);
	        }

	        if (type === Token.Punctuator && lookahead.value === '{') {
	            return parseBlock();
	        }

	        startToken = lookahead;

	        if (type === Token.Punctuator) {
	            switch (lookahead.value) {
	            case ';':
	                return delegate.markEnd(parseEmptyStatement(), startToken);
	            case '(':
	                return delegate.markEnd(parseExpressionStatement(), startToken);
	            default:
	                break;
	            }
	        }

	        if (type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'break':
	                return delegate.markEnd(parseBreakStatement(), startToken);
	            case 'continue':
	                return delegate.markEnd(parseContinueStatement(), startToken);
	            case 'debugger':
	                return delegate.markEnd(parseDebuggerStatement(), startToken);
	            case 'do':
	                return delegate.markEnd(parseDoWhileStatement(), startToken);
	            case 'for':
	                return delegate.markEnd(parseForStatement(), startToken);
	            case 'function':
	                return delegate.markEnd(parseFunctionDeclaration(), startToken);
	            case 'if':
	                return delegate.markEnd(parseIfStatement(), startToken);
	            case 'return':
	                return delegate.markEnd(parseReturnStatement(), startToken);
	            case 'switch':
	                return delegate.markEnd(parseSwitchStatement(), startToken);
	            case 'throw':
	                return delegate.markEnd(parseThrowStatement(), startToken);
	            case 'try':
	                return delegate.markEnd(parseTryStatement(), startToken);
	            case 'var':
	                return delegate.markEnd(parseVariableStatement(), startToken);
	            case 'while':
	                return delegate.markEnd(parseWhileStatement(), startToken);
	            case 'with':
	                return delegate.markEnd(parseWithStatement(), startToken);
	            default:
	                break;
	            }
	        }

	        expr = parseExpression();

	        // 12.12 Labelled Statements
	        if ((expr.type === Syntax.Identifier) && match(':')) {
	            lex();

	            key = '$' + expr.name;
	            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError({}, Messages.Redeclaration, 'Label', expr.name);
	            }

	            state.labelSet[key] = true;
	            labeledBody = parseStatement();
	            delete state.labelSet[key];
	            return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);
	        }

	        consumeSemicolon();

	        return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);
	    }

	    // 13 Function Definition

	    function parseFunctionSourceElements() {
	        var sourceElement, sourceElements = [], token, directive, firstRestricted,
	            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, startToken;

	        startToken = lookahead;
	        expect('{');

	        while (index < length) {
	            if (lookahead.type !== Token.StringLiteral) {
	                break;
	            }
	            token = lookahead;

	            sourceElement = parseSourceElement();
	            sourceElements.push(sourceElement);
	            if (sourceElement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }

	        oldLabelSet = state.labelSet;
	        oldInIteration = state.inIteration;
	        oldInSwitch = state.inSwitch;
	        oldInFunctionBody = state.inFunctionBody;

	        state.labelSet = {};
	        state.inIteration = false;
	        state.inSwitch = false;
	        state.inFunctionBody = true;

	        while (index < length) {
	            if (match('}')) {
	                break;
	            }
	            sourceElement = parseSourceElement();
	            if (typeof sourceElement === 'undefined') {
	                break;
	            }
	            sourceElements.push(sourceElement);
	        }

	        expect('}');

	        state.labelSet = oldLabelSet;
	        state.inIteration = oldInIteration;
	        state.inSwitch = oldInSwitch;
	        state.inFunctionBody = oldInFunctionBody;

	        return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);
	    }

	    function parseParams(firstRestricted) {
	        var param, params = [], token, stricted, paramSet, key, message;
	        expect('(');

	        if (!match(')')) {
	            paramSet = {};
	            while (index < length) {
	                token = lookahead;
	                param = parseVariableIdentifier();
	                key = '$' + token.value;
	                if (strict) {
	                    if (isRestrictedWord(token.value)) {
	                        stricted = token;
	                        message = Messages.StrictParamName;
	                    }
	                    if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
	                        stricted = token;
	                        message = Messages.StrictParamDupe;
	                    }
	                } else if (!firstRestricted) {
	                    if (isRestrictedWord(token.value)) {
	                        firstRestricted = token;
	                        message = Messages.StrictParamName;
	                    } else if (isStrictModeReservedWord(token.value)) {
	                        firstRestricted = token;
	                        message = Messages.StrictReservedWord;
	                    } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
	                        firstRestricted = token;
	                        message = Messages.StrictParamDupe;
	                    }
	                }
	                params.push(param);
	                paramSet[key] = true;
	                if (match(')')) {
	                    break;
	                }
	                expect(',');
	            }
	        }

	        expect(')');

	        return {
	            params: params,
	            stricted: stricted,
	            firstRestricted: firstRestricted,
	            message: message
	        };
	    }

	    function parseFunctionDeclaration() {
	        var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, startToken;

	        startToken = lookahead;

	        expectKeyword('function');
	        token = lookahead;
	        id = parseVariableIdentifier();
	        if (strict) {
	            if (isRestrictedWord(token.value)) {
	                throwErrorTolerant(token, Messages.StrictFunctionName);
	            }
	        } else {
	            if (isRestrictedWord(token.value)) {
	                firstRestricted = token;
	                message = Messages.StrictFunctionName;
	            } else if (isStrictModeReservedWord(token.value)) {
	                firstRestricted = token;
	                message = Messages.StrictReservedWord;
	            }
	        }

	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }

	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwError(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            throwErrorTolerant(stricted, message);
	        }
	        strict = previousStrict;

	        return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);
	    }

	    function parseFunctionExpression() {
	        var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict, startToken;

	        startToken = lookahead;
	        expectKeyword('function');

	        if (!match('(')) {
	            token = lookahead;
	            id = parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    throwErrorTolerant(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }

	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }

	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwError(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            throwErrorTolerant(stricted, message);
	        }
	        strict = previousStrict;

	        return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);
	    }

	    // 14 Program

	    function parseSourceElement() {
	        if (lookahead.type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'const':
	            case 'let':
	                return parseConstLetDeclaration(lookahead.value);
	            case 'function':
	                return parseFunctionDeclaration();
	            default:
	                return parseStatement();
	            }
	        }

	        if (lookahead.type !== Token.EOF) {
	            return parseStatement();
	        }
	    }

	    function parseSourceElements() {
	        var sourceElement, sourceElements = [], token, directive, firstRestricted;

	        while (index < length) {
	            token = lookahead;
	            if (token.type !== Token.StringLiteral) {
	                break;
	            }

	            sourceElement = parseSourceElement();
	            sourceElements.push(sourceElement);
	            if (sourceElement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }

	        while (index < length) {
	            sourceElement = parseSourceElement();
	            /* istanbul ignore if */
	            if (typeof sourceElement === 'undefined') {
	                break;
	            }
	            sourceElements.push(sourceElement);
	        }
	        return sourceElements;
	    }

	    function parseProgram() {
	        var body, startToken;

	        skipComment();
	        peek();
	        startToken = lookahead;
	        strict = false;

	        body = parseSourceElements();
	        return delegate.markEnd(delegate.createProgram(body), startToken);
	    }

	    function filterTokenLocation() {
	        var i, entry, token, tokens = [];

	        for (i = 0; i < extra.tokens.length; ++i) {
	            entry = extra.tokens[i];
	            token = {
	                type: entry.type,
	                value: entry.value
	            };
	            if (extra.range) {
	                token.range = entry.range;
	            }
	            if (extra.loc) {
	                token.loc = entry.loc;
	            }
	            tokens.push(token);
	        }

	        extra.tokens = tokens;
	    }

	    function tokenize(code, options) {
	        var toString,
	            token,
	            tokens;

	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }

	        delegate = SyntaxTreeDelegate;
	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1
	        };

	        extra = {};

	        // Options matching.
	        options = options || {};

	        // Of course we collect tokens here.
	        options.tokens = true;
	        extra.tokens = [];
	        extra.tokenize = true;
	        // The following two fields are necessary to compute the Regex tokens.
	        extra.openParenToken = -1;
	        extra.openCurlyToken = -1;

	        extra.range = (typeof options.range === 'boolean') && options.range;
	        extra.loc = (typeof options.loc === 'boolean') && options.loc;

	        if (typeof options.comment === 'boolean' && options.comment) {
	            extra.comments = [];
	        }
	        if (typeof options.tolerant === 'boolean' && options.tolerant) {
	            extra.errors = [];
	        }

	        try {
	            peek();
	            if (lookahead.type === Token.EOF) {
	                return extra.tokens;
	            }

	            token = lex();
	            while (lookahead.type !== Token.EOF) {
	                try {
	                    token = lex();
	                } catch (lexError) {
	                    token = lookahead;
	                    if (extra.errors) {
	                        extra.errors.push(lexError);
	                        // We have to break on the first error
	                        // to avoid infinite loops.
	                        break;
	                    } else {
	                        throw lexError;
	                    }
	                }
	            }

	            filterTokenLocation();
	            tokens = extra.tokens;
	            if (typeof extra.comments !== 'undefined') {
	                tokens.comments = extra.comments;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                tokens.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }
	        return tokens;
	    }

	    function parse(code, options) {
	        var program, toString;

	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }

	        delegate = SyntaxTreeDelegate;
	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1
	        };

	        extra = {};
	        if (typeof options !== 'undefined') {
	            extra.range = (typeof options.range === 'boolean') && options.range;
	            extra.loc = (typeof options.loc === 'boolean') && options.loc;
	            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

	            if (extra.loc && options.source !== null && options.source !== undefined) {
	                extra.source = toString(options.source);
	            }

	            if (typeof options.tokens === 'boolean' && options.tokens) {
	                extra.tokens = [];
	            }
	            if (typeof options.comment === 'boolean' && options.comment) {
	                extra.comments = [];
	            }
	            if (typeof options.tolerant === 'boolean' && options.tolerant) {
	                extra.errors = [];
	            }
	            if (extra.attachComment) {
	                extra.range = true;
	                extra.comments = [];
	                extra.bottomRightStack = [];
	                extra.trailingComments = [];
	                extra.leadingComments = [];
	            }
	        }

	        try {
	            program = parseProgram();
	            if (typeof extra.comments !== 'undefined') {
	                program.comments = extra.comments;
	            }
	            if (typeof extra.tokens !== 'undefined') {
	                filterTokenLocation();
	                program.tokens = extra.tokens;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                program.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }

	        return program;
	    }

	    // Sync with *.json manifests.
	    exports.version = '1.2.5';

	    exports.tokenize = tokenize;

	    exports.parse = parse;

	    // Deep copy.
	   /* istanbul ignore next */
	    exports.Syntax = (function () {
	        var name, types = {};

	        if (typeof Object.create === 'function') {
	            types = Object.create(null);
	        }

	        for (name in Syntax) {
	            if (Syntax.hasOwnProperty(name)) {
	                types[name] = Syntax[name];
	            }
	        }

	        if (typeof Object.freeze === 'function') {
	            Object.freeze(types);
	        }

	        return types;
	    }());

	}));
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 238 */
/*!**************************************************************!*\
  !*** ./~/ndarray-fill/~/cwise/~/cwise-parser/~/uniq/uniq.js ***!
  \**************************************************************/
/***/ function(module, exports) {

	"use strict"

	function unique_pred(list, compare) {
	  var ptr = 1
	    , len = list.length
	    , a=list[0], b=list[0]
	  for(var i=1; i<len; ++i) {
	    b = a
	    a = list[i]
	    if(compare(a, b)) {
	      if(i === ptr) {
	        ptr++
	        continue
	      }
	      list[ptr++] = a
	    }
	  }
	  list.length = ptr
	  return list
	}

	function unique_eq(list) {
	  var ptr = 1
	    , len = list.length
	    , a=list[0], b = list[0]
	  for(var i=1; i<len; ++i, b=a) {
	    b = a
	    a = list[i]
	    if(a !== b) {
	      if(i === ptr) {
	        ptr++
	        continue
	      }
	      list[ptr++] = a
	    }
	  }
	  list.length = ptr
	  return list
	}

	function unique(list, compare, sorted) {
	  if(list.length === 0) {
	    return list
	  }
	  if(compare) {
	    if(!sorted) {
	      list.sort(compare)
	    }
	    return unique_pred(list, compare)
	  }
	  if(!sorted) {
	    list.sort()
	  }
	  return unique_eq(list)
	}

	module.exports = unique


/***/ },
/* 239 */
/*!*************************************************************!*\
  !*** ./~/ndarray-fill/~/cwise/~/cwise-compiler/compiler.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict"

	var createThunk = __webpack_require__(/*! ./lib/thunk.js */ 240)

	function Procedure() {
	  this.argTypes = []
	  this.shimArgs = []
	  this.arrayArgs = []
	  this.arrayBlockIndices = []
	  this.scalarArgs = []
	  this.offsetArgs = []
	  this.offsetArgIndex = []
	  this.indexArgs = []
	  this.shapeArgs = []
	  this.funcName = ""
	  this.pre = null
	  this.body = null
	  this.post = null
	  this.debug = false
	}

	function compileCwise(user_args) {
	  //Create procedure
	  var proc = new Procedure()
	  
	  //Parse blocks
	  proc.pre    = user_args.pre
	  proc.body   = user_args.body
	  proc.post   = user_args.post

	  //Parse arguments
	  var proc_args = user_args.args.slice(0)
	  proc.argTypes = proc_args
	  for(var i=0; i<proc_args.length; ++i) {
	    var arg_type = proc_args[i]
	    if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
	      proc.argTypes[i] = "array"
	      proc.arrayArgs.push(i)
	      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)
	      proc.shimArgs.push("array" + i)
	      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
	        throw new Error("cwise: pre() block may not reference array args")
	      }
	      if(i < proc.post.args.length && proc.post.args[i].count>0) {
	        throw new Error("cwise: post() block may not reference array args")
	      }
	    } else if(arg_type === "scalar") {
	      proc.scalarArgs.push(i)
	      proc.shimArgs.push("scalar" + i)
	    } else if(arg_type === "index") {
	      proc.indexArgs.push(i)
	      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
	        throw new Error("cwise: pre() block may not reference array index")
	      }
	      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
	        throw new Error("cwise: body() block may not write to array index")
	      }
	      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
	        throw new Error("cwise: post() block may not reference array index")
	      }
	    } else if(arg_type === "shape") {
	      proc.shapeArgs.push(i)
	      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
	        throw new Error("cwise: pre() block may not write to array shape")
	      }
	      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
	        throw new Error("cwise: body() block may not write to array shape")
	      }
	      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
	        throw new Error("cwise: post() block may not write to array shape")
	      }
	    } else if(typeof arg_type === "object" && arg_type.offset) {
	      proc.argTypes[i] = "offset"
	      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
	      proc.offsetArgIndex.push(i)
	    } else {
	      throw new Error("cwise: Unknown argument type " + proc_args[i])
	    }
	  }
	  
	  //Make sure at least one array argument was specified
	  if(proc.arrayArgs.length <= 0) {
	    throw new Error("cwise: No array arguments specified")
	  }
	  
	  //Make sure arguments are correct
	  if(proc.pre.args.length > proc_args.length) {
	    throw new Error("cwise: Too many arguments in pre() block")
	  }
	  if(proc.body.args.length > proc_args.length) {
	    throw new Error("cwise: Too many arguments in body() block")
	  }
	  if(proc.post.args.length > proc_args.length) {
	    throw new Error("cwise: Too many arguments in post() block")
	  }

	  //Check debug flag
	  proc.debug = !!user_args.printCode || !!user_args.debug
	  
	  //Retrieve name
	  proc.funcName = user_args.funcName || "cwise"
	  
	  //Read in block size
	  proc.blockSize = user_args.blockSize || 64

	  return createThunk(proc)
	}

	module.exports = compileCwise


/***/ },
/* 240 */
/*!**************************************************************!*\
  !*** ./~/ndarray-fill/~/cwise/~/cwise-compiler/lib/thunk.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict"

	// The function below is called when constructing a cwise function object, and does the following:
	// A function object is constructed which accepts as argument a compilation function and returns another function.
	// It is this other function that is eventually returned by createThunk, and this function is the one that actually
	// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
	// The compilation passed to the first function object is used for compiling new functions.
	// Once this function object is created, it is called with compile as argument, where the first argument of compile
	// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
	// So createThunk roughly works like this:
	// function createThunk(proc) {
	//   var thunk = function(compileBound) {
	//     var CACHED = {}
	//     return function(arrays and scalars) {
	//       if (dtype and order of arrays in CACHED) {
	//         var func = CACHED[dtype and order of arrays]
	//       } else {
	//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
	//       }
	//       return func(arrays and scalars)
	//     }
	//   }
	//   return thunk(compile.bind1(proc))
	// }

	var compile = __webpack_require__(/*! ./compile.js */ 241)

	function createThunk(proc) {
	  var code = ["'use strict'", "var CACHED={}"]
	  var vars = []
	  var thunkName = proc.funcName + "_cwise_thunk"
	  
	  //Build thunk
	  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
	  var typesig = []
	  var string_typesig = []
	  var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
	                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")]
	  var shapeLengthConditions = [], shapeConditions = []
	  // Process array arguments
	  for(var i=0; i<proc.arrayArgs.length; ++i) {
	    var j = proc.arrayArgs[i]
	    vars.push(["t", j, "=array", j, ".dtype,",
	               "r", j, "=array", j, ".order"].join(""))
	    typesig.push("t" + j)
	    typesig.push("r" + j)
	    string_typesig.push("t"+j)
	    string_typesig.push("r"+j+".join()")
	    proc_args.push("array" + j + ".data")
	    proc_args.push("array" + j + ".stride")
	    proc_args.push("array" + j + ".offset|0")
	    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
	      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))
	      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]")
	    }
	  }
	  // Check for shape equality
	  if (proc.arrayArgs.length > 1) {
	    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')")
	    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {")
	    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')")
	    code.push("}")
	  }
	  // Process scalar arguments
	  for(var i=0; i<proc.scalarArgs.length; ++i) {
	    proc_args.push("scalar" + proc.scalarArgs[i])
	  }
	  // Check for cached function (and if not present, generate it)
	  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
	  vars.push("proc=CACHED[type]")
	  code.push("var " + vars.join(","))
	  
	  code.push(["if(!proc){",
	             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
	             "return proc(", proc_args.join(","), ")}"].join(""))

	  if(proc.debug) {
	    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------")
	  }
	  
	  //Compile thunk
	  var thunk = new Function("compile", code.join("\n"))
	  return thunk(compile.bind(undefined, proc))
	}

	module.exports = createThunk


/***/ },
/* 241 */
/*!****************************************************************!*\
  !*** ./~/ndarray-fill/~/cwise/~/cwise-compiler/lib/compile.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict"

	var uniq = __webpack_require__(/*! uniq */ 242)

	// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
	// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
	function innerFill(order, proc, body) {
	  var dimension = order.length
	    , nargs = proc.arrayArgs.length
	    , has_index = proc.indexArgs.length>0
	    , code = []
	    , vars = []
	    , idx=0, pidx=0, i, j
	  for(i=0; i<dimension; ++i) { // Iteration variables
	    vars.push(["i",i,"=0"].join(""))
	  }
	  //Compute scan deltas
	  for(j=0; j<nargs; ++j) {
	    for(i=0; i<dimension; ++i) {
	      pidx = idx
	      idx = order[i]
	      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
	        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
	      } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
	        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
	      }
	    }
	  }
	  code.push("var " + vars.join(","))
	  //Scan loop
	  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
	    idx = order[i]
	    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
	  }
	  //Push body of inner loop
	  code.push(body)
	  //Advance scan pointers
	  for(i=0; i<dimension; ++i) {
	    pidx = idx
	    idx = order[i]
	    for(j=0; j<nargs; ++j) {
	      code.push(["p",j,"+=d",j,"s",i].join(""))
	    }
	    if(has_index) {
	      if(i > 0) {
	        code.push(["index[",pidx,"]-=s",pidx].join(""))
	      }
	      code.push(["++index[",idx,"]"].join(""))
	    }
	    code.push("}")
	  }
	  return code.join("\n")
	}

	// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
	// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
	//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
	function outerFill(matched, order, proc, body) {
	  var dimension = order.length
	    , nargs = proc.arrayArgs.length
	    , blockSize = proc.blockSize
	    , has_index = proc.indexArgs.length > 0
	    , code = []
	  for(var i=0; i<nargs; ++i) {
	    code.push(["var offset",i,"=p",i].join(""))
	  }
	  //Generate loops for unmatched dimensions
	  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
	  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
	  for(var i=matched; i<dimension; ++i) {
	    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")) // Iterate back to front
	    code.push(["if(j",i,"<",blockSize,"){"].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
	    code.push(["s",order[i],"=j",i].join(""))
	    code.push(["j",i,"=0"].join(""))
	    code.push(["}else{s",order[i],"=",blockSize].join(""))
	    code.push(["j",i,"-=",blockSize,"}"].join(""))
	    if(has_index) {
	      code.push(["index[",order[i],"]=j",i].join(""))
	    }
	  }
	  for(var i=0; i<nargs; ++i) {
	    var indexStr = ["offset"+i]
	    for(var j=matched; j<dimension; ++j) {
	      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
	    }
	    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
	  }
	  code.push(innerFill(order, proc, body))
	  for(var i=matched; i<dimension; ++i) {
	    code.push("}")
	  }
	  return code.join("\n")
	}

	//Count the number of compatible inner orders
	// This is the length of the longest common prefix of the arrays in orders.
	// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
	// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
	function countMatches(orders) {
	  var matched = 0, dimension = orders[0].length
	  while(matched < dimension) {
	    for(var j=1; j<orders.length; ++j) {
	      if(orders[j][matched] !== orders[0][matched]) {
	        return matched
	      }
	    }
	    ++matched
	  }
	  return matched
	}

	//Processes a block according to the given data types
	// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
	function processBlock(block, proc, dtypes) {
	  var code = block.body
	  var pre = []
	  var post = []
	  for(var i=0; i<block.args.length; ++i) {
	    var carg = block.args[i]
	    if(carg.count <= 0) {
	      continue
	    }
	    var re = new RegExp(carg.name, "g")
	    var ptrStr = ""
	    var arrNum = proc.arrayArgs.indexOf(i)
	    switch(proc.argTypes[i]) {
	      case "offset":
	        var offArgIndex = proc.offsetArgIndex.indexOf(i)
	        var offArg = proc.offsetArgs[offArgIndex]
	        arrNum = offArg.array
	        ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
	      case "array":
	        ptrStr = "p" + arrNum + ptrStr
	        var localStr = "l" + i
	        var arrStr = "a" + arrNum
	        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
	          if(carg.count === 1) { // Argument/array used only once(?)
	            if(dtypes[arrNum] === "generic") {
	              if(carg.lvalue) {
	                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
	                code = code.replace(re, localStr)
	                post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
	              } else {
	                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
	              }
	            } else {
	              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
	            }
	          } else if(dtypes[arrNum] === "generic") {
	            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
	            code = code.replace(re, localStr)
	            if(carg.lvalue) {
	              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
	            }
	          } else {
	            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
	            code = code.replace(re, localStr)
	            if(carg.lvalue) {
	              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
	            }
	          }
	        } else { // Argument to body is a "block"
	          var reStrArr = [carg.name], ptrStrArr = [ptrStr]
	          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
	            reStrArr.push("\\s*\\[([^\\]]+)\\]")
	            ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j) // Matched index times stride
	          }
	          re = new RegExp(reStrArr.join(""), "g")
	          ptrStr = ptrStrArr.join("+")
	          if(dtypes[arrNum] === "generic") {
	            /*if(carg.lvalue) {
	              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
	              code = code.replace(re, localStr)
	              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
	            } else {
	              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
	            }*/
	            throw new Error("cwise: Generic arrays not supported in combination with blocks!")
	          } else {
	            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
	            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
	          }
	        }
	      break
	      case "scalar":
	        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
	      break
	      case "index":
	        code = code.replace(re, "index")
	      break
	      case "shape":
	        code = code.replace(re, "shape")
	      break
	    }
	  }
	  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
	}

	function typeSummary(dtypes) {
	  var summary = new Array(dtypes.length)
	  var allEqual = true
	  for(var i=0; i<dtypes.length; ++i) {
	    var t = dtypes[i]
	    var digits = t.match(/\d+/)
	    if(!digits) {
	      digits = ""
	    } else {
	      digits = digits[0]
	    }
	    if(t.charAt(0) === 0) {
	      summary[i] = "u" + t.charAt(1) + digits
	    } else {
	      summary[i] = t.charAt(0) + digits
	    }
	    if(i > 0) {
	      allEqual = allEqual && summary[i] === summary[i-1]
	    }
	  }
	  if(allEqual) {
	    return summary[0]
	  }
	  return summary.join("")
	}

	//Generates a cwise operator
	function generateCWiseOp(proc, typesig) {

	  //Compute dimension
	  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
	  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0
	  var orders = new Array(proc.arrayArgs.length)
	  var dtypes = new Array(proc.arrayArgs.length)
	  for(var i=0; i<proc.arrayArgs.length; ++i) {
	    dtypes[i] = typesig[2*i]
	    orders[i] = typesig[2*i+1]
	  }
	  
	  //Determine where block and loop indices start and end
	  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
	  var loopBegin = [], loopEnd = [] // These indices are iterated over
	  var loopOrders = [] // orders restricted to the loop indices
	  for(var i=0; i<proc.arrayArgs.length; ++i) {
	    if (proc.arrayBlockIndices[i]<0) {
	      loopBegin.push(0)
	      loopEnd.push(dimension)
	      blockBegin.push(dimension)
	      blockEnd.push(dimension+proc.arrayBlockIndices[i])
	    } else {
	      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
	      loopEnd.push(proc.arrayBlockIndices[i]+dimension)
	      blockBegin.push(0)
	      blockEnd.push(proc.arrayBlockIndices[i])
	    }
	    var newOrder = []
	    for(var j=0; j<orders[i].length; j++) {
	      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
	        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
	      }
	    }
	    loopOrders.push(newOrder)
	  }

	  //First create arguments for procedure
	  var arglist = ["SS"] // SS is the overall shape over which we iterate
	  var code = ["'use strict'"]
	  var vars = []
	  
	  for(var j=0; j<dimension; ++j) {
	    vars.push(["s", j, "=SS[", j, "]"].join("")) // The limits for each dimension.
	  }
	  for(var i=0; i<proc.arrayArgs.length; ++i) {
	    arglist.push("a"+i) // Actual data array
	    arglist.push("t"+i) // Strides
	    arglist.push("p"+i) // Offset in the array at which the data starts (also used for iterating over the data)
	    
	    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
	      vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""))
	    }
	    
	    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
	      vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""))
	    }
	  }
	  for(var i=0; i<proc.scalarArgs.length; ++i) {
	    arglist.push("Y" + i)
	  }
	  if(proc.shapeArgs.length > 0) {
	    vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
	  }
	  if(proc.indexArgs.length > 0) {
	    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
	    var zeros = new Array(dimension)
	    for(var i=0; i<dimension; ++i) {
	      zeros[i] = "0"
	    }
	    vars.push(["index=[", zeros.join(","), "]"].join(""))
	  }
	  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
	    var off_arg = proc.offsetArgs[i]
	    var init_string = []
	    for(var j=0; j<off_arg.offset.length; ++j) {
	      if(off_arg.offset[j] === 0) {
	        continue
	      } else if(off_arg.offset[j] === 1) {
	        init_string.push(["t", off_arg.array, "p", j].join(""))      
	      } else {
	        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
	      }
	    }
	    if(init_string.length === 0) {
	      vars.push("q" + i + "=0")
	    } else {
	      vars.push(["q", i, "=", init_string.join("+")].join(""))
	    }
	  }

	  //Prepare this variables
	  var thisVars = uniq([].concat(proc.pre.thisVars)
	                      .concat(proc.body.thisVars)
	                      .concat(proc.post.thisVars))
	  vars = vars.concat(thisVars)
	  code.push("var " + vars.join(","))
	  for(var i=0; i<proc.arrayArgs.length; ++i) {
	    code.push("p"+i+"|=0")
	  }
	  
	  //Inline prelude
	  if(proc.pre.body.length > 3) {
	    code.push(processBlock(proc.pre, proc, dtypes))
	  }

	  //Process body
	  var body = processBlock(proc.body, proc, dtypes)
	  var matched = countMatches(loopOrders)
	  if(matched < dimension) {
	    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
	  } else {
	    code.push(innerFill(loopOrders[0], proc, body))
	  }

	  //Inline epilog
	  if(proc.post.body.length > 3) {
	    code.push(processBlock(proc.post, proc, dtypes))
	  }
	  
	  if(proc.debug) {
	    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------")
	  }
	  
	  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
	  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
	  return f()
	}
	module.exports = generateCWiseOp


/***/ },
/* 242 */
/*!****************************************************************!*\
  !*** ./~/ndarray-fill/~/cwise/~/cwise-compiler/~/uniq/uniq.js ***!
  \****************************************************************/
/***/ function(module, exports) {

	"use strict"

	function unique_pred(list, compare) {
	  var ptr = 1
	    , len = list.length
	    , a=list[0], b=list[0]
	  for(var i=1; i<len; ++i) {
	    b = a
	    a = list[i]
	    if(compare(a, b)) {
	      if(i === ptr) {
	        ptr++
	        continue
	      }
	      list[ptr++] = a
	    }
	  }
	  list.length = ptr
	  return list
	}

	function unique_eq(list) {
	  var ptr = 1
	    , len = list.length
	    , a=list[0], b = list[0]
	  for(var i=1; i<len; ++i, b=a) {
	    b = a
	    a = list[i]
	    if(a !== b) {
	      if(i === ptr) {
	        ptr++
	        continue
	      }
	      list[ptr++] = a
	    }
	  }
	  list.length = ptr
	  return list
	}

	function unique(list, compare, sorted) {
	  if(list.length === 0) {
	    return list
	  }
	  if(compare) {
	    if(!sorted) {
	      list.sort(compare)
	    }
	    return unique_pred(list, compare)
	  }
	  if(!sorted) {
	    list.sort()
	  }
	  return unique_eq(list)
	}

	module.exports = unique


/***/ },
/* 243 */
/*!***************************************!*\
  !*** ./static/js/procedural/biome.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 1)["default"];

	exports.__esModule = true;

	var _threeJs = __webpack_require__(/*! three.js */ 195);

	var _threeJs2 = _interopRequireDefault(_threeJs);

	var _proceduralNoise = __webpack_require__(/*! procedural/noise */ 228);

	var Biome = function Biome() {
	    this.chunks = {};

	    this.put = function (x, y, chunk) {
	        if (!(x in this.chunks)) {
	            this.chunks[x] = {};
	        }

	        this.chunks[x][y] = chunk;
	    };

	    this.get = function (x, y) {
	        if (!(x in this.chunks)) {
	            return undefined;
	        }

	        return this.chunks[x][y];
	    };

	    this.cull = function (cb) {
	        for (var xc in this.chunks) {
	            for (var yc in this.chunks[xc]) {
	                if (cb(xc, yc, this.chunks[xc][yc])) {
	                    delete this.chunks[xc][yc];
	                }
	            }
	        }
	    };
	};

	var BiomeChunk = function BiomeChunk(terrain, water) {
	    this.terrain = terrain;
	    this.water = water;
	};

	var BiomeMap = function BiomeMap(size) {
	    var data = new Uint8Array(3 * size * size);
	    for (var i = 0; i < size; i++) {
	        for (var j = 0; j < size; j++) {
	            var z1 = 255 * _proceduralNoise.perlin(i / size, j / size, 4) | 0;
	            var z2 = 255 * _proceduralNoise.perlin(i / size, j / size, 8) | 0;

	            if (z1 < 64) {
	                data[0 + 3 * (i + size * j)] = 255;
	            } else if (z1 < 128) {
	                data[0 + 3 * (i + size * j)] = 128;
	            } else {
	                data[0 + 3 * (i + size * j)] = 0;
	            }

	            if (z2 < 64) {
	                data[1 + 3 * (i + size * j)] = 255;
	            } else if (z2 < 128) {
	                data[1 + 3 * (i + size * j)] = 128;
	            } else {
	                data[1 + 3 * (i + size * j)] = 0;
	            }
	        }
	    }

	    var texture = new _threeJs2["default"].DataTexture(data, size, size, _threeJs2["default"].RGBFormat);
	    texture.needsUpdate = true;
	    var geometry = new _threeJs2["default"].PlaneGeometry(size, size);
	    var material = new _threeJs2["default"].MeshBasicMaterial({
	        map: texture,
	        side: _threeJs2["default"].DoubleSide,
	        transparent: true,
	        opacity: 0.5
	    });

	    var mesh = new _threeJs2["default"].Mesh(geometry, material);
	    mesh.rotation.x = -90 * Math.PI / 180;
	    return mesh;
	};

	exports["default"] = { BiomeMap: BiomeMap, Biome: Biome, BiomeChunk: BiomeChunk };
	module.exports = exports["default"];

/***/ },
/* 244 */
/*!****************************************!*\
  !*** ./static/js/procedural/nebula.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _Math$log2 = __webpack_require__(/*! babel-runtime/core-js/math/log2 */ 245)["default"];

	exports.__esModule = true;

	var _engine = __webpack_require__(/*! engine */ 194);

	var _proceduralNoise = __webpack_require__(/*! procedural/noise */ 228);

	function shuffle(o) {
	    for (var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
	    return o;
	}

	var PerlinMaterial = function PerlinMaterial(width, height, side) {
	    var opacity = arguments.length <= 3 || arguments[3] === undefined ? 1 : arguments[3];

	    var canvas = document.createElement("canvas");
	    var context = canvas.getContext("2d");

	    canvas.width = width;
	    canvas.height = height;

	    var imageData = context.createImageData(width, height);

	    var offsetX = Math.random() * 100;
	    var offsetY = Math.random() * 100;

	    var rgb = [0, 1, 2];
	    shuffle(rgb);

	    var p0 = rgb[0];
	    var cx0 = Math.random() * 0.0051;
	    var cy0 = Math.random() * 0.0048;

	    var p1 = rgb[1];
	    var cx1 = Math.random() * 0.0024;
	    var cy1 = Math.random() * 0.0019;

	    var p2 = rgb[2];
	    var cx2 = Math.random() * 0.038;
	    var cy2 = Math.random() * 0.054;

	    for (var i = 0; i < width; i++) {
	        for (var j = 0; j < height; j++) {
	            var x = i + offsetX;
	            var y = j + offsetY;

	            // set opacity
	            var r = Math.sqrt(Math.pow((i - width / 2) / width, 2) + Math.pow((j - height / 2) / height, 2)) * Math.sqrt(2);
	            imageData.data[3 + 4 * (i + width * j)] = 255 * opacity * Math.pow(1 - r, 3);

	            imageData.data[p0 + 4 * (i + width * j)] = 2048 * Math.abs(_proceduralNoise.perlin(x * cx0, y * cy0, 3));
	            imageData.data[p1 + 4 * (i + width * j)] = 1024 * Math.abs(_proceduralNoise.perlin(x * cx1, y * cy1, 5));
	            imageData.data[p2 + 4 * (i + width * j)] = 256 * Math.abs(_proceduralNoise.perlin(x * cx2, y * cy2, 7));
	        }
	    }

	    context.putImageData(imageData, 0, 0);

	    var texture = new _engine.THREE.Texture(canvas);
	    texture.needsUpdate = true;

	    var material = new _engine.THREE.MeshBasicMaterial({
	        map: texture,
	        transparent: true,
	        depthWrite: false
	    });

	    if (side !== undefined) {
	        material.side = side;
	    }
	    return material;
	};

	var Nebula = function Nebula(scale) {
	    var nebulas = new _engine.THREE.Object3D();

	    var area = scale * scale;

	    var R = 500 * Math.floor(100 * Math.random()) + 5000;
	    var theta = 2 * Math.PI * Math.random();
	    var phi = Math.acos(2 * Math.random() - 1);

	    // add some perlin textured sphere segments at close range
	    var nSpheres = Math.floor(Math.random() * 4) + 3;
	    for (var i = 0; i < nSpheres; i++) {
	        var width = Math.pow(2, Math.floor(Math.random() + _Math$log2(scale) - 1 + 0.5));
	        var height = area / width;

	        var material = PerlinMaterial(width, height, _engine.THREE.DoubleSide, Math.random() * 0.2 + 0.5);

	        var phiStart = Math.random() * 2 * Math.PI;
	        var phiLength = Math.random() * Math.PI / 3 + Math.PI / 3;
	        var thetaStart = Math.random() * Math.PI / 2 + Math.PI / 12;
	        var thetaLength = Math.random() * (Math.PI - thetaStart - Math.PI / 6) + Math.PI / 4;

	        var segment = new _engine.THREE.Mesh(new _engine.THREE.SphereGeometry(R, 32, 32, phiStart, phiLength, thetaStart, thetaLength), material);
	        segment.rotation.z = Math.random() * Math.PI;

	        nebulas.add(segment);

	        R = 500 * Math.floor(100 * Math.random()) + 5000;
	        theta += Math.PI + Math.PI / 3 * Math.random();
	        phi += Math.PI + Math.PI / 3 * Math.random();
	    }

	    // add some perlin textured planes really far away for dat sweet parallax
	    R = 500 * Math.floor(100 * Math.random()) + 50000;
	    theta = 2 * Math.PI * Math.random();
	    phi = Math.acos(2 * Math.random() - 1);

	    var nPlanes = Math.floor(Math.random() * 3) + 3;
	    for (var i = 0; i < nPlanes; i++) {
	        var x = R * Math.cos(theta) * Math.sin(phi);
	        var y = R * Math.sin(theta) * Math.sin(phi);
	        var z = R * Math.cos(phi);

	        var width = Math.pow(2, Math.floor(Math.random() + _Math$log2(scale) - 1 + 0.5));
	        var height = area / width;
	        var material = PerlinMaterial(width, height, _engine.THREE.DoubleSide, Math.random() * 0.2 + 0.6);

	        var aura = new _engine.THREE.Mesh(new _engine.THREE.PlaneGeometry(width * scale, height * scale), material);
	        aura.position.set(x, y, z);
	        aura.lookAt(new _engine.THREE.Vector3());
	        aura.rotation.z = Math.random() * Math.PI * 2;
	        nebulas.add(aura);

	        R = 500 * Math.floor(100 * Math.random()) + 50000;
	        theta += Math.PI + 0.2 * Math.random();
	        phi += Math.PI + 0.2 * Math.random();
	    }

	    return nebulas;
	};
	exports.Nebula = Nebula;

/***/ },
/* 245 */
/*!**********************************************!*\
  !*** ./~/babel-runtime/core-js/math/log2.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(/*! core-js/library/fn/math/log2 */ 246), __esModule: true };

/***/ },
/* 246 */
/*!***********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/math/log2.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/es6.math.log2 */ 247);
	module.exports = __webpack_require__(/*! ../../modules/$.core */ 207).Math.log2;

/***/ },
/* 247 */
/*!********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.math.log2.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $def = __webpack_require__(/*! ./$.def */ 205);

	$def($def.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 248 */
/*!*******************************************!*\
  !*** ./static/js/procedural/starfield.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 1)["default"];

	exports.__esModule = true;

	var _engine = __webpack_require__(/*! engine */ 194);

	var _constMaterial = __webpack_require__(/*! const/material */ 219);

	var _constMaterial2 = _interopRequireDefault(_constMaterial);

	var Starfield = function Starfield(num, radius, filter) {
	    var starsGeometry = new _engine.THREE.Geometry();
	    for (var i = 0; i < num; i++) {
	        var phi = Math.random() * 2 * Math.PI;
	        var costheta = Math.random() * 2 - 1;
	        var u = Math.random();

	        var theta = Math.acos(costheta);
	        // generate some more stars near the center for exaggerated parallax effect
	        var R, r;
	        if (u < 0.2) {
	            R = radius * Math.pow(u, 0.5);
	            r = 0.5 + 2 * R / radius * Math.random();
	        } else if (u < 0.5) {
	            R = radius * 10 * u / 0.4;
	            r = 10 + 2 * R / radius * Math.random();
	        } else if (u < 0.95) {
	            R = radius * 20 * u / 0.7;
	            r = 20 + 2 * R / radius * Math.random();
	        } else {
	            R = radius * 20 * u / 0.95;
	            r = 30 + 2 * R / radius * Math.random();
	        }

	        var x = R * Math.sin(theta) * Math.cos(phi);
	        var y = R * Math.sin(theta) * Math.sin(phi);
	        var z = R * Math.cos(theta);

	        if (filter(x, y, z, R)) continue;

	        var starGeometry = new _engine.THREE.SphereGeometry(r);
	        var starMesh = new _engine.THREE.Mesh(starGeometry, _constMaterial2["default"].STAR);
	        starMesh.position.set(x, y, z);
	        starMesh.updateMatrix();
	        starsGeometry.merge(starGeometry, starMesh.matrix);
	    }

	    return new _engine.THREE.Mesh(starsGeometry, _constMaterial2["default"].STAR);
	};
	exports.Starfield = Starfield;

/***/ },
/* 249 */
/*!*********************************!*\
  !*** ./static/js/util/plane.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _engine = __webpack_require__(/*! engine */ 194);

	var _materials = __webpack_require__(/*! materials */ 217);

	var _proceduralNoise = __webpack_require__(/*! procedural/noise */ 228);

	function makeTerrain(size) {
	    var data = new Uint8Array(size * size);
	    for (var i = 0; i < size; i++) {
	        for (var j = 0; j < size; j++) {
	            data[i + size * j] = 255 * _proceduralNoise.perlin(i / size, j / size, 8) | 0;
	        }
	    }

	    return data;
	}

	exports["default"] = function (world_size, world, scene) {
	    var data = makeTerrain(world_size);

	    var size = Math.sqrt(data.length);
	    var geometry = new _engine.THREE.Geometry();

	    var seen = {};
	    function makePolygonMesh(x, y, z) {
	        var index = seen[x + " " + y + " " + z];
	        if (index !== undefined) {
	            return index;
	        }

	        var newIndex = geometry.vertices.length;
	        seen[x + " " + y + " " + z] = newIndex;
	        geometry.vertices.push(new _engine.THREE.Vector3(x, y, z));
	        return newIndex;
	    }

	    var w = 50;
	    for (var i = 0; i < size - 1; i++) {
	        for (var j = 0; j < size - 1; j++) {
	            var v1 = makePolygonMesh(w * (i - size / 2), w * (j - size / 2), data[i + size * j]);
	            var v2 = makePolygonMesh(w * (i + 1 - size / 2), w * (j - size / 2), data[i + 1 + size * j]);
	            var v3 = makePolygonMesh(w * (i - size / 2), w * (j + 1 - size / 2), data[i + size * (j + 1)]);
	            var v4 = makePolygonMesh(w * (i + 1 - size / 2), w * (j + 1 - size / 2), data[i + 1 + size * (j + 1)]);

	            //TODO dont alternate face sides
	            geometry.faces.push(new _engine.THREE.Face3(v1, v2, v3), new _engine.THREE.Face3(v2, v4, v3));
	        }
	    }

	    geometry.computeFaceNormals();

	    var mat = new _engine.THREE.MeshLambertMaterial({
	        color: 0x44DD88,
	        emissive: 0x002255,
	        side: _engine.THREE.DoubleSide
	    });
	    var mesh = new _engine.THREE.Mesh(geometry, mat);
	    mesh.receiveShadow = true;
	    mesh.castShadow = true;
	    mesh.rotation.x = -90 * Math.PI / 180;

	    var shape = new _engine.CANNON.ConvexPolyhedron(geometry.vertices.map(function (x) {
	        return new _engine.CANNON.Vec3(x.x, x.y, x.z);
	    }), geometry.faces.map(function (x) {
	        return [x.a, x.b, x.c];
	    }));
	    var body = new _engine.CANNON.Body({ mass: 0, material: _materials.NORMAL });
	    body.addShape(shape);
	    body.quaternion.setFromAxisAngle(new _engine.CANNON.Vec3(1, 0.2, 0), -Math.PI / 2);
	    body.position.set(0, 0, 0);

	    mesh.position.copy(body.position);
	    mesh.quaternion.copy(body.quaternion);

	    scene.add(mesh);
	    world.addBody(body);
	};

	module.exports = exports["default"];

/***/ },
/* 250 */
/*!*****************************!*\
  !*** ./static/js/amoeba.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _classCallCheck = __webpack_require__(/*! babel-runtime/helpers/class-call-check */ 193)["default"];

	exports.__esModule = true;

	var _engine = __webpack_require__(/*! engine */ 194);

	var _materials = __webpack_require__(/*! materials */ 217);

	var Amoeba = (function () {
	    function Amoeba(world, scene) {
	        var radius = arguments.length <= 2 || arguments[2] === undefined ? 20 : arguments[2];
	        var segments = arguments.length <= 3 || arguments[3] === undefined ? 4 : arguments[3];

	        _classCallCheck(this, Amoeba);

	        var geo = new _engine.THREE.SphereGeometry(radius, segments, segments);
	        var mat = new _engine.THREE.MeshLambertMaterial({ color: 0xffff00, emissive: 0xaa0033 });
	        this.mesh = new _engine.THREE.Mesh(geo, mat);
	        this.mesh.castShadow = true;

	        var shape = new _engine.CANNON.Sphere(radius);
	        this.body = new _engine.CANNON.Body({ mass: 0.1, material: _materials.NORMAL });
	        this.body.addShape(shape);

	        scene.add(this.mesh);
	        world.addBody(this.body);

	        this.update();
	    }

	    Amoeba.prototype.update = function update() {
	        this.mesh.position.copy(this.body.position);
	        this.mesh.quaternion.copy(this.body.quaternion);
	    };

	    return Amoeba;
	})();

	exports["default"] = Amoeba;
	module.exports = exports["default"];

/***/ },
/* 251 */
/*!****************************************!*\
  !*** ./static/js/amoeba_simulation.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _classCallCheck = __webpack_require__(/*! babel-runtime/helpers/class-call-check */ 193)["default"];

	var _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 1)["default"];

	exports.__esModule = true;

	var _engine = __webpack_require__(/*! engine */ 194);

	var _props = __webpack_require__(/*! props */ 218);

	var _utilPlane = __webpack_require__(/*! util/plane */ 249);

	var _utilPlane2 = _interopRequireDefault(_utilPlane);

	var _amoeba = __webpack_require__(/*! amoeba */ 250);

	var _amoeba2 = _interopRequireDefault(_amoeba);

	var AmoebaSimulation = (function () {
	    function AmoebaSimulation(container_id) {
	        var _this = this;

	        var chunkSize = arguments.length <= 1 || arguments[1] === undefined ? 32 : arguments[1];

	        _classCallCheck(this, AmoebaSimulation);

	        this.width = window.innerWidth;
	        this.height = window.innerHeight;
	        this.view_angle = 45;
	        this.aspect = this.width / this.height;
	        this.near = 0.1;
	        this.far = 10000;
	        this.chunkSize = chunkSize;

	        this.world = new _engine.CANNON.World();
	        this.world.gravity.set(0, -9.82, 0);

	        this.renderer = new _engine.THREE.WebGLRenderer({ alpha: true });
	        this.renderer.setSize(this.width, this.height);
	        this.renderer.setClearColor(0x000000, 1);
	        this.renderer.shadowMap.enabled = true;
	        this.renderer.shadowMap.soft = true;

	        this.camera = new _engine.THREE.PerspectiveCamera(this.view_angle, this.aspect, this.near, this.far);
	        this.camera.position.x = 500;
	        this.camera.position.y = 750;
	        this.camera.position.z = 500;

	        this.controls = new _engine.OrbitControls(this.camera, this.renderer.domElement);

	        this.scene = new _engine.THREE.Scene();

	        document.getElementById(container_id).appendChild(this.renderer.domElement);
	        window.addEventListener("resize", function () {
	            return _this.resize();
	        });
	    }

	    AmoebaSimulation.prototype.init = function init() {
	        this.scene.add(this.camera);
	        this.scene.add(_props.Axes(this.width));

	        var pointLight = new _engine.THREE.DirectionalLight(0xFFFF00, 0.8, 100);
	        pointLight.castShadow = true;
	        pointLight.position.set(this.chunkSize / 2, 50, -this.chunkSize / 2);
	        this.scene.add(pointLight);

	        _utilPlane2["default"](this.chunkSize, this.world, this.scene);

	        this.amoeba = new _amoeba2["default"](this.world, this.scene);
	        this.amoeba.body.position.set(1, 275, 0);

	        this.world.solver.iterations = 10;
	    };

	    AmoebaSimulation.prototype.resize = function resize() {
	        this.width = window.innerWidth;
	        this.height = window.innerHeight;
	        this.renderer.setSize(this.width, this.height);
	        this.camera.aspect = this.width / this.height;
	        this.camera.updateProjectionMatrix();
	    };

	    AmoebaSimulation.prototype.update = function update() {

	        // step physics
	        this.world.step(1 / 35);

	        // update based on physics
	        this.amoeba.update();
	    };

	    AmoebaSimulation.prototype.render = function render() {
	        this.renderer.render(this.scene, this.camera);
	    };

	    return AmoebaSimulation;
	})();

	exports["default"] = AmoebaSimulation;
	module.exports = exports["default"];

/***/ }
/******/ ]);
//# sourceMappingURL=index.js.map